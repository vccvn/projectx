(function (modules) {
    var installedModules = {}; function __webpack_require__(moduleId) {
        if (installedModules[moduleId]) { return installedModules[moduleId].exports; }
        var module = installedModules[moduleId] = { i: moduleId, l: false, exports: {} }; modules[moduleId].call(module.exports, module, module.exports, __webpack_require__); module.l = true; return module.exports;
    }
    __webpack_require__.m = modules; __webpack_require__.c = installedModules; __webpack_require__.d = function (exports, name, getter) { if (!__webpack_require__.o(exports, name)) { Object.defineProperty(exports, name, { configurable: false, enumerable: true, get: getter }); } }; __webpack_require__.n = function (module) { var getter = module && module.__esModule ? function getDefault() { return module['default']; } : function getModuleExports() { return module; }; __webpack_require__.d(getter, 'a', getter); return getter; }; __webpack_require__.o = function (object, property) { return Object.prototype.hasOwnProperty.call(object, property); }; __webpack_require__.p = ""; return __webpack_require__(__webpack_require__.s = 238);
})
    ([(function (module, exports, __webpack_require__) {
        "use strict"; var isUndefined = __webpack_require__(3); var isNumber = __webpack_require__(79); var emptyMarker = function emptyMarker() { return []; }; var AssessmentResult = function AssessmentResult(values) {
            this._hasScore = false; this._identifier = ""; this._hasMarks = false; this._marker = emptyMarker; this.score = 0; this.text = ""; if (isUndefined(values)) { values = {}; }
            if (!isUndefined(values.score)) { this.setScore(values.score); }
            if (!isUndefined(values.text)) { this.setText(values.text); }
        }; AssessmentResult.prototype.hasScore = function () { return this._hasScore; }; AssessmentResult.prototype.getScore = function () { return this.score; }; AssessmentResult.prototype.setScore = function (score) { if (isNumber(score)) { this.score = score; this._hasScore = true; } }; AssessmentResult.prototype.hasText = function () { return this.text !== ""; }; AssessmentResult.prototype.getText = function () { return this.text; }; AssessmentResult.prototype.setText = function (text) {
            if (isUndefined(text)) { text = ""; }
            this.text = text;
        }; AssessmentResult.prototype.setIdentifier = function (identifier) { this._identifier = identifier; }; AssessmentResult.prototype.getIdentifier = function () { return this._identifier; }; AssessmentResult.prototype.setMarker = function (marker) { this._marker = marker; }; AssessmentResult.prototype.hasMarker = function () { return this._hasMarks && this._marker !== emptyMarker; }; AssessmentResult.prototype.getMarker = function () { return this._marker; }; AssessmentResult.prototype.setHasMarks = function (hasMarks) { this._hasMarks = hasMarks; }; AssessmentResult.prototype.hasMarks = function () { return this._hasMarks; }; module.exports = AssessmentResult;
    }), (function (module, exports, __webpack_require__) {
        var arrayEach = __webpack_require__(146), baseEach = __webpack_require__(48), castFunction = __webpack_require__(302), isArray = __webpack_require__(4); function forEach(collection, iteratee) { var func = isArray(collection) ? arrayEach : baseEach; return func(collection, castFunction(iteratee)); }
        module.exports = forEach;
    }), (function (module, exports, __webpack_require__) {
        var arrayMap = __webpack_require__(24), baseIteratee = __webpack_require__(18), baseMap = __webpack_require__(144), isArray = __webpack_require__(4); function map(collection, iteratee) { var func = isArray(collection) ? arrayMap : baseMap; return func(collection, baseIteratee(iteratee, 3)); }
        module.exports = map;
    }), (function (module, exports) {
        function isUndefined(value) { return value === undefined; }
        module.exports = isUndefined;
    }), (function (module, exports) { var isArray = Array.isArray; module.exports = isArray; }), (function (module, exports) {
        function isObject(value) { var type = typeof value; return value != null && (type == 'object' || type == 'function'); }
        module.exports = isObject;
    }), (function (module, exports, __webpack_require__) {
        var arrayFilter = __webpack_require__(86), baseFilter = __webpack_require__(147), baseIteratee = __webpack_require__(18), isArray = __webpack_require__(4); function filter(collection, predicate) { var func = isArray(collection) ? arrayFilter : baseFilter; return func(collection, baseIteratee(predicate, 3)); }
        module.exports = filter;
    }), (function (module, exports, __webpack_require__) { "use strict"; var stripSpaces = __webpack_require__(8); var blockElements = __webpack_require__(92).blockElements; var blockElementStartRegex = new RegExp("^<(" + blockElements.join("|") + ")[^>]*?>", "i"); var blockElementEndRegex = new RegExp("</(" + blockElements.join("|") + ")[^>]*?>$", "i"); var stripIncompleteTags = function stripIncompleteTags(text) { text = text.replace(/^(<\/([^>]+)>)+/i, ""); text = text.replace(/(<([^\/>]+)>)+$/i, ""); return text; }; var stripBlockTagsAtStartEnd = function stripBlockTagsAtStartEnd(text) { text = text.replace(blockElementStartRegex, ""); text = text.replace(blockElementEndRegex, ""); return text; }; var stripFullTags = function stripFullTags(text) { text = text.replace(/(<([^>]+)>)/ig, " "); text = stripSpaces(text); return text; }; module.exports = { stripFullTags: stripFullTags, stripIncompleteTags: stripIncompleteTags, stripBlockTagsAtStartEnd: stripBlockTagsAtStartEnd }; }), (function (module, exports, __webpack_require__) { "use strict"; module.exports = function (text) { text = text.replace(/\s{2,}/g, " "); text = text.replace(/\s\./g, "."); text = text.replace(/^\s+|\s+$/g, ""); return text; }; }), (function (module, exports, __webpack_require__) { var freeGlobal = __webpack_require__(127); var freeSelf = typeof self == 'object' && self && self.Object === Object && self; var root = freeGlobal || freeSelf || Function('return this')(); module.exports = root; }), (function (module, exports, __webpack_require__) {
        var baseKeys = __webpack_require__(137), getTag = __webpack_require__(88), isArguments = __webpack_require__(43), isArray = __webpack_require__(4), isArrayLike = __webpack_require__(19), isBuffer = __webpack_require__(44), isPrototype = __webpack_require__(70), isTypedArray = __webpack_require__(68); var mapTag = '[object Map]', setTag = '[object Set]'; var objectProto = Object.prototype; var hasOwnProperty = objectProto.hasOwnProperty; function isEmpty(value) {
            if (value == null) { return true; }
            if (isArrayLike(value) && (isArray(value) || typeof value == 'string' || typeof value.splice == 'function' || isBuffer(value) || isTypedArray(value) || isArguments(value))) { return !value.length; }
            var tag = getTag(value); if (tag == mapTag || tag == setTag) { return !value.size; }
            if (isPrototype(value)) { return !baseKeys(value).length; }
            for (var key in value) { if (hasOwnProperty.call(value, key)) { return false; } }
            return true;
        }
        module.exports = isEmpty;
    }), (function (module, exports, __webpack_require__) { var baseMerge = __webpack_require__(93), createAssigner = __webpack_require__(99); var merge = createAssigner(function (object, source, srcIndex) { baseMerge(object, source, srcIndex); }); module.exports = merge; }), (function (module, exports, __webpack_require__) {
        var toString = __webpack_require__(91); var reRegExpChar = /[\\^$.*+?()[\]{}|]/g, reHasRegExpChar = RegExp(reRegExpChar.source); function escapeRegExp(string) { string = toString(string); return (string && reHasRegExpChar.test(string)) ? string.replace(reRegExpChar, '\\$&') : string; }
        module.exports = escapeRegExp;
    }), (function (module, exports) {
        function isObjectLike(value) { return value != null && typeof value == 'object'; }
        module.exports = isObjectLike;
    }), (function (module, exports, __webpack_require__) {
        (function (global, process) {
            var formatRegExp = /%[sdj%]/g; exports.format = function (f) {
                if (!isString(f)) {
                    var objects = []; for (var i = 0; i < arguments.length; i++) { objects.push(inspect(arguments[i])); }
                    return objects.join(' ');
                }
                var i = 1; var args = arguments; var len = args.length; var str = String(f).replace(formatRegExp, function (x) {
                    if (x === '%%') return '%'; if (i >= len) return x; switch (x) {
                        case '%s': return String(args[i++]); case '%d': return Number(args[i++]); case '%j': try { return JSON.stringify(args[i++]); } catch (_) { return '[Circular]'; }
                        default: return x;
                    }
                }); for (var x = args[i]; i < len; x = args[++i]) { if (isNull(x) || !isObject(x)) { str += ' ' + x; } else { str += ' ' + inspect(x); } }
                return str;
            }; exports.deprecate = function (fn, msg) {
                if (isUndefined(global.process)) { return function () { return exports.deprecate(fn, msg).apply(this, arguments); }; }
                if (process.noDeprecation === true) { return fn; }
                var warned = false; function deprecated() {
                    if (!warned) {
                        if (process.throwDeprecation) { throw new Error(msg); } else if (process.traceDeprecation) { console.trace(msg); } else { console.error(msg); }
                        warned = true;
                    }
                    return fn.apply(this, arguments);
                }
                return deprecated;
            }; var debugs = {}; var debugEnviron; exports.debuglog = function (set) {
                if (isUndefined(debugEnviron))
                    debugEnviron = process.env.NODE_DEBUG || ''; set = set.toUpperCase(); if (!debugs[set]) { if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) { var pid = process.pid; debugs[set] = function () { var msg = exports.format.apply(exports, arguments); console.error('%s %d: %s', set, pid, msg); }; } else { debugs[set] = function () { }; } }
                return debugs[set];
            }; function inspect(obj, opts) {
                var ctx = { seen: [], stylize: stylizeNoColor }; if (arguments.length >= 3) ctx.depth = arguments[2]; if (arguments.length >= 4) ctx.colors = arguments[3]; if (isBoolean(opts)) { ctx.showHidden = opts; } else if (opts) { exports._extend(ctx, opts); }
                if (isUndefined(ctx.showHidden)) ctx.showHidden = false; if (isUndefined(ctx.depth)) ctx.depth = 2; if (isUndefined(ctx.colors)) ctx.colors = false; if (isUndefined(ctx.customInspect)) ctx.customInspect = true; if (ctx.colors) ctx.stylize = stylizeWithColor; return formatValue(ctx, obj, ctx.depth);
            }
            exports.inspect = inspect; inspect.colors = { 'bold': [1, 22], 'italic': [3, 23], 'underline': [4, 24], 'inverse': [7, 27], 'white': [37, 39], 'grey': [90, 39], 'black': [30, 39], 'blue': [34, 39], 'cyan': [36, 39], 'green': [32, 39], 'magenta': [35, 39], 'red': [31, 39], 'yellow': [33, 39] }; inspect.styles = { 'special': 'cyan', 'number': 'yellow', 'boolean': 'yellow', 'undefined': 'grey', 'null': 'bold', 'string': 'green', 'date': 'magenta', 'regexp': 'red' }; function stylizeWithColor(str, styleType) {
                var style = inspect.styles[styleType]; if (style) {
                    return '\u001b[' + inspect.colors[style][0] + 'm' + str +
                        '\u001b[' + inspect.colors[style][1] + 'm';
                } else { return str; }
            }
            function stylizeNoColor(str, styleType) { return str; }
            function arrayToHash(array) { var hash = {}; array.forEach(function (val, idx) { hash[val] = true; }); return hash; }
            function formatValue(ctx, value, recurseTimes) {
                if (ctx.customInspect && value && isFunction(value.inspect) && value.inspect !== exports.inspect && !(value.constructor && value.constructor.prototype === value)) {
                    var ret = value.inspect(recurseTimes, ctx); if (!isString(ret)) { ret = formatValue(ctx, ret, recurseTimes); }
                    return ret;
                }
                var primitive = formatPrimitive(ctx, value); if (primitive) { return primitive; }
                var keys = Object.keys(value); var visibleKeys = arrayToHash(keys); if (ctx.showHidden) { keys = Object.getOwnPropertyNames(value); }
                if (isError(value) && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) { return formatError(value); }
                if (keys.length === 0) {
                    if (isFunction(value)) { var name = value.name ? ': ' + value.name : ''; return ctx.stylize('[Function' + name + ']', 'special'); }
                    if (isRegExp(value)) { return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp'); }
                    if (isDate(value)) { return ctx.stylize(Date.prototype.toString.call(value), 'date'); }
                    if (isError(value)) { return formatError(value); }
                }
                var base = '', array = false, braces = ['{', '}']; if (isArray(value)) { array = true; braces = ['[', ']']; }
                if (isFunction(value)) { var n = value.name ? ': ' + value.name : ''; base = ' [Function' + n + ']'; }
                if (isRegExp(value)) { base = ' ' + RegExp.prototype.toString.call(value); }
                if (isDate(value)) { base = ' ' + Date.prototype.toUTCString.call(value); }
                if (isError(value)) { base = ' ' + formatError(value); }
                if (keys.length === 0 && (!array || value.length == 0)) { return braces[0] + base + braces[1]; }
                if (recurseTimes < 0) { if (isRegExp(value)) { return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp'); } else { return ctx.stylize('[Object]', 'special'); } }
                ctx.seen.push(value); var output; if (array) { output = formatArray(ctx, value, recurseTimes, visibleKeys, keys); } else { output = keys.map(function (key) { return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array); }); }
                ctx.seen.pop(); return reduceToSingleString(output, base, braces);
            }
            function formatPrimitive(ctx, value) {
                if (isUndefined(value))
                    return ctx.stylize('undefined', 'undefined'); if (isString(value)) { var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '').replace(/'/g, "\\'").replace(/\\"/g, '"') + '\''; return ctx.stylize(simple, 'string'); }
                if (isNumber(value))
                    return ctx.stylize('' + value, 'number'); if (isBoolean(value))
                    return ctx.stylize('' + value, 'boolean'); if (isNull(value))
                    return ctx.stylize('null', 'null');
            }
            function formatError(value) { return '[' + Error.prototype.toString.call(value) + ']'; }
            function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
                var output = []; for (var i = 0, l = value.length; i < l; ++i) { if (hasOwnProperty(value, String(i))) { output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, String(i), true)); } else { output.push(''); } }
                keys.forEach(function (key) { if (!key.match(/^\d+$/)) { output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, key, true)); } }); return output;
            }
            function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
                var name, str, desc; desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] }; if (desc.get) { if (desc.set) { str = ctx.stylize('[Getter/Setter]', 'special'); } else { str = ctx.stylize('[Getter]', 'special'); } } else { if (desc.set) { str = ctx.stylize('[Setter]', 'special'); } }
                if (!hasOwnProperty(visibleKeys, key)) { name = '[' + key + ']'; }
                if (!str) {
                    if (ctx.seen.indexOf(desc.value) < 0) {
                        if (isNull(recurseTimes)) { str = formatValue(ctx, desc.value, null); } else { str = formatValue(ctx, desc.value, recurseTimes - 1); }
                        if (str.indexOf('\n') > -1) { if (array) { str = str.split('\n').map(function (line) { return '  ' + line; }).join('\n').substr(2); } else { str = '\n' + str.split('\n').map(function (line) { return '   ' + line; }).join('\n'); } }
                    } else { str = ctx.stylize('[Circular]', 'special'); }
                }
                if (isUndefined(name)) {
                    if (array && key.match(/^\d+$/)) { return str; }
                    name = JSON.stringify('' + key); if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) { name = name.substr(1, name.length - 2); name = ctx.stylize(name, 'name'); } else { name = name.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'"); name = ctx.stylize(name, 'string'); }
                }
                return name + ': ' + str;
            }
            function reduceToSingleString(output, base, braces) {
                var numLinesEst = 0; var length = output.reduce(function (prev, cur) { numLinesEst++; if (cur.indexOf('\n') >= 0) numLinesEst++; return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1; }, 0); if (length > 60) {
                    return braces[0] +
                        (base === '' ? '' : base + '\n ') +
                        ' ' +
                        output.join(',\n  ') +
                        ' ' +
                        braces[1];
                }
                return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
            }
            function isArray(ar) { return Array.isArray(ar); }
            exports.isArray = isArray; function isBoolean(arg) { return typeof arg === 'boolean'; }
            exports.isBoolean = isBoolean; function isNull(arg) { return arg === null; }
            exports.isNull = isNull; function isNullOrUndefined(arg) { return arg == null; }
            exports.isNullOrUndefined = isNullOrUndefined; function isNumber(arg) { return typeof arg === 'number'; }
            exports.isNumber = isNumber; function isString(arg) { return typeof arg === 'string'; }
            exports.isString = isString; function isSymbol(arg) { return typeof arg === 'symbol'; }
            exports.isSymbol = isSymbol; function isUndefined(arg) { return arg === void 0; }
            exports.isUndefined = isUndefined; function isRegExp(re) { return isObject(re) && objectToString(re) === '[object RegExp]'; }
            exports.isRegExp = isRegExp; function isObject(arg) { return typeof arg === 'object' && arg !== null; }
            exports.isObject = isObject; function isDate(d) { return isObject(d) && objectToString(d) === '[object Date]'; }
            exports.isDate = isDate; function isError(e) { return isObject(e) && (objectToString(e) === '[object Error]' || e instanceof Error); }
            exports.isError = isError; function isFunction(arg) { return typeof arg === 'function'; }
            exports.isFunction = isFunction; function isPrimitive(arg) { return arg === null || typeof arg === 'boolean' || typeof arg === 'number' || typeof arg === 'string' || typeof arg === 'symbol' || typeof arg === 'undefined'; }
            exports.isPrimitive = isPrimitive; exports.isBuffer = __webpack_require__(243); function objectToString(o) { return Object.prototype.toString.call(o); }
            function pad(n) { return n < 10 ? '0' + n.toString(10) : n.toString(10); }
            var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec']; function timestamp() { var d = new Date(); var time = [pad(d.getHours()), pad(d.getMinutes()), pad(d.getSeconds())].join(':'); return [d.getDate(), months[d.getMonth()], time].join(' '); }
            exports.log = function () { console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments)); }; exports.inherits = __webpack_require__(244); exports._extend = function (origin, add) {
                if (!add || !isObject(add)) return origin; var keys = Object.keys(add); var i = keys.length; while (i--) { origin[keys[i]] = add[keys[i]]; }
                return origin;
            }; function hasOwnProperty(obj, prop) { return Object.prototype.hasOwnProperty.call(obj, prop); }
        }.call(exports, __webpack_require__(17), __webpack_require__(41)))
    }), (function (module, exports, __webpack_require__) {
        "use strict"; var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
        var Assessment = function () {
            function Assessment() { _classCallCheck(this, Assessment); }
            _createClass(Assessment, [{ key: "getResult", value: function getResult(paper, researcher, i18n) { throw "The method getResult is not implemented"; } }, { key: "isApplicable", value: function isApplicable(paper) { return true; } }]); return Assessment;
        }(); module.exports = Assessment;
    }), (function (module, exports) {
        if (typeof Object.create === 'function') {
            module.exports = function inherits(ctor, superCtor) {
                ctor.super_ = superCtor
                ctor.prototype = Object.create(superCtor.prototype, { constructor: { value: ctor, enumerable: false, writable: true, configurable: true } });
            };
        } else {
            module.exports = function inherits(ctor, superCtor) {
                ctor.super_ = superCtor
                var TempCtor = function () { }
                TempCtor.prototype = superCtor.prototype
                ctor.prototype = new TempCtor()
                ctor.prototype.constructor = ctor
            }
        }
    }), (function (module, exports) {
        var g; g = (function () { return this; })(); try { g = g || Function("return this")() || (1, eval)("this"); } catch (e) {
            if (typeof window === "object")
                g = window;
        }
        module.exports = g;
    }), (function (module, exports, __webpack_require__) {
        var baseMatches = __webpack_require__(246), baseMatchesProperty = __webpack_require__(290), identity = __webpack_require__(37), isArray = __webpack_require__(4), property = __webpack_require__(296); function baseIteratee(value) {
            if (typeof value == 'function') { return value; }
            if (value == null) { return identity; }
            if (typeof value == 'object') { return isArray(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value); }
            return property(value);
        }
        module.exports = baseIteratee;
    }), (function (module, exports, __webpack_require__) {
        var isFunction = __webpack_require__(61), isLength = __webpack_require__(87); function isArrayLike(value) { return value != null && isLength(value.length) && !isFunction(value); }
        module.exports = isArrayLike;
    }), (function (module, exports, __webpack_require__) { "use strict"; module.exports = function (locale) { return locale.split("_")[0]; }; }), (function (module, exports, __webpack_require__) {
        var Symbol = __webpack_require__(34), getRawTag = __webpack_require__(241), objectToString = __webpack_require__(242); var nullTag = '[object Null]', undefinedTag = '[object Undefined]'; var symToStringTag = Symbol ? Symbol.toStringTag : undefined; function baseGetTag(value) {
            if (value == null) { return value === undefined ? undefinedTag : nullTag; }
            return (symToStringTag && symToStringTag in Object(value)) ? getRawTag(value) : objectToString(value);
        }
        module.exports = baseGetTag;
    }), (function (module, exports, __webpack_require__) {
        "use strict"; var map = __webpack_require__(2); var isUndefined = __webpack_require__(3); var forEach = __webpack_require__(1); var isNaN = __webpack_require__(303); var filter = __webpack_require__(6); var flatMap = __webpack_require__(72); var isEmpty = __webpack_require__(10); var negate = __webpack_require__(148); var memoize = __webpack_require__(36); var core = __webpack_require__(149); var getBlocks = __webpack_require__(92).getBlocks; var normalizeQuotes = __webpack_require__(74).normalize; var unifyWhitespace = __webpack_require__(150).unifyNonBreakingSpace; var fullStop = "."; var sentenceDelimiters = "?!;\u2026"; var newLines = "\n\r|\n|\r"; var fullStopRegex = new RegExp("^[" + fullStop + "]$"); var sentenceDelimiterRegex = new RegExp("^[" + sentenceDelimiters + "]$"); var sentenceRegex = new RegExp("^[^" + fullStop + sentenceDelimiters + "<\\(\\)\\[\\]]+$"); var htmlStartRegex = /^<([^>\s\/]+)[^>]*>$/mi; var htmlEndRegex = /^<\/([^>\s]+)[^>]*>$/mi; var newLineRegex = new RegExp(newLines); var blockStartRegex = /^\s*[\[\(\{]\s*$/; var blockEndRegex = /^\s*[\]\)}]\s*$/; var tokens = []; var sentenceTokenizer; function createTokenizer() { tokens = []; sentenceTokenizer = core(function (token) { tokens.push(token); }); sentenceTokenizer.addRule(htmlStartRegex, "html-start"); sentenceTokenizer.addRule(htmlEndRegex, "html-end"); sentenceTokenizer.addRule(blockStartRegex, "block-start"); sentenceTokenizer.addRule(blockEndRegex, "block-end"); sentenceTokenizer.addRule(fullStopRegex, "full-stop"); sentenceTokenizer.addRule(sentenceDelimiterRegex, "sentence-delimiter"); sentenceTokenizer.addRule(sentenceRegex, "sentence"); }
        function isCapitalLetter(character) { return character !== character.toLocaleLowerCase(); }
        function isNumber(character) { return !isNaN(parseInt(character, 10)); }
        function isBreakTag(htmlTag) { return (/<br/.test(htmlTag)); }
        function isQuotation(character) { character = normalizeQuotes(character); return "'" === character || "\"" === character; }
        function isPunctuation(character) { return "¿" === character || "¡" === character; }
        function tokenizeSentences(text) { createTokenizer(); sentenceTokenizer.onText(text); sentenceTokenizer.end(); return tokens; }
        function removeDuplicateWhitespace(text) { return text.replace(/\s+/, " "); }
        function getNextTwoCharacters(nextTokens) {
            var next = ""; if (!isUndefined(nextTokens[0])) { next += nextTokens[0].src; }
            if (!isUndefined(nextTokens[1])) { next += nextTokens[1].src; }
            next = removeDuplicateWhitespace(next); return next;
        }
        function isValidSentenceBeginning(sentenceBeginning) { return isCapitalLetter(sentenceBeginning) || isNumber(sentenceBeginning) || isQuotation(sentenceBeginning) || isPunctuation(sentenceBeginning); }
        function isSentenceStart(token) { return !isUndefined(token) && ("html-start" === token.type || "html-end" === token.type || "block-start" === token.type); }
        function getSentencesFromTokens(tokens) {
            var tokenSentences = [], currentSentence = "", nextSentenceStart; var sliced; do { sliced = false; var firstToken = tokens[0]; var lastToken = tokens[tokens.length - 1]; if (firstToken.type === "html-start" && lastToken.type === "html-end") { tokens = tokens.slice(1, tokens.length - 1); sliced = true; } } while (sliced && tokens.length > 1); forEach(tokens, function (token, i) {
                var hasNextSentence; var nextToken = tokens[i + 1]; var secondToNextToken = tokens[i + 2]; var nextCharacters; switch (token.type) {
                    case "html-start": case "html-end": if (isBreakTag(token.src)) { tokenSentences.push(currentSentence); currentSentence = ""; } else { currentSentence += token.src; }
                        break; case "sentence": currentSentence += token.src; break; case "sentence-delimiter": currentSentence += token.src; if (!isUndefined(nextToken) && "block-end" !== nextToken.type) { tokenSentences.push(currentSentence); currentSentence = ""; }
                        break; case "full-stop": currentSentence += token.src; nextCharacters = getNextTwoCharacters([nextToken, secondToNextToken]); hasNextSentence = nextCharacters.length >= 2; nextSentenceStart = hasNextSentence ? nextCharacters[1] : ""; if (hasNextSentence && isNumber(nextCharacters[0])) { break; }
                        if (hasNextSentence && isValidSentenceBeginning(nextSentenceStart) || isSentenceStart(nextToken)) { tokenSentences.push(currentSentence); currentSentence = ""; }
                        break; case "block-start": currentSentence += token.src; break; case "block-end": currentSentence += token.src; nextCharacters = getNextTwoCharacters([nextToken, secondToNextToken]); hasNextSentence = nextCharacters.length >= 2; nextSentenceStart = hasNextSentence ? nextCharacters[0] : ""; if (hasNextSentence && isNumber(nextCharacters[0])) { break; }
                        if (hasNextSentence && isValidSentenceBeginning(nextSentenceStart) || isSentenceStart(nextToken)) { tokenSentences.push(currentSentence); currentSentence = ""; }
                        break;
                }
            }); if ("" !== currentSentence) { tokenSentences.push(currentSentence); }
            tokenSentences = map(tokenSentences, function (sentence) { return sentence.trim(); }); return tokenSentences;
        }
        function getSentencesFromBlock(block) { var tokens = tokenizeSentences(block); return tokens.length === 0 ? [] : getSentencesFromTokens(tokens); }
        var getSentencesFromBlockCached = memoize(getSentencesFromBlock); module.exports = function (text) { text = unifyWhitespace(text); var sentences, blocks = getBlocks(text); blocks = flatMap(blocks, function (block) { return block.split(newLineRegex); }); sentences = flatMap(blocks, getSentencesFromBlockCached); return filter(sentences, negate(isEmpty)); };
    }), (function (module, exports, __webpack_require__) { "use strict"; var getWords = __webpack_require__(27); module.exports = function (text) { return getWords(text).length; }; }), (function (module, exports) {
        function arrayMap(array, iteratee) {
            var index = -1, length = array == null ? 0 : array.length, result = Array(length); while (++index < length) { result[index] = iteratee(array[index], index, array); }
            return result;
        }
        module.exports = arrayMap;
    }), (function (module, exports, __webpack_require__) {
        var baseIsNative = __webpack_require__(258), getValue = __webpack_require__(261); function getNative(object, key) { var value = getValue(object, key); return baseIsNative(value) ? value : undefined; }
        module.exports = getNative;
    }), (function (module, exports, __webpack_require__) {
        var arrayLikeKeys = __webpack_require__(136), baseKeys = __webpack_require__(137), isArrayLike = __webpack_require__(19); function keys(object) { return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object); }
        module.exports = keys;
    }), (function (module, exports, __webpack_require__) {
        "use strict"; var stripTags = __webpack_require__(7).stripFullTags; var stripSpaces = __webpack_require__(8); var removePunctuation = __webpack_require__(314); var map = __webpack_require__(2); var filter = __webpack_require__(6); module.exports = function (text) {
            text = stripSpaces(stripTags(text)); if (text === "") { return []; }
            var words = text.split(/\s/g); words = map(words, function (word) { return removePunctuation(word); }); return filter(words, function (word) { return word.trim() !== ""; });
        };
    }), (function (module, exports, __webpack_require__) { "use strict"; var stripSomeTags = __webpack_require__(165); var unifyWhitespace = __webpack_require__(150).unifyAllSpaces; var matchStringWithTransliteration = __webpack_require__(101); module.exports = function (text, wordToMatch, locale, extraBoundary) { text = stripSomeTags(text); text = unifyWhitespace(text); var matches = matchStringWithTransliteration(text, wordToMatch, locale, extraBoundary); return matches.length; }; }), (function (module, exports, __webpack_require__) {
        var baseIndexOf = __webpack_require__(106), isArrayLike = __webpack_require__(19), isString = __webpack_require__(107), toInteger = __webpack_require__(75), values = __webpack_require__(185); var nativeMax = Math.max; function includes(collection, value, fromIndex, guard) {
            collection = isArrayLike(collection) ? collection : values(collection); fromIndex = (fromIndex && !guard) ? toInteger(fromIndex) : 0; var length = collection.length; if (fromIndex < 0) { fromIndex = nativeMax(length + fromIndex, 0); }
            return isString(collection) ? (fromIndex <= length && collection.indexOf(value, fromIndex) > -1) : (!!length && baseIndexOf(collection, value, fromIndex) > -1);
        }
        module.exports = includes;
    }), (function (module, exports, __webpack_require__) {
        "use strict"; function inRangeEndInclusive(number, start, end) { return number > start && number <= end; }
        function inRangeStartInclusive(number, start, end) { return number >= start && number < end; }
        function inRangeStartEndInclusive(number, start, end) { return number >= start && number <= end; }
        module.exports = { inRange: inRangeEndInclusive, inRangeStartInclusive: inRangeStartInclusive, inRangeEndInclusive: inRangeEndInclusive, inRangeStartEndInclusive: inRangeStartEndInclusive };
    }), (function (module, exports, __webpack_require__) {
        "use strict"; var defaults = __webpack_require__(110); function Mark(properties) { defaults(properties, { original: "", marked: "" }); this._properties = properties; }
        Mark.prototype.getOriginal = function () { return this._properties.original; }; Mark.prototype.getMarked = function () { return this._properties.marked; }; Mark.prototype.applyWithReplace = function (text) { return text.split(this._properties.original).join(this._properties.marked); }; module.exports = Mark;
    }), (function (module, exports, __webpack_require__) { "use strict"; module.exports = function (text) { return "<yoastmark class='yoast-text-mark'>" + text + "</yoastmark>"; }; }), (function (module, exports, __webpack_require__) {
        "use strict"; var processNextTick = __webpack_require__(77); var objectKeys = Object.keys || function (obj) { var keys = []; for (var key in obj) { keys.push(key); } return keys; }; module.exports = Duplex; var util = __webpack_require__(56); util.inherits = __webpack_require__(16); var Readable = __webpack_require__(233); var Writable = __webpack_require__(124); util.inherits(Duplex, Readable); var keys = objectKeys(Writable.prototype); for (var v = 0; v < keys.length; v++) { var method = keys[v]; if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method]; }
        function Duplex(options) { if (!(this instanceof Duplex)) return new Duplex(options); Readable.call(this, options); Writable.call(this, options); if (options && options.readable === false) this.readable = false; if (options && options.writable === false) this.writable = false; this.allowHalfOpen = true; if (options && options.allowHalfOpen === false) this.allowHalfOpen = false; this.once('end', onend); }
        function onend() { if (this.allowHalfOpen || this._writableState.ended) return; processNextTick(onEndNT, this); }
        function onEndNT(self) { self.end(); }
        Object.defineProperty(Duplex.prototype, 'destroyed', {
            get: function () {
                if (this._readableState === undefined || this._writableState === undefined) { return false; }
                return this._readableState.destroyed && this._writableState.destroyed;
            }, set: function (value) {
                if (this._readableState === undefined || this._writableState === undefined) { return; }
                this._readableState.destroyed = value; this._writableState.destroyed = value;
            }
        }); Duplex.prototype._destroy = function (err, cb) { this.push(null); this.end(); processNextTick(cb, err); }; function forEach(xs, f) { for (var i = 0, l = xs.length; i < l; i++) { f(xs[i], i); } }
    }), (function (module, exports, __webpack_require__) { var root = __webpack_require__(9); var Symbol = root.Symbol; module.exports = Symbol; }), (function (module, exports) {
        function eq(value, other) { return value === other || (value !== value && other !== other); }
        module.exports = eq;
    }), (function (module, exports, __webpack_require__) {
        var MapCache = __webpack_require__(83); var FUNC_ERROR_TEXT = 'Expected a function'; function memoize(func, resolver) {
            if (typeof func != 'function' || (resolver != null && typeof resolver != 'function')) { throw new TypeError(FUNC_ERROR_TEXT); }
            var memoized = function () {
                var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache; if (cache.has(key)) { return cache.get(key); }
                var result = func.apply(this, args); memoized.cache = cache.set(key, result) || cache; return result;
            }; memoized.cache = new (memoize.Cache || MapCache); return memoized;
        }
        memoize.Cache = MapCache; module.exports = memoize;
    }), (function (module, exports) {
        function identity(value) { return value; }
        module.exports = identity;
    }), (function (module, exports, __webpack_require__) {
        var assignValue = __webpack_require__(98), baseAssignValue = __webpack_require__(94); function copyObject(source, props, object, customizer) {
            var isNew = !object; object || (object = {}); var index = -1, length = props.length; while (++index < length) {
                var key = props[index]; var newValue = customizer ? customizer(object[key], source[key], key, object, source) : undefined; if (newValue === undefined) { newValue = source[key]; }
                if (isNew) { baseAssignValue(object, key, newValue); } else { assignValue(object, key, newValue); }
            }
            return object;
        }
        module.exports = copyObject;
    }), (function (module, exports, __webpack_require__) {
        var identity = __webpack_require__(37), overRest = __webpack_require__(158), setToString = __webpack_require__(159); function baseRest(func, start) { return setToString(overRest(func, start, identity), func + ''); }
        module.exports = baseRest;
    }), (function (module, exports, __webpack_require__) { "use strict"; var indexOf = __webpack_require__(435); var getLanguage = __webpack_require__(20); module.exports = function (locale, languages) { var language = getLanguage(locale); return indexOf(languages, language) > -1; }; }), (function (module, exports) {
        var process = module.exports = {}; var cachedSetTimeout; var cachedClearTimeout; function defaultSetTimout() { throw new Error('setTimeout has not been defined'); }
        function defaultClearTimeout() { throw new Error('clearTimeout has not been defined'); }
        (function () {
            try { if (typeof setTimeout === 'function') { cachedSetTimeout = setTimeout; } else { cachedSetTimeout = defaultSetTimout; } } catch (e) { cachedSetTimeout = defaultSetTimout; }
            try { if (typeof clearTimeout === 'function') { cachedClearTimeout = clearTimeout; } else { cachedClearTimeout = defaultClearTimeout; } } catch (e) { cachedClearTimeout = defaultClearTimeout; }
        }())
        function runTimeout(fun) {
            if (cachedSetTimeout === setTimeout) { return setTimeout(fun, 0); }
            if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) { cachedSetTimeout = setTimeout; return setTimeout(fun, 0); }
            try { return cachedSetTimeout(fun, 0); } catch (e) { try { return cachedSetTimeout.call(null, fun, 0); } catch (e) { return cachedSetTimeout.call(this, fun, 0); } }
        }
        function runClearTimeout(marker) {
            if (cachedClearTimeout === clearTimeout) { return clearTimeout(marker); }
            if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) { cachedClearTimeout = clearTimeout; return clearTimeout(marker); }
            try { return cachedClearTimeout(marker); } catch (e) { try { return cachedClearTimeout.call(null, marker); } catch (e) { return cachedClearTimeout.call(this, marker); } }
        }
        var queue = []; var draining = false; var currentQueue; var queueIndex = -1; function cleanUpNextTick() {
            if (!draining || !currentQueue) { return; }
            draining = false; if (currentQueue.length) { queue = currentQueue.concat(queue); } else { queueIndex = -1; }
            if (queue.length) { drainQueue(); }
        }
        function drainQueue() {
            if (draining) { return; }
            var timeout = runTimeout(cleanUpNextTick); draining = true; var len = queue.length; while (len) {
                currentQueue = queue; queue = []; while (++queueIndex < len) { if (currentQueue) { currentQueue[queueIndex].run(); } }
                queueIndex = -1; len = queue.length;
            }
            currentQueue = null; draining = false; runClearTimeout(timeout);
        }
        process.nextTick = function (fun) {
            var args = new Array(arguments.length - 1); if (arguments.length > 1) { for (var i = 1; i < arguments.length; i++) { args[i - 1] = arguments[i]; } }
            queue.push(new Item(fun, args)); if (queue.length === 1 && !draining) { runTimeout(drainQueue); }
        }; function Item(fun, array) { this.fun = fun; this.array = array; }
        Item.prototype.run = function () { this.fun.apply(null, this.array); }; process.title = 'browser'; process.browser = true; process.env = {}; process.argv = []; process.version = ''; process.versions = {}; function noop() { }
        process.on = noop; process.addListener = noop; process.once = noop; process.off = noop; process.removeListener = noop; process.removeAllListeners = noop; process.emit = noop; process.prependListener = noop; process.prependOnceListener = noop; process.listeners = function (name) { return [] }
        process.binding = function (name) { throw new Error('process.binding is not supported'); }; process.cwd = function () { return '/' }; process.chdir = function (dir) { throw new Error('process.chdir is not supported'); }; process.umask = function () { return 0; };
    }), (function (module, exports, __webpack_require__) {
        "use strict"; var Researcher = __webpack_require__(81); var MissingArgument = __webpack_require__(57); var removeDuplicateMarks = __webpack_require__(429); var AssessmentResult = __webpack_require__(0); var showTrace = __webpack_require__(434).showTrace; var isUndefined = __webpack_require__(3); var isFunction = __webpack_require__(61); var forEach = __webpack_require__(1); var filter = __webpack_require__(6); var map = __webpack_require__(2); var findIndex = __webpack_require__(171); var find = __webpack_require__(103); var ScoreRating = 9; var Assessor = function Assessor(i18n, options) { this.setI18n(i18n); this._assessments = []; this._options = options || {}; }; Assessor.prototype.setI18n = function (i18n) {
            if (isUndefined(i18n)) { throw new MissingArgument("The assessor requires an i18n object."); }
            this.i18n = i18n;
        }; Assessor.prototype.getAvailableAssessments = function () { return this._assessments; }; Assessor.prototype.isApplicable = function (assessment, paper, researcher) {
            if (assessment.hasOwnProperty("isApplicable") || typeof assessment.isApplicable === "function") { return assessment.isApplicable(paper, researcher); }
            return true;
        }; Assessor.prototype.hasMarker = function (assessment) {
            if (!isUndefined(window) && !isUndefined(window.yoastHideMarkers) && window.yoastHideMarkers) { return false; }
            return isFunction(this._options.marker) && (assessment.hasOwnProperty("getMarks") || typeof assessment.getMarks === "function");
        }; Assessor.prototype.getSpecificMarker = function () { return this._options.marker; }; Assessor.prototype.getPaper = function () { return this._lastPaper; }; Assessor.prototype.getMarker = function (assessment, paper, researcher) { var specificMarker = this._options.marker; return function () { var marks = assessment.getMarks(paper, researcher); marks = removeDuplicateMarks(marks); specificMarker(paper, marks); }; }; Assessor.prototype.assess = function (paper) { var researcher = new Researcher(paper); var assessments = this.getAvailableAssessments(); this.results = []; assessments = filter(assessments, function (assessment) { return this.isApplicable(assessment, paper, researcher); }.bind(this)); this.setHasMarkers(false); this.results = map(assessments, this.executeAssessment.bind(this, paper, researcher)); this._lastPaper = paper; }; Assessor.prototype.setHasMarkers = function (hasMarkers) { this._hasMarkers = hasMarkers; }; Assessor.prototype.hasMarkers = function () { return this._hasMarkers; }; Assessor.prototype.executeAssessment = function (paper, researcher, assessment) {
            var result; try { result = assessment.getResult(paper, researcher, this.i18n); result.setIdentifier(assessment.identifier); if (result.hasMarks() && this.hasMarker(assessment)) { this.setHasMarkers(true); result.setMarker(this.getMarker(assessment, paper, researcher)); } } catch (assessmentError) { showTrace(assessmentError); result = new AssessmentResult(); result.setScore(-1); result.setText(this.i18n.sprintf(this.i18n.dgettext("js-text-analysis", "An error occurred in the '%1$s' assessment"), assessment.identifier, assessmentError)); }
            return result;
        }; Assessor.prototype.getValidResults = function () { return filter(this.results, function (result) { return this.isValidResult(result); }.bind(this)); }; Assessor.prototype.isValidResult = function (assessmentResult) { return assessmentResult.hasScore() && assessmentResult.hasText(); }; Assessor.prototype.calculateOverallScore = function () { var results = this.getValidResults(); var totalScore = 0; forEach(results, function (assessmentResult) { totalScore += assessmentResult.getScore(); }); return Math.round(totalScore / (results.length * ScoreRating) * 100) || 0; }; Assessor.prototype.addAssessment = function (name, assessment) {
            if (!assessment.hasOwnProperty("identifier")) { assessment.identifier = name; }
            this._assessments.push(assessment); return true;
        }; Assessor.prototype.removeAssessment = function (name) { var toDelete = findIndex(this._assessments, function (assessment) { return assessment.hasOwnProperty("identifier") && name === assessment.identifier; }); if (-1 !== toDelete) { this._assessments.splice(toDelete, 1); } }; Assessor.prototype.getAssessment = function (identifier) { return find(this._assessments, function (assessment) { return assessment.hasOwnProperty("identifier") && identifier === assessment.identifier; }); }; Assessor.prototype.getApplicableAssessments = function () { var availableAssessments = this.getAvailableAssessments(); return filter(availableAssessments, function (availableAssessment) { return this.isApplicable(availableAssessment, this.getPaper()); }.bind(this)); }; module.exports = Assessor;
    }), (function (module, exports, __webpack_require__) { var baseIsArguments = __webpack_require__(281), isObjectLike = __webpack_require__(13); var objectProto = Object.prototype; var hasOwnProperty = objectProto.hasOwnProperty; var propertyIsEnumerable = objectProto.propertyIsEnumerable; var isArguments = baseIsArguments(function () { return arguments; }()) ? baseIsArguments : function (value) { return isObjectLike(value) && hasOwnProperty.call(value, 'callee') && !propertyIsEnumerable.call(value, 'callee'); }; module.exports = isArguments; }), (function (module, exports, __webpack_require__) { (function (module) { var root = __webpack_require__(9), stubFalse = __webpack_require__(282); var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports; var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module; var moduleExports = freeModule && freeModule.exports === freeExports; var Buffer = moduleExports ? root.Buffer : undefined; var nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined; var isBuffer = nativeIsBuffer || stubFalse; module.exports = isBuffer; }.call(exports, __webpack_require__(45)(module))) }), (function (module, exports) {
        module.exports = function (module) {
            if (!module.webpackPolyfill) { module.deprecate = function () { }; module.paths = []; if (!module.children) module.children = []; Object.defineProperty(module, "loaded", { enumerable: true, get: function () { return module.l; } }); Object.defineProperty(module, "id", { enumerable: true, get: function () { return module.i; } }); module.webpackPolyfill = 1; }
            return module;
        };
    }), (function (module, exports, __webpack_require__) {
        var baseGetTag = __webpack_require__(21), isObjectLike = __webpack_require__(13); var symbolTag = '[object Symbol]'; function isSymbol(value) { return typeof value == 'symbol' || (isObjectLike(value) && baseGetTag(value) == symbolTag); }
        module.exports = isSymbol;
    }), (function (module, exports, __webpack_require__) {
        var isSymbol = __webpack_require__(46); var INFINITY = 1 / 0; function toKey(value) {
            if (typeof value == 'string' || isSymbol(value)) { return value; }
            var result = (value + ''); return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
        }
        module.exports = toKey;
    }), (function (module, exports, __webpack_require__) { var baseForOwn = __webpack_require__(299), createBaseEach = __webpack_require__(301); var baseEach = createBaseEach(baseForOwn); module.exports = baseEach; }), (function (module, exports, __webpack_require__) {
        var arrayLikeKeys = __webpack_require__(136), baseKeysIn = __webpack_require__(308), isArrayLike = __webpack_require__(19); function keysIn(object) { return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object); }
        module.exports = keysIn;
    }), (function (module, exports, __webpack_require__) {
        "use strict"; module.exports = function (matchString) {
            var positiveLookAhead = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false; var extraWordBoundary = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : ""; var wordBoundary, wordBoundaryStart, wordBoundaryEnd; wordBoundary = "[ \\u00a0\xA0\\n\\r\\t.,'()\"+-;!?:/\xBB\xAB\u2039\u203A" + extraWordBoundary + "<>]"; wordBoundaryStart = "(^|" + wordBoundary + ")"; if (positiveLookAhead) { wordBoundary = "(?=" + wordBoundary + ")"; }
            wordBoundaryEnd = "($|" + wordBoundary + ")"; return wordBoundaryStart + matchString + wordBoundaryEnd;
        };
    }), (function (module, exports, __webpack_require__) {
        "use strict"; var addWordBoundary = __webpack_require__(50); var map = __webpack_require__(2); module.exports = function (array, disableWordBoundary) {
            var regexString; var _disableWordBoundary = disableWordBoundary || false; var boundedArray = map(array, function (string) {
                if (_disableWordBoundary) { return string; }
                return addWordBoundary(string, true);
            }); regexString = "(" + boundedArray.join(")|(") + ")"; return new RegExp(regexString, "ig");
        };
    }), (function (module, exports, __webpack_require__) {
        "use strict"; module.exports = function (number) {
            if (Math.round(number) === number) { return Math.round(number); }
            return Math.round(number * 10) / 10;
        };
    }), (function (module, exports, __webpack_require__) { "use strict"; var participleLike = ["bekommst", "bekommt", "bekamst", "bekommest", "bekommet", "bekämest", "bekämst", "bekämet", "bekämt", "gekriegt", "gehörst", "gehört", "gehörtest", "gehörtet", "gehörest", "gehöret", "erhältst", "erhält", "erhaltet", "erhielt", "erhieltest", "erhieltst", "erhieltet", "erhaltest"]; var otherAuxiliaries = ["werde", "wirst", "wird", "werden", "werdet", "wurde", "ward", "wurdest", "wardst", "wurden", "wurdet", "worden", "werdest", "würde", "würdest", "würden", "würdet", "bekomme", "bekommen", "bekam", "bekamen", "bekäme", "bekämen", "kriege", "kriegst", "kriegt", "kriegen", "kriegte", "kriegtest", "kriegten", "kriegtet", "kriegest", "krieget", "gehöre", "gehören", "gehörte", "gehörten", "erhalte", "erhalten", "erhielten", "erhielte"]; var infinitiveAuxiliaries = ["werden", "bekommen", "kriegen", "gehören", "erhalten"]; module.exports = function () { return { participleLike: participleLike, otherAuxiliaries: otherAuxiliaries.concat(infinitiveAuxiliaries), filteredAuxiliaries: participleLike.concat(otherAuxiliaries), infinitiveAuxiliaries: infinitiveAuxiliaries, allAuxiliaries: participleLike.concat(otherAuxiliaries, infinitiveAuxiliaries) }; }; }), (function (module, exports, __webpack_require__) {
        var Parser = __webpack_require__(227), DomHandler = __webpack_require__(487); function defineProp(name, value) { delete module.exports[name]; module.exports[name] = value; return value; }
        module.exports = { Parser: Parser, Tokenizer: __webpack_require__(228), ElementType: __webpack_require__(55), DomHandler: DomHandler, get FeedHandler() { return defineProp("FeedHandler", __webpack_require__(489)); }, get Stream() { return defineProp("Stream", __webpack_require__(490)); }, get WritableStream() { return defineProp("WritableStream", __webpack_require__(232)); }, get ProxyHandler() { return defineProp("ProxyHandler", __webpack_require__(505)); }, get DomUtils() { return defineProp("DomUtils", __webpack_require__(506)); }, get CollectingHandler() { return defineProp("CollectingHandler", __webpack_require__(518)); }, DefaultHandler: DomHandler, get RssHandler() { return defineProp("RssHandler", this.FeedHandler); }, parseDOM: function (data, options) { var handler = new DomHandler(options); new Parser(handler, options).end(data); return handler.dom; }, parseFeed: function (feed, options) { var handler = new module.exports.FeedHandler(options); new Parser(handler, options).end(feed); return handler.dom; }, createDomStream: function (cb, options, elementCb) { var handler = new DomHandler(cb, options, elementCb); return new Parser(handler, options); }, EVENTS: { attribute: 2, cdatastart: 0, cdataend: 0, text: 1, processinginstruction: 2, comment: 1, commentend: 0, closetag: 1, opentag: 2, opentagname: 1, error: 1, end: 0 } };
    }), (function (module, exports) { module.exports = { Text: "text", Directive: "directive", Comment: "comment", Script: "script", Style: "style", Tag: "tag", CDATA: "cdata", Doctype: "doctype", isTag: function (elem) { return elem.type === "tag" || elem.type === "script" || elem.type === "style"; } }; }), (function (module, exports, __webpack_require__) {
        (function (Buffer) {
            function isArray(arg) {
                if (Array.isArray) { return Array.isArray(arg); }
                return objectToString(arg) === '[object Array]';
            }
            exports.isArray = isArray; function isBoolean(arg) { return typeof arg === 'boolean'; }
            exports.isBoolean = isBoolean; function isNull(arg) { return arg === null; }
            exports.isNull = isNull; function isNullOrUndefined(arg) { return arg == null; }
            exports.isNullOrUndefined = isNullOrUndefined; function isNumber(arg) { return typeof arg === 'number'; }
            exports.isNumber = isNumber; function isString(arg) { return typeof arg === 'string'; }
            exports.isString = isString; function isSymbol(arg) { return typeof arg === 'symbol'; }
            exports.isSymbol = isSymbol; function isUndefined(arg) { return arg === void 0; }
            exports.isUndefined = isUndefined; function isRegExp(re) { return objectToString(re) === '[object RegExp]'; }
            exports.isRegExp = isRegExp; function isObject(arg) { return typeof arg === 'object' && arg !== null; }
            exports.isObject = isObject; function isDate(d) { return objectToString(d) === '[object Date]'; }
            exports.isDate = isDate; function isError(e) { return (objectToString(e) === '[object Error]' || e instanceof Error); }
            exports.isError = isError; function isFunction(arg) { return typeof arg === 'function'; }
            exports.isFunction = isFunction; function isPrimitive(arg) { return arg === null || typeof arg === 'boolean' || typeof arg === 'number' || typeof arg === 'string' || typeof arg === 'symbol' || typeof arg === 'undefined'; }
            exports.isPrimitive = isPrimitive; exports.isBuffer = Buffer.isBuffer; function objectToString(o) { return Object.prototype.toString.call(o); }
        }.call(exports, __webpack_require__(123).Buffer))
    }), (function (module, exports, __webpack_require__) { "use strict"; module.exports = function MissingArgumentError(message) { Error.captureStackTrace(this, this.constructor); this.name = this.constructor.name; this.message = message; }; __webpack_require__(14).inherits(module.exports, Error); }), (function (module, exports, __webpack_require__) {
        var ListCache = __webpack_require__(59), stackClear = __webpack_require__(253), stackDelete = __webpack_require__(254), stackGet = __webpack_require__(255), stackHas = __webpack_require__(256), stackSet = __webpack_require__(257); function Stack(entries) { var data = this.__data__ = new ListCache(entries); this.size = data.size; }
        Stack.prototype.clear = stackClear; Stack.prototype['delete'] = stackDelete; Stack.prototype.get = stackGet; Stack.prototype.has = stackHas; Stack.prototype.set = stackSet; module.exports = Stack;
    }), (function (module, exports, __webpack_require__) {
        var listCacheClear = __webpack_require__(248), listCacheDelete = __webpack_require__(249), listCacheGet = __webpack_require__(250), listCacheHas = __webpack_require__(251), listCacheSet = __webpack_require__(252); function ListCache(entries) { var index = -1, length = entries == null ? 0 : entries.length; this.clear(); while (++index < length) { var entry = entries[index]; this.set(entry[0], entry[1]); } }
        ListCache.prototype.clear = listCacheClear; ListCache.prototype['delete'] = listCacheDelete; ListCache.prototype.get = listCacheGet; ListCache.prototype.has = listCacheHas; ListCache.prototype.set = listCacheSet; module.exports = ListCache;
    }), (function (module, exports, __webpack_require__) {
        var eq = __webpack_require__(35); function assocIndexOf(array, key) {
            var length = array.length; while (length--) { if (eq(array[length][0], key)) { return length; } }
            return -1;
        }
        module.exports = assocIndexOf;
    }), (function (module, exports, __webpack_require__) {
        var baseGetTag = __webpack_require__(21), isObject = __webpack_require__(5); var asyncTag = '[object AsyncFunction]', funcTag = '[object Function]', genTag = '[object GeneratorFunction]', proxyTag = '[object Proxy]'; function isFunction(value) {
            if (!isObject(value)) { return false; }
            var tag = baseGetTag(value); return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
        }
        module.exports = isFunction;
    }), (function (module, exports, __webpack_require__) { var getNative = __webpack_require__(25); var nativeCreate = getNative(Object, 'create'); module.exports = nativeCreate; }), (function (module, exports, __webpack_require__) {
        var isKeyable = __webpack_require__(270); function getMapData(map, key) { var data = map.__data__; return isKeyable(key) ? data[typeof key == 'string' ? 'string' : 'hash'] : data.map; }
        module.exports = getMapData;
    }), (function (module, exports, __webpack_require__) {
        var MapCache = __webpack_require__(83), setCacheAdd = __webpack_require__(275), setCacheHas = __webpack_require__(276); function SetCache(values) { var index = -1, length = values == null ? 0 : values.length; this.__data__ = new MapCache; while (++index < length) { this.add(values[index]); } }
        SetCache.prototype.add = SetCache.prototype.push = setCacheAdd; SetCache.prototype.has = setCacheHas; module.exports = SetCache;
    }), (function (module, exports) {
        function cacheHas(cache, key) { return cache.has(key); }
        module.exports = cacheHas;
    }), (function (module, exports) {
        function setToArray(set) { var index = -1, result = Array(set.size); set.forEach(function (value) { result[++index] = value; }); return result; }
        module.exports = setToArray;
    }), (function (module, exports) {
        var MAX_SAFE_INTEGER = 9007199254740991; var reIsUint = /^(?:0|[1-9]\d*)$/; function isIndex(value, length) { length = length == null ? MAX_SAFE_INTEGER : length; return !!length && (typeof value == 'number' || reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length); }
        module.exports = isIndex;
    }), (function (module, exports, __webpack_require__) { var baseIsTypedArray = __webpack_require__(283), baseUnary = __webpack_require__(69), nodeUtil = __webpack_require__(284); var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray; var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray; module.exports = isTypedArray; }), (function (module, exports) {
        function baseUnary(func) { return function (value) { return func(value); }; }
        module.exports = baseUnary;
    }), (function (module, exports) {
        var objectProto = Object.prototype; function isPrototype(value) { var Ctor = value && value.constructor, proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto; return value === proto; }
        module.exports = isPrototype;
    }), (function (module, exports, __webpack_require__) {
        var isArray = __webpack_require__(4), isKey = __webpack_require__(90), stringToPath = __webpack_require__(292), toString = __webpack_require__(91); function castPath(value, object) {
            if (isArray(value)) { return value; }
            return isKey(value, object) ? [value] : stringToPath(toString(value));
        }
        module.exports = castPath;
    }), (function (module, exports, __webpack_require__) {
        var baseFlatten = __webpack_require__(73), map = __webpack_require__(2); function flatMap(collection, iteratee) { return baseFlatten(map(collection, iteratee), 1); }
        module.exports = flatMap;
    }), (function (module, exports, __webpack_require__) {
        var arrayPush = __webpack_require__(84), isFlattenable = __webpack_require__(304); function baseFlatten(array, depth, predicate, isStrict, result) {
            var index = -1, length = array.length; predicate || (predicate = isFlattenable); result || (result = []); while (++index < length) { var value = array[index]; if (depth > 0 && predicate(value)) { if (depth > 1) { baseFlatten(value, depth - 1, predicate, isStrict, result); } else { arrayPush(result, value); } } else if (!isStrict) { result[result.length] = value; } }
            return result;
        }
        module.exports = baseFlatten;
    }), (function (module, exports, __webpack_require__) {
        "use strict"; function normalizeSingleQuotes(text) { return text.replace(/[‘’‛`]/g, "'"); }
        function normalizeDoubleQuotes(text) { return text.replace(/[“”〝〞〟‟„]/g, "\""); }
        function normalizeQuotes(text) { return normalizeDoubleQuotes(normalizeSingleQuotes(text)); }
        module.exports = { normalizeSingle: normalizeSingleQuotes, normalizeDouble: normalizeDoubleQuotes, normalize: normalizeQuotes };
    }), (function (module, exports, __webpack_require__) {
        var toFinite = __webpack_require__(173); function toInteger(value) { var result = toFinite(value), remainder = result % 1; return result === result ? (remainder ? result - remainder : result) : 0; }
        module.exports = toInteger;
    }), (function (module, exports) {
        function EventEmitter() { this._events = this._events || {}; this._maxListeners = this._maxListeners || undefined; }
        module.exports = EventEmitter; EventEmitter.EventEmitter = EventEmitter; EventEmitter.prototype._events = undefined; EventEmitter.prototype._maxListeners = undefined; EventEmitter.defaultMaxListeners = 10; EventEmitter.prototype.setMaxListeners = function (n) {
            if (!isNumber(n) || n < 0 || isNaN(n))
                throw TypeError('n must be a positive number'); this._maxListeners = n; return this;
        }; EventEmitter.prototype.emit = function (type) {
            var er, handler, len, args, i, listeners; if (!this._events)
                this._events = {}; if (type === 'error') { if (!this._events.error || (isObject(this._events.error) && !this._events.error.length)) { er = arguments[1]; if (er instanceof Error) { throw er; } else { var err = new Error('Uncaught, unspecified "error" event. (' + er + ')'); err.context = er; throw err; } } }
            handler = this._events[type]; if (isUndefined(handler))
                return false; if (isFunction(handler)) { switch (arguments.length) { case 1: handler.call(this); break; case 2: handler.call(this, arguments[1]); break; case 3: handler.call(this, arguments[1], arguments[2]); break; default: args = Array.prototype.slice.call(arguments, 1); handler.apply(this, args); } } else if (isObject(handler)) {
                    args = Array.prototype.slice.call(arguments, 1); listeners = handler.slice(); len = listeners.length; for (i = 0; i < len; i++)
                        listeners[i].apply(this, args);
                }
            return true;
        }; EventEmitter.prototype.addListener = function (type, listener) {
            var m; if (!isFunction(listener))
                throw TypeError('listener must be a function'); if (!this._events)
                this._events = {}; if (this._events.newListener)
                this.emit('newListener', type, isFunction(listener.listener) ? listener.listener : listener); if (!this._events[type])
                this._events[type] = listener; else if (isObject(this._events[type]))
                this._events[type].push(listener); else
                this._events[type] = [this._events[type], listener]; if (isObject(this._events[type]) && !this._events[type].warned) {
                    if (!isUndefined(this._maxListeners)) { m = this._maxListeners; } else { m = EventEmitter.defaultMaxListeners; }
                    if (m && m > 0 && this._events[type].length > m) {
                        this._events[type].warned = true; console.error('(node) warning: possible EventEmitter memory ' +
                            'leak detected. %d listeners added. ' +
                            'Use emitter.setMaxListeners() to increase limit.', this._events[type].length); if (typeof console.trace === 'function') { console.trace(); }
                    }
                }
            return this;
        }; EventEmitter.prototype.on = EventEmitter.prototype.addListener; EventEmitter.prototype.once = function (type, listener) {
            if (!isFunction(listener))
                throw TypeError('listener must be a function'); var fired = false; function g() { this.removeListener(type, g); if (!fired) { fired = true; listener.apply(this, arguments); } }
            g.listener = listener; this.on(type, g); return this;
        }; EventEmitter.prototype.removeListener = function (type, listener) {
            var list, position, length, i; if (!isFunction(listener))
                throw TypeError('listener must be a function'); if (!this._events || !this._events[type])
                return this; list = this._events[type]; length = list.length; position = -1; if (list === listener || (isFunction(list.listener) && list.listener === listener)) {
                    delete this._events[type]; if (this._events.removeListener)
                        this.emit('removeListener', type, listener);
                } else if (isObject(list)) {
                    for (i = length; i-- > 0;) { if (list[i] === listener || (list[i].listener && list[i].listener === listener)) { position = i; break; } }
                    if (position < 0)
                        return this; if (list.length === 1) { list.length = 0; delete this._events[type]; } else { list.splice(position, 1); }
                    if (this._events.removeListener)
                        this.emit('removeListener', type, listener);
                }
            return this;
        }; EventEmitter.prototype.removeAllListeners = function (type) {
            var key, listeners; if (!this._events)
                return this; if (!this._events.removeListener) {
                    if (arguments.length === 0)
                        this._events = {}; else if (this._events[type])
                        delete this._events[type]; return this;
                }
            if (arguments.length === 0) {
                for (key in this._events) { if (key === 'removeListener') continue; this.removeAllListeners(key); }
                this.removeAllListeners('removeListener'); this._events = {}; return this;
            }
            listeners = this._events[type]; if (isFunction(listeners)) { this.removeListener(type, listeners); } else if (listeners) {
                while (listeners.length)
                    this.removeListener(type, listeners[listeners.length - 1]);
            }
            delete this._events[type]; return this;
        }; EventEmitter.prototype.listeners = function (type) {
            var ret; if (!this._events || !this._events[type])
                ret = []; else if (isFunction(this._events[type]))
                ret = [this._events[type]]; else
                ret = this._events[type].slice(); return ret;
        }; EventEmitter.prototype.listenerCount = function (type) {
            if (this._events) {
                var evlistener = this._events[type]; if (isFunction(evlistener))
                    return 1; else if (evlistener)
                    return evlistener.length;
            }
            return 0;
        }; EventEmitter.listenerCount = function (emitter, type) { return emitter.listenerCount(type); }; function isFunction(arg) { return typeof arg === 'function'; }
        function isNumber(arg) { return typeof arg === 'number'; }
        function isObject(arg) { return typeof arg === 'object' && arg !== null; }
        function isUndefined(arg) { return arg === void 0; }
    }), (function (module, exports, __webpack_require__) {
        "use strict"; (function (process) {
            if (!process.version || process.version.indexOf('v0.') === 0 || process.version.indexOf('v1.') === 0 && process.version.indexOf('v1.8.') !== 0) { module.exports = nextTick; } else { module.exports = process.nextTick; }
            function nextTick(fn, arg1, arg2, arg3) {
                if (typeof fn !== 'function') { throw new TypeError('"callback" argument must be a function'); }
                var len = arguments.length; var args, i; switch (len) {
                    case 0: case 1: return process.nextTick(fn); case 2: return process.nextTick(function afterTickOne() { fn.call(null, arg1); }); case 3: return process.nextTick(function afterTickTwo() { fn.call(null, arg1, arg2); }); case 4: return process.nextTick(function afterTickThree() { fn.call(null, arg1, arg2, arg3); }); default: args = new Array(len - 1); i = 0; while (i < args.length) { args[i++] = arguments[i]; }
                        return process.nextTick(function afterTick() { fn.apply(null, args); });
                }
            }
        }.call(exports, __webpack_require__(41)))
    }), (function (module, exports, __webpack_require__) {
        var buffer = __webpack_require__(123)
        var Buffer = buffer.Buffer
        function copyProps(src, dst) { for (var key in src) { dst[key] = src[key] } }
        if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) { module.exports = buffer } else {
            copyProps(buffer, exports)
            exports.Buffer = SafeBuffer
        }
        function SafeBuffer(arg, encodingOrOffset, length) { return Buffer(arg, encodingOrOffset, length) }
        copyProps(Buffer, SafeBuffer)
        SafeBuffer.from = function (arg, encodingOrOffset, length) {
            if (typeof arg === 'number') { throw new TypeError('Argument must not be a number') }
            return Buffer(arg, encodingOrOffset, length)
        }
        SafeBuffer.alloc = function (size, fill, encoding) {
            if (typeof size !== 'number') { throw new TypeError('Argument must be a number') }
            var buf = Buffer(size)
            if (fill !== undefined) { if (typeof encoding === 'string') { buf.fill(fill, encoding) } else { buf.fill(fill) } } else { buf.fill(0) }
            return buf
        }
        SafeBuffer.allocUnsafe = function (size) {
            if (typeof size !== 'number') { throw new TypeError('Argument must be a number') }
            return Buffer(size)
        }
        SafeBuffer.allocUnsafeSlow = function (size) {
            if (typeof size !== 'number') { throw new TypeError('Argument must be a number') }
            return buffer.SlowBuffer(size)
        }
    }), (function (module, exports, __webpack_require__) {
        var baseGetTag = __webpack_require__(21), isObjectLike = __webpack_require__(13); var numberTag = '[object Number]'; function isNumber(value) { return typeof value == 'number' || (isObjectLike(value) && baseGetTag(value) == numberTag); }
        module.exports = isNumber;
    }), (function (module, exports, __webpack_require__) {
        "use strict"; var ScoreToRating = function ScoreToRating(score) {
            if (score === -1) { return "error"; }
            if (score === 0) { return "feedback"; }
            if (score <= 4) { return "bad"; }
            if (score > 4 && score <= 7) { return "ok"; }
            if (score > 7) { return "good"; }
            return "";
        }; module.exports = ScoreToRating;
    }), (function (module, exports, __webpack_require__) {
        "use strict"; var _sentences = __webpack_require__(245); var _sentences2 = _interopRequireDefault(_sentences); function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
        var merge = __webpack_require__(11); var InvalidTypeError = __webpack_require__(161); var MissingArgument = __webpack_require__(57); var isUndefined = __webpack_require__(3); var isEmpty = __webpack_require__(10); var wordCountInText = __webpack_require__(313); var getLinkStatistics = __webpack_require__(315); var linkCount = __webpack_require__(326); var getLinks = __webpack_require__(164); var urlLength = __webpack_require__(327); var findKeywordInPageTitle = __webpack_require__(328); var matchKeywordInSubheadings = __webpack_require__(329); var getKeywordDensity = __webpack_require__(334); var stopWordsInKeyword = __webpack_require__(335); var stopWordsInUrl = __webpack_require__(338); var calculateFleschReading = __webpack_require__(339); var metaDescriptionLength = __webpack_require__(357); var imageCount = __webpack_require__(358); var altTagCount = __webpack_require__(360); var keyphraseLength = __webpack_require__(362); var metaDescriptionKeyword = __webpack_require__(363); var keywordCountInUrl = __webpack_require__(364); var findKeywordInFirstParagraph = __webpack_require__(365); var pageTitleWidth = __webpack_require__(367); var wordComplexity = __webpack_require__(368); var getParagraphLength = __webpack_require__(369); var countSentencesFromText = __webpack_require__(370); var countSentencesFromDescription = __webpack_require__(371); var getSubheadingTextLengths = __webpack_require__(372); var findTransitionWords = __webpack_require__(374); var passiveVoice = __webpack_require__(387); var getSentenceBeginnings = __webpack_require__(410); var relevantWords = __webpack_require__(418); var Researcher = function Researcher(paper) { this.setPaper(paper); this.defaultResearches = { urlLength: urlLength, wordCountInText: wordCountInText, findKeywordInPageTitle: findKeywordInPageTitle, calculateFleschReading: calculateFleschReading, getLinkStatistics: getLinkStatistics, getLinks: getLinks, linkCount: linkCount, imageCount: imageCount, altTagCount: altTagCount, matchKeywordInSubheadings: matchKeywordInSubheadings, getKeywordDensity: getKeywordDensity, stopWordsInKeyword: stopWordsInKeyword, stopWordsInUrl: stopWordsInUrl, metaDescriptionLength: metaDescriptionLength, keyphraseLength: keyphraseLength, keywordCountInUrl: keywordCountInUrl, firstParagraph: findKeywordInFirstParagraph, metaDescriptionKeyword: metaDescriptionKeyword, pageTitleWidth: pageTitleWidth, wordComplexity: wordComplexity, getParagraphLength: getParagraphLength, countSentencesFromText: countSentencesFromText, countSentencesFromDescription: countSentencesFromDescription, getSubheadingTextLengths: getSubheadingTextLengths, findTransitionWords: findTransitionWords, passiveVoice: passiveVoice, getSentenceBeginnings: getSentenceBeginnings, relevantWords: relevantWords, sentences: _sentences2.default }; this.customResearches = {}; }; Researcher.prototype.setPaper = function (paper) { this.paper = paper; }; Researcher.prototype.addResearch = function (name, research) {
            if (isUndefined(name) || isEmpty(name)) { throw new MissingArgument("Research name cannot be empty"); }
            if (!(research instanceof Function)) { throw new InvalidTypeError("The research requires a Function callback."); }
            this.customResearches[name] = research;
        }; Researcher.prototype.hasResearch = function (name) { return Object.keys(this.getAvailableResearches()).filter(function (research) { return research === name; }).length > 0; }; Researcher.prototype.getAvailableResearches = function () { return merge(this.defaultResearches, this.customResearches); }; Researcher.prototype.getResearch = function (name) {
            if (isUndefined(name) || isEmpty(name)) { throw new MissingArgument("Research name cannot be empty"); }
            if (!this.hasResearch(name)) { return false; }
            return this.getAvailableResearches()[name](this.paper, this);
        }; module.exports = Researcher;
    }), (function (module, exports, __webpack_require__) { var getNative = __webpack_require__(25), root = __webpack_require__(9); var Map = getNative(root, 'Map'); module.exports = Map; }), (function (module, exports, __webpack_require__) {
        var mapCacheClear = __webpack_require__(262), mapCacheDelete = __webpack_require__(269), mapCacheGet = __webpack_require__(271), mapCacheHas = __webpack_require__(272), mapCacheSet = __webpack_require__(273); function MapCache(entries) { var index = -1, length = entries == null ? 0 : entries.length; this.clear(); while (++index < length) { var entry = entries[index]; this.set(entry[0], entry[1]); } }
        MapCache.prototype.clear = mapCacheClear; MapCache.prototype['delete'] = mapCacheDelete; MapCache.prototype.get = mapCacheGet; MapCache.prototype.has = mapCacheHas; MapCache.prototype.set = mapCacheSet; module.exports = MapCache;
    }), (function (module, exports) {
        function arrayPush(array, values) {
            var index = -1, length = values.length, offset = array.length; while (++index < length) { array[offset + index] = values[index]; }
            return array;
        }
        module.exports = arrayPush;
    }), (function (module, exports, __webpack_require__) {
        var arrayFilter = __webpack_require__(86), stubArray = __webpack_require__(135); var objectProto = Object.prototype; var propertyIsEnumerable = objectProto.propertyIsEnumerable; var nativeGetSymbols = Object.getOwnPropertySymbols; var getSymbols = !nativeGetSymbols ? stubArray : function (object) {
            if (object == null) { return []; }
            object = Object(object); return arrayFilter(nativeGetSymbols(object), function (symbol) { return propertyIsEnumerable.call(object, symbol); });
        }; module.exports = getSymbols;
    }), (function (module, exports) {
        function arrayFilter(array, predicate) {
            var index = -1, length = array == null ? 0 : array.length, resIndex = 0, result = []; while (++index < length) { var value = array[index]; if (predicate(value, index, array)) { result[resIndex++] = value; } }
            return result;
        }
        module.exports = arrayFilter;
    }), (function (module, exports) {
        var MAX_SAFE_INTEGER = 9007199254740991; function isLength(value) { return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER; }
        module.exports = isLength;
    }), (function (module, exports, __webpack_require__) {
        var DataView = __webpack_require__(286), Map = __webpack_require__(82), Promise = __webpack_require__(287), Set = __webpack_require__(139), WeakMap = __webpack_require__(288), baseGetTag = __webpack_require__(21), toSource = __webpack_require__(128); var mapTag = '[object Map]', objectTag = '[object Object]', promiseTag = '[object Promise]', setTag = '[object Set]', weakMapTag = '[object WeakMap]'; var dataViewTag = '[object DataView]'; var dataViewCtorString = toSource(DataView), mapCtorString = toSource(Map), promiseCtorString = toSource(Promise), setCtorString = toSource(Set), weakMapCtorString = toSource(WeakMap); var getTag = baseGetTag; if ((DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) || (Map && getTag(new Map) != mapTag) || (Promise && getTag(Promise.resolve()) != promiseTag) || (Set && getTag(new Set) != setTag) || (WeakMap && getTag(new WeakMap) != weakMapTag)) {
            getTag = function (value) {
                var result = baseGetTag(value), Ctor = result == objectTag ? value.constructor : undefined, ctorString = Ctor ? toSource(Ctor) : ''; if (ctorString) { switch (ctorString) { case dataViewCtorString: return dataViewTag; case mapCtorString: return mapTag; case promiseCtorString: return promiseTag; case setCtorString: return setTag; case weakMapCtorString: return weakMapTag; } }
                return result;
            };
        }
        module.exports = getTag;
    }), (function (module, exports, __webpack_require__) {
        var castPath = __webpack_require__(71), toKey = __webpack_require__(47); function baseGet(object, path) {
            path = castPath(path, object); var index = 0, length = path.length; while (object != null && index < length) { object = object[toKey(path[index++])]; }
            return (index && index == length) ? object : undefined;
        }
        module.exports = baseGet;
    }), (function (module, exports, __webpack_require__) {
        var isArray = __webpack_require__(4), isSymbol = __webpack_require__(46); var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp = /^\w*$/; function isKey(value, object) {
            if (isArray(value)) { return false; }
            var type = typeof value; if (type == 'number' || type == 'symbol' || type == 'boolean' || value == null || isSymbol(value)) { return true; }
            return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || (object != null && value in Object(object));
        }
        module.exports = isKey;
    }), (function (module, exports, __webpack_require__) {
        var baseToString = __webpack_require__(294); function toString(value) { return value == null ? '' : baseToString(value); }
        module.exports = toString;
    }), (function (module, exports, __webpack_require__) {
        "use strict"; var blockElements = ["address", "article", "aside", "blockquote", "canvas", "dd", "div", "dl", "fieldset", "figcaption", "figure", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "header", "hgroup", "hr", "li", "main", "nav", "noscript", "ol", "output", "p", "pre", "section", "table", "tfoot", "ul", "video"]; var inlineElements = ["b", "big", "i", "small", "tt", "abbr", "acronym", "cite", "code", "dfn", "em", "kbd", "strong", "samp", "time", "var", "a", "bdo", "br", "img", "map", "object", "q", "script", "span", "sub", "sup", "button", "input", "label", "select", "textarea"]; var blockElementsRegex = new RegExp("^(" + blockElements.join("|") + ")$", "i"); var inlineElementsRegex = new RegExp("^(" + inlineElements.join("|") + ")$", "i"); var blockElementStartRegex = new RegExp("^<(" + blockElements.join("|") + ")[^>]*?>$", "i"); var blockElementEndRegex = new RegExp("^</(" + blockElements.join("|") + ")[^>]*?>$", "i"); var inlineElementStartRegex = new RegExp("^<(" + inlineElements.join("|") + ")[^>]*>$", "i"); var inlineElementEndRegex = new RegExp("^</(" + inlineElements.join("|") + ")[^>]*>$", "i"); var otherElementStartRegex = /^<([^>\s\/]+)[^>]*>$/; var otherElementEndRegex = /^<\/([^>\s]+)[^>]*>$/; var contentRegex = /^[^<]+$/; var greaterThanContentRegex = /^<[^><]*$/; var commentRegex = /<!--(.|[\r\n])*?-->/g; var core = __webpack_require__(149); var forEach = __webpack_require__(1); var memoize = __webpack_require__(36); var tokens = []; var htmlBlockTokenizer; function createTokenizer() { tokens = []; htmlBlockTokenizer = core(function (token) { tokens.push(token); }); htmlBlockTokenizer.addRule(contentRegex, "content"); htmlBlockTokenizer.addRule(greaterThanContentRegex, "greater-than-sign-content"); htmlBlockTokenizer.addRule(blockElementStartRegex, "block-start"); htmlBlockTokenizer.addRule(blockElementEndRegex, "block-end"); htmlBlockTokenizer.addRule(inlineElementStartRegex, "inline-start"); htmlBlockTokenizer.addRule(inlineElementEndRegex, "inline-end"); htmlBlockTokenizer.addRule(otherElementStartRegex, "other-element-start"); htmlBlockTokenizer.addRule(otherElementEndRegex, "other-element-end"); }
        function isBlockElement(htmlElementName) { return blockElementsRegex.test(htmlElementName); }
        function isInlineElement(htmlElementName) { return inlineElementsRegex.test(htmlElementName); }
        function getBlocks(text) {
            var blocks = [], depth = 0, blockStartTag = "", currentBlock = "", blockEndTag = ""; text = text.replace(commentRegex, ""); createTokenizer(); htmlBlockTokenizer.onText(text); htmlBlockTokenizer.end(); forEach(tokens, function (token, i) {
                var nextToken = tokens[i + 1]; switch (token.type) {
                    case "content": case "greater-than-sign-content": case "inline-start": case "inline-end": case "other-tag": case "other-element-start": case "other-element-end": case "greater than sign": if (!nextToken || depth === 0 && (nextToken.type === "block-start" || nextToken.type === "block-end")) { currentBlock += token.src; blocks.push(currentBlock); blockStartTag = ""; currentBlock = ""; blockEndTag = ""; } else { currentBlock += token.src; }
                        break; case "block-start": if (depth !== 0) {
                            if (currentBlock.trim() !== "") { blocks.push(currentBlock); }
                            currentBlock = ""; blockEndTag = "";
                        }
                        depth++; blockStartTag = token.src; break; case "block-end": depth--; blockEndTag = token.src; if ("" !== blockStartTag && "" !== blockEndTag) { blocks.push(blockStartTag + currentBlock + blockEndTag); } else if ("" !== currentBlock.trim()) { blocks.push(currentBlock); }
                        blockStartTag = ""; currentBlock = ""; blockEndTag = ""; break;
                }
                if (depth < 0) { depth = 0; }
            }); return blocks;
        }
        module.exports = { blockElements: blockElements, inlineElements: inlineElements, isBlockElement: isBlockElement, isInlineElement: isInlineElement, getBlocks: memoize(getBlocks) };
    }), (function (module, exports, __webpack_require__) {
        var Stack = __webpack_require__(58), assignMergeValue = __webpack_require__(151), baseFor = __webpack_require__(145), baseMergeDeep = __webpack_require__(305), isObject = __webpack_require__(5), keysIn = __webpack_require__(49); function baseMerge(object, source, srcIndex, customizer, stack) {
            if (object === source) { return; }
            baseFor(source, function (srcValue, key) {
                if (isObject(srcValue)) { stack || (stack = new Stack); baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack); }
                else {
                    var newValue = customizer ? customizer(object[key], srcValue, (key + ''), object, source, stack) : undefined; if (newValue === undefined) { newValue = srcValue; }
                    assignMergeValue(object, key, newValue);
                }
            }, keysIn);
        }
        module.exports = baseMerge;
    }), (function (module, exports, __webpack_require__) {
        var defineProperty = __webpack_require__(152); function baseAssignValue(object, key, value) { if (key == '__proto__' && defineProperty) { defineProperty(object, key, { 'configurable': true, 'enumerable': true, 'value': value, 'writable': true }); } else { object[key] = value; } }
        module.exports = baseAssignValue;
    }), (function (module, exports, __webpack_require__) {
        var Uint8Array = __webpack_require__(131); function cloneArrayBuffer(arrayBuffer) { var result = new arrayBuffer.constructor(arrayBuffer.byteLength); new Uint8Array(result).set(new Uint8Array(arrayBuffer)); return result; }
        module.exports = cloneArrayBuffer;
    }), (function (module, exports, __webpack_require__) { var overArg = __webpack_require__(138); var getPrototype = overArg(Object.getPrototypeOf, Object); module.exports = getPrototype; }), (function (module, exports, __webpack_require__) {
        var isArrayLike = __webpack_require__(19), isObjectLike = __webpack_require__(13); function isArrayLikeObject(value) { return isObjectLike(value) && isArrayLike(value); }
        module.exports = isArrayLikeObject;
    }), (function (module, exports, __webpack_require__) {
        var baseAssignValue = __webpack_require__(94), eq = __webpack_require__(35); var objectProto = Object.prototype; var hasOwnProperty = objectProto.hasOwnProperty; function assignValue(object, key, value) { var objValue = object[key]; if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) || (value === undefined && !(key in object))) { baseAssignValue(object, key, value); } }
        module.exports = assignValue;
    }), (function (module, exports, __webpack_require__) {
        var baseRest = __webpack_require__(39), isIterateeCall = __webpack_require__(160); function createAssigner(assigner) {
            return baseRest(function (object, sources) {
                var index = -1, length = sources.length, customizer = length > 1 ? sources[length - 1] : undefined, guard = length > 2 ? sources[2] : undefined; customizer = (assigner.length > 3 && typeof customizer == 'function') ? (length--, customizer) : undefined; if (guard && isIterateeCall(sources[0], sources[1], guard)) { customizer = length < 3 ? undefined : customizer; length = 1; }
                object = Object(object); while (++index < length) { var source = sources[index]; if (source) { assigner(object, source, index, customizer); } }
                return object;
            });
        }
        module.exports = createAssigner;
    }), (function (module, exports) {
        function apply(func, thisArg, args) {
            switch (args.length) { case 0: return func.call(thisArg); case 1: return func.call(thisArg, args[0]); case 2: return func.call(thisArg, args[0], args[1]); case 3: return func.call(thisArg, args[0], args[1], args[2]); }
            return func.apply(thisArg, args);
        }
        module.exports = apply;
    }), (function (module, exports, __webpack_require__) { "use strict"; var map = __webpack_require__(2); var addWordBoundary = __webpack_require__(50); var stripSpaces = __webpack_require__(8); var transliterate = __webpack_require__(163); var toRegex = function toRegex(keyword) { keyword = addWordBoundary(keyword); return new RegExp(keyword, "ig"); }; module.exports = function (text, keyword, locale) { var keywordRegex = toRegex(keyword); var matches = text.match(keywordRegex) || []; text = text.replace(keywordRegex, ""); var transliterateKeyword = transliterate(keyword, locale); var transliterateKeywordRegex = toRegex(transliterateKeyword); var transliterateMatches = text.match(transliterateKeywordRegex) || []; var combinedArray = matches.concat(transliterateMatches); return map(combinedArray, function (keyword) { return stripSpaces(keyword); }); }; }), (function (module, exports, __webpack_require__) {
        "use strict"; var urlFromAnchorRegex = /href=(["'])([^"']+)\1/i; var urlMethods = __webpack_require__(319); function removeHash(url) { return url.split("#")[0]; }
        function removeQueryArgs(url) { return url.split("?")[0]; }
        function removeTrailingSlash(url) { return url.replace(/\/$/, ""); }
        function addTrailingSlash(url) { return removeTrailingSlash(url) + "/"; }
        function getFromAnchorTag(anchorTag) { var urlMatch = urlFromAnchorRegex.exec(anchorTag); return urlMatch === null ? "" : urlMatch[2]; }
        function areEqual(urlA, urlB) { urlA = removeQueryArgs(removeHash(urlA)); urlB = removeQueryArgs(removeHash(urlB)); return addTrailingSlash(urlA) === addTrailingSlash(urlB); }
        function getHostname(url) { url = urlMethods.parse(url); return url.hostname; }
        module.exports = { removeHash: removeHash, removeQueryArgs: removeQueryArgs, removeTrailingSlash: removeTrailingSlash, addTrailingSlash: addTrailingSlash, getFromAnchorTag: getFromAnchorTag, areEqual: areEqual, getHostname: getHostname };
    }), (function (module, exports, __webpack_require__) { var createFind = __webpack_require__(347), findIndex = __webpack_require__(171); var find = createFind(findIndex); module.exports = find; }), (function (module, exports, __webpack_require__) {
        var isObject = __webpack_require__(5), isSymbol = __webpack_require__(46); var NAN = 0 / 0; var reTrim = /^\s+|\s+$/g; var reIsBadHex = /^[-+]0x[0-9a-f]+$/i; var reIsBinary = /^0b[01]+$/i; var reIsOctal = /^0o[0-7]+$/i; var freeParseInt = parseInt; function toNumber(value) {
            if (typeof value == 'number') { return value; }
            if (isSymbol(value)) { return NAN; }
            if (isObject(value)) { var other = typeof value.valueOf == 'function' ? value.valueOf() : value; value = isObject(other) ? (other + '') : other; }
            if (typeof value != 'string') { return value === 0 ? value : +value; }
            value = value.replace(reTrim, ''); var isBinary = reIsBinary.test(value); return (isBinary || reIsOctal.test(value)) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : (reIsBadHex.test(value) ? NAN : +value);
        }
        module.exports = toNumber;
    }), (function (module, exports, __webpack_require__) {
        "use strict"; var wordBoundaries = __webpack_require__(383)(); var includes = __webpack_require__(29); var addWordBoundary = __webpack_require__(50); var characterInBoundary = function characterInBoundary(character) { return includes(wordBoundaries, character); }; var isWordInSentence = function isWordInSentence(word, sentence) {
            word = word.toLocaleLowerCase(); sentence = sentence.toLocaleLowerCase(); var wordWithBoundaries = addWordBoundary(word); var occurrenceStart = sentence.search(new RegExp(wordWithBoundaries, "ig")); if (occurrenceStart === -1) { return false; }
            if (occurrenceStart > 0) { occurrenceStart += 1; }
            var occurrenceEnd = occurrenceStart + word.length; var previousCharacter = characterInBoundary(sentence[occurrenceStart - 1]) || occurrenceStart === 0; var nextCharacter = characterInBoundary(sentence[occurrenceEnd]) || occurrenceEnd === sentence.length; return previousCharacter && nextCharacter;
        }; module.exports = { characterInBoundary: characterInBoundary, isWordInSentence: isWordInSentence };
    }), (function (module, exports, __webpack_require__) {
        var baseFindIndex = __webpack_require__(172), baseIsNaN = __webpack_require__(384), strictIndexOf = __webpack_require__(385); function baseIndexOf(array, value, fromIndex) { return value === value ? strictIndexOf(array, value, fromIndex) : baseFindIndex(array, baseIsNaN, fromIndex); }
        module.exports = baseIndexOf;
    }), (function (module, exports, __webpack_require__) {
        var baseGetTag = __webpack_require__(21), isArray = __webpack_require__(4), isObjectLike = __webpack_require__(13); var stringTag = '[object String]'; function isString(value) { return typeof value == 'string' || (!isArray(value) && isObjectLike(value) && baseGetTag(value) == stringTag); }
        module.exports = isString;
    }), (function (module, exports, __webpack_require__) {
        "use strict"; var isUndefined = __webpack_require__(3); var forEach = __webpack_require__(1); var stripSpaces = __webpack_require__(8); var matchWordInSentence = __webpack_require__(105).isWordInSentence; var characterInBoundary = __webpack_require__(105).characterInBoundary; function getIndicesByWord(word, text) {
            var startIndex = 0; var searchStringLength = word.length; var index, indices = []; while ((index = text.indexOf(word, startIndex)) > -1) {
                var isPreviousCharacterWordBoundary = characterInBoundary(text[index - 1]) || index === 0; var isNextCharacterWordBoundary = characterInBoundary(text[index + searchStringLength]) || text.length === index + searchStringLength; if (isPreviousCharacterWordBoundary && isNextCharacterWordBoundary) { indices.push({ index: index, match: word }); }
                startIndex = index + searchStringLength;
            }
            return indices;
        }
        var getIndicesByWordList = function getIndicesByWordList(words, text) {
            var matchedWords = []; forEach(words, function (word) {
                word = stripSpaces(word); if (!matchWordInSentence(word, text)) { return; }
                matchedWords = matchedWords.concat(getIndicesByWord(word, text));
            }); return matchedWords;
        }; var sortIndices = function sortIndices(indices) { return indices.sort(function (a, b) { return a.index > b.index; }); }; var filterIndices = function filterIndices(indices) {
            indices = sortIndices(indices); var filtered = []; for (var i = 0; i < indices.length; i++) {
                if (!isUndefined(indices[i + 1]) && indices[i + 1].index < indices[i].index + indices[i].match.length) { filtered.push(indices[i]); i++; continue; }
                filtered.push(indices[i]);
            }
            return filtered;
        }; module.exports = { getIndicesByWord: getIndicesByWord, getIndicesByWordList: getIndicesByWordList, filterIndices: filterIndices, sortIndices: sortIndices };
    }), (function (module, exports, __webpack_require__) { "use strict"; var filteredAuxiliaries = ["am", "is", "are", "was", "were", "been", "get", "gets", "got", "gotten", "be", "she's", "he's", "it's", "i'm", "we're", "they're", "you're", "isn't", "weren't", "wasn't", "that's", "aren't"]; var notFilteredAuxiliaries = ["being", "getting", "having", "what's"]; module.exports = function () { return { filteredAuxiliaries: filteredAuxiliaries, notFilteredAuxiliaries: notFilteredAuxiliaries, all: filteredAuxiliaries.concat(notFilteredAuxiliaries) }; }; }), (function (module, exports, __webpack_require__) { var apply = __webpack_require__(100), assignInWith = __webpack_require__(394), baseRest = __webpack_require__(39), customDefaultsAssignIn = __webpack_require__(395); var defaults = baseRest(function (args) { args.push(undefined, customDefaultsAssignIn); return apply(assignInWith, undefined, args); }); module.exports = defaults; }), (function (module, exports, __webpack_require__) { "use strict"; var filteredPassiveAuxiliaries = __webpack_require__(109)().filteredAuxiliaries; var notFilteredPassiveAuxiliaries = __webpack_require__(109)().notFilteredAuxiliaries; var transitionWords = __webpack_require__(179)().singleWords; var articles = ["the", "an", "a"]; var cardinalNumerals = ["one", "two", "three", "four", "five", "six", "seven", "eight", "nine", "ten", "eleven", "twelve", "thirteen", "fourteen", "fifteen", "sixteen", "seventeen", "eighteen", "nineteen", "twenty", "hundred", "hundreds", "thousand", "thousands", "million", "millions", "billion", "billions"]; var ordinalNumerals = ["first", "second", "third", "fourth", "fifth", "sixth", "seventh", "eighth", "ninth", "tenth", "eleventh", "twelfth", "thirteenth", "fourteenth", "fifteenth", "sixteenth", "seventeenth", "eighteenth", "nineteenth", "twentieth"]; var personalPronounsNominative = ["i", "you", "he", "she", "it", "we", "they"]; var personalPronounsAccusative = ["me", "him", "us", "them"]; var demonstrativePronouns = ["this", "that", "these", "those"]; var possessivePronouns = ["my", "your", "his", "her", "its", "their", "our", "mine", "yours", "hers", "theirs", "ours"]; var quantifiers = ["all", "some", "many", "lot", "lots", "ton", "tons", "bit", "no", "every", "enough", "little", "much", "more", "most", "plenty", "several", "few", "fewer", "kind", "kinds"]; var reflexivePronouns = ["myself", "yourself", "himself", "herself", "itself", "oneself", "ourselves", "yourselves", "themselves"]; var indefinitePronouns = ["none", "nobody", "everyone", "everybody", "someone", "somebody", "anyone", "anybody", "nothing", "everything", "something", "anything", "each", "other", "whatever", "whichever", "whoever", "whomever", "whomsoever", "whosoever", "others", "neither", "both", "either", "any", "such"]; var indefinitePronounsPossessive = ["one's", "nobody's", "everyone's", "everybody's", "someone's", "somebody's", "anyone's", "anybody's", "nothing's", "everything's", "something's", "anything's", "whoever's", "others'", "other's", "another's", "neither's", "either's"]; var interrogativeDeterminers = ["which", "what", "whose"]; var interrogativePronouns = ["who", "whom"]; var interrogativeProAdverbs = ["where", "how", "why", "whether", "wherever", "whyever", "wheresoever", "whensoever", "howsoever", "whysoever", "whatsoever", "whereso", "whomso", "whenso", "howso", "whyso", "whoso", "whatso"]; var pronominalAdverbs = ["therefor", "therein", "hereby", "hereto", "wherein", "therewith", "herewith", "wherewith", "thereby"]; var locativeAdverbs = ["there", "here", "whither", "thither", "hither", "whence", "thence"]; var adverbialGenitives = ["always", "once", "twice", "thrice"]; var otherAuxiliaries = ["can", "cannot", "can't", "could", "couldn't", "could've", "dare", "dares", "dared", "do", "don't", "does", "doesn't", "did", "didn't", "done", "have", "haven't", "had", "hadn't", "has", "hasn't", "i've", "you've", "we've", "they've", "i'd", "you'd", "he'd", "she'd", "it'd", "we'd", "they'd", "would", "wouldn't", "would've", "may", "might", "must", "need", "needn't", "needs", "ought", "shall", "shalln't", "shan't", "should", "shouldn't", "will", "won't", "i'll", "you'll", "he'll", "she'll", "it'll", "we'll", "they'll", "there's", "there're", "there'll", "here's", "here're", "there'll"]; var copula = ["appear", "appears", "appeared", "become", "becomes", "became", "come", "comes", "came", "keep", "keeps", "kept", "remain", "remains", "remained", "stay", "stays", "stayed", "turn", "turns", "turned"]; var continuousVerbs = ["doing", "daring", "having", "appearing", "becoming", "coming", "keeping", "remaining", "staying", "saying", "asking", "stating", "seeming", "letting", "making", "setting", "showing", "putting", "adding", "going", "using", "trying", "containing"]; var prepositions = ["in", "from", "with", "under", "throughout", "atop", "for", "on", "of", "to", "aboard", "about", "above", "abreast", "absent", "across", "adjacent", "after", "against", "along", "alongside", "amid", "mid", "among", "apropos", "apud", "around", "as", "astride", "at", "ontop", "afore", "tofore", "behind", "ahind", "below", "ablow", "beneath", "neath", "beside", "between", "atween", "beyond", "ayond", "by", "chez", "circa", "spite", "down", "except", "into", "less", "like", "minus", "near", "nearer", "nearest", "anear", "notwithstanding", "off", "onto", "opposite", "out", "outen", "over", "past", "per", "pre", "qua", "sans", "sauf", "sithence", "through", "thru", "truout", "toward", "underneath", "up", "upon", "upside", "versus", "via", "vis-à-vis", "without", "ago", "apart", "aside", "aslant", "away", "withal", "towards", "amidst", "amongst", "midst", "whilst"]; var prepositionalAdverbs = ["back", "within", "forward", "backward", "ahead"]; var coordinatingConjunctions = ["and", "or", "and/or", "yet"]; var correlativeConjunctions = ["sooner", "just", "only"]; var subordinatingConjunctions = ["if", "even"]; var interviewVerbs = ["say", "says", "said", "claimed", "ask", "asks", "asked", "stated", "explain", "explains", "explained", "think", "thinks", "talks", "talked", "announces", "announced", "tells", "told", "discusses", "discussed", "suggests", "suggested", "understands", "understood"]; var additionalTransitionWords = ["again", "definitely", "eternally", "expressively", "instead", "expressly", "immediately", "including", "instantly", "namely", "naturally", "next", "notably", "now", "nowadays", "ordinarily", "positively", "truly", "ultimately", "uniquely", "usually", "almost", "maybe", "probably", "granted", "initially", "too", "actually", "already", "e.g", "i.e", "often", "regularly", "simply", "optionally", "perhaps", "sometimes", "likely", "never", "ever", "else", "inasmuch", "provided", "currently", "incidentally", "elsewhere", "particular", "recently", "relatively", "f.i", "clearly", "apparently"]; var intensifiers = ["highly", "very", "really", "extremely", "absolutely", "completely", "totally", "utterly", "quite", "somewhat", "seriously", "fairly", "fully", "amazingly"]; var delexicalizedVerbs = ["seem", "seems", "seemed", "let", "let's", "lets", "make", "makes", "made", "want", "showed", "shown", "go", "goes", "went", "gone", "take", "takes", "took", "taken", "put", "puts", "use", "used", "try", "tries", "tried", "mean", "means", "meant", "called", "based", "add", "adds", "added", "contain", "contains", "contained", "consist", "consists", "consisted", "ensure", "ensures", "ensured"]; var generalAdjectivesAdverbs = ["new", "newer", "newest", "old", "older", "oldest", "previous", "good", "well", "better", "best", "big", "bigger", "biggest", "easy", "easier", "easiest", "fast", "faster", "fastest", "far", "hard", "harder", "hardest", "least", "own", "large", "larger", "largest", "long", "longer", "longest", "low", "lower", "lowest", "high", "higher", "highest", "regular", "simple", "simpler", "simplest", "small", "smaller", "smallest", "tiny", "tinier", "tiniest", "short", "shorter", "shortest", "main", "actual", "nice", "nicer", "nicest", "real", "same", "able", "certain", "usual", "so-called", "mainly", "mostly", "recent", "anymore", "complete", "lately", "possible", "commonly", "constantly", "continually", "directly", "easily", "nearly", "slightly", "somewhere", "estimated", "latest", "different", "similar", "widely", "bad", "worse", "worst", "great", "specific", "available", "average", "awful", "awesome", "basic", "beautiful", "busy", "current", "entire", "everywhere", "important", "major", "multiple", "normal", "necessary", "obvious", "partly", "special", "last", "early", "earlier", "earliest", "young", "younger", "youngest", ""]; var interjections = ["oh", "wow", "tut-tut", "tsk-tsk", "ugh", "whew", "phew", "yeah", "yea", "shh", "oops", "ouch", "aha", "yikes"]; var recipeWords = ["tbs", "tbsp", "spk", "lb", "qt", "pk", "bu", "oz", "pt", "mod", "doz", "hr", "f.g", "ml", "dl", "cl", "l", "mg", "g", "kg", "quart"]; var timeWords = ["seconds", "minute", "minutes", "hour", "hours", "day", "days", "week", "weeks", "month", "months", "year", "years", "today", "tomorrow", "yesterday"]; var vagueNouns = ["thing", "things", "way", "ways", "matter", "case", "likelihood", "ones", "piece", "pieces", "stuff", "times", "part", "parts", "percent", "instance", "instances", "aspect", "aspects", "item", "items", "idea", "theme", "person", "instance", "instances", "detail", "details", "factor", "factors", "difference", "differences"]; var miscellaneous = ["not", "yes", "sure", "top", "bottom", "ok", "okay", "amen", "aka", "etc", "etcetera", "sorry", "please"]; var titlesPreceding = ["ms", "mss", "mrs", "mr", "dr", "prof"]; var titlesFollowing = ["jr", "sr"]; module.exports = function () { return { filteredAtEnding: [].concat(ordinalNumerals, continuousVerbs, generalAdjectivesAdverbs), filteredAtBeginningAndEnding: [].concat(articles, prepositions, coordinatingConjunctions, demonstrativePronouns, intensifiers, quantifiers, possessivePronouns), filteredAnywhere: [].concat(transitionWords, adverbialGenitives, personalPronounsNominative, personalPronounsAccusative, reflexivePronouns, interjections, cardinalNumerals, filteredPassiveAuxiliaries, otherAuxiliaries, copula, interviewVerbs, delexicalizedVerbs, indefinitePronouns, correlativeConjunctions, subordinatingConjunctions, interrogativeDeterminers, interrogativePronouns, interrogativeProAdverbs, locativeAdverbs, miscellaneous, prepositionalAdverbs, pronominalAdverbs, recipeWords, timeWords, vagueNouns), cannotDirectlyPrecedePassiveParticiple: [].concat(articles, prepositions, demonstrativePronouns, possessivePronouns, ordinalNumerals, continuousVerbs, quantifiers), cannotBeBetweenPassiveAuxiliaryAndParticiple: [].concat(otherAuxiliaries, copula, interviewVerbs, delexicalizedVerbs), all: [].concat(articles, cardinalNumerals, ordinalNumerals, demonstrativePronouns, possessivePronouns, reflexivePronouns, personalPronounsNominative, personalPronounsAccusative, quantifiers, indefinitePronouns, continuousVerbs, indefinitePronounsPossessive, interrogativeDeterminers, interrogativePronouns, interrogativeProAdverbs, pronominalAdverbs, locativeAdverbs, adverbialGenitives, prepositionalAdverbs, filteredPassiveAuxiliaries, notFilteredPassiveAuxiliaries, otherAuxiliaries, copula, prepositions, coordinatingConjunctions, correlativeConjunctions, subordinatingConjunctions, interviewVerbs, transitionWords, additionalTransitionWords, intensifiers, delexicalizedVerbs, interjections, generalAdjectivesAdverbs, recipeWords, vagueNouns, miscellaneous, titlesPreceding, titlesFollowing) }; }; }), (function (module, exports, __webpack_require__) {
        var baseIndexOf = __webpack_require__(106); function arrayIncludes(array, value) { var length = array == null ? 0 : array.length; return !!length && baseIndexOf(array, value, 0) > -1; }
        module.exports = arrayIncludes;
    }), (function (module, exports) {
        function arrayIncludesWith(array, value, comparator) {
            var index = -1, length = array == null ? 0 : array.length; while (++index < length) { if (comparator(value, array[index])) { return true; } }
            return false;
        }
        module.exports = arrayIncludesWith;
    }), (function (module, exports, __webpack_require__) { "use strict"; var Assessor = __webpack_require__(42); var introductionKeyword = __webpack_require__(194); var keyphraseLength = __webpack_require__(195); var keywordDensity = __webpack_require__(196); var keywordStopWords = __webpack_require__(197); var metaDescriptionKeyword = __webpack_require__(198); var MetaDescriptionLength = __webpack_require__(199); var SubheadingsKeyword = __webpack_require__(200); var textCompetingLinks = __webpack_require__(201); var TextImages = __webpack_require__(202); var TextLength = __webpack_require__(203); var OutboundLinks = __webpack_require__(205); var internalLinks = __webpack_require__(206); var titleKeyword = __webpack_require__(207); var TitleWidth = __webpack_require__(208); var UrlKeyword = __webpack_require__(209); var UrlLength = __webpack_require__(210); var urlStopWords = __webpack_require__(211); var SEOAssessor = function SEOAssessor(i18n, options) { Assessor.call(this, i18n, options); this._assessments = [introductionKeyword, keyphraseLength, keywordDensity, keywordStopWords, metaDescriptionKeyword, new MetaDescriptionLength(), new SubheadingsKeyword(), textCompetingLinks, new TextImages(), new TextLength(), new OutboundLinks(), internalLinks, titleKeyword, new TitleWidth(), new UrlKeyword(), new UrlLength(), urlStopWords]; }; __webpack_require__(14).inherits(SEOAssessor, Assessor); module.exports = SEOAssessor; }), (function (module, exports, __webpack_require__) {
        "use strict"; var Assessor = __webpack_require__(42); var fleschReadingEase = __webpack_require__(212); var paragraphTooLong = __webpack_require__(213); var SentenceLengthInText = __webpack_require__(214); var SubheadingDistributionTooLong = __webpack_require__(215); var transitionWords = __webpack_require__(216); var passiveVoice = __webpack_require__(217); var sentenceBeginnings = __webpack_require__(218); var textPresence = __webpack_require__(219); var contentConfiguration = __webpack_require__(220); var scoreToRating = __webpack_require__(80); var map = __webpack_require__(2); var sum = __webpack_require__(174); var ContentAssessor = function ContentAssessor(i18n) { var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {}; Assessor.call(this, i18n, options); var locale = options.hasOwnProperty("locale") ? options.locale : "en_US"; this._assessments = [fleschReadingEase, new SubheadingDistributionTooLong(), paragraphTooLong, new SentenceLengthInText(contentConfiguration(locale).sentenceLength), transitionWords, passiveVoice, textPresence, sentenceBeginnings]; }; __webpack_require__(14).inherits(ContentAssessor, Assessor); ContentAssessor.prototype.calculatePenaltyPointsFullSupport = function (rating) { switch (rating) { case "bad": return 3; case "ok": return 2; default: case "good": return 0; } }; ContentAssessor.prototype.calculatePenaltyPointsPartialSupport = function (rating) { switch (rating) { case "bad": return 4; case "ok": return 2; default: case "good": return 0; } }; ContentAssessor.prototype._allAssessmentsSupported = function () { var numberOfAssessments = 8; var applicableAssessments = this.getApplicableAssessments(); return applicableAssessments.length === numberOfAssessments; }; ContentAssessor.prototype.calculatePenaltyPoints = function () {
            var results = this.getValidResults(); var penaltyPoints = map(results, function (result) {
                var rating = scoreToRating(result.getScore()); if (this._allAssessmentsSupported()) { return this.calculatePenaltyPointsFullSupport(rating); }
                return this.calculatePenaltyPointsPartialSupport(rating);
            }.bind(this)); return sum(penaltyPoints);
        }; ContentAssessor.prototype._ratePenaltyPoints = function (totalPenaltyPoints) {
            if (this.getValidResults().length === 1) { return 30; }
            if (this._allAssessmentsSupported()) {
                if (totalPenaltyPoints > 6) { return 30; }
                if (totalPenaltyPoints > 4) { return 60; }
            } else {
                if (totalPenaltyPoints > 4) { return 30; }
                if (totalPenaltyPoints > 2) { return 60; }
            }
            return 90;
        }; ContentAssessor.prototype.calculateOverallScore = function () {
            var results = this.getValidResults(); if (results.length === 0) { return 30; }
            var totalPenaltyPoints = this.calculatePenaltyPoints(); return this._ratePenaltyPoints(totalPenaltyPoints);
        }; module.exports = ContentAssessor;
    }), (function (module, exports, __webpack_require__) { "use strict"; module.exports = function (recommendedValue, valueLength) { return valueLength > recommendedValue; }; }), (function (module, exports, __webpack_require__) { var apply = __webpack_require__(100), baseRest = __webpack_require__(39), customDefaultsMerge = __webpack_require__(450), mergeWith = __webpack_require__(451); var defaultsDeep = baseRest(function (args) { args.push(undefined, customDefaultsMerge); return apply(mergeWith, undefined, args); }); module.exports = defaultsDeep; }), (function (module, exports) {
        function arrayReduce(array, iteratee, accumulator, initAccum) {
            var index = -1, length = array == null ? 0 : array.length; if (initAccum && length) { accumulator = array[++index]; }
            while (++index < length) { accumulator = iteratee(accumulator, array[index], index, array); }
            return accumulator;
        }
        module.exports = arrayReduce;
    }), (function (module, exports, __webpack_require__) {
        var isObject = __webpack_require__(5), now = __webpack_require__(473), toNumber = __webpack_require__(104); var FUNC_ERROR_TEXT = 'Expected a function'; var nativeMax = Math.max, nativeMin = Math.min; function debounce(func, wait, options) {
            var lastArgs, lastThis, maxWait, result, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true; if (typeof func != 'function') { throw new TypeError(FUNC_ERROR_TEXT); }
            wait = toNumber(wait) || 0; if (isObject(options)) { leading = !!options.leading; maxing = 'maxWait' in options; maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait; trailing = 'trailing' in options ? !!options.trailing : trailing; }
            function invokeFunc(time) { var args = lastArgs, thisArg = lastThis; lastArgs = lastThis = undefined; lastInvokeTime = time; result = func.apply(thisArg, args); return result; }
            function leadingEdge(time) { lastInvokeTime = time; timerId = setTimeout(timerExpired, wait); return leading ? invokeFunc(time) : result; }
            function remainingWait(time) { var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, result = wait - timeSinceLastCall; return maxing ? nativeMin(result, maxWait - timeSinceLastInvoke) : result; }
            function shouldInvoke(time) { var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime; return (lastCallTime === undefined || (timeSinceLastCall >= wait) || (timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait)); }
            function timerExpired() {
                var time = now(); if (shouldInvoke(time)) { return trailingEdge(time); }
                timerId = setTimeout(timerExpired, remainingWait(time));
            }
            function trailingEdge(time) {
                timerId = undefined; if (trailing && lastArgs) { return invokeFunc(time); }
                lastArgs = lastThis = undefined; return result;
            }
            function cancel() {
                if (timerId !== undefined) { clearTimeout(timerId); }
                lastInvokeTime = 0; lastArgs = lastCallTime = lastThis = timerId = undefined;
            }
            function flush() { return timerId === undefined ? result : trailingEdge(now()); }
            function debounced() {
                var time = now(), isInvoking = shouldInvoke(time); lastArgs = arguments; lastThis = this; lastCallTime = time; if (isInvoking) {
                    if (timerId === undefined) { return leadingEdge(lastCallTime); }
                    if (maxing) { timerId = setTimeout(timerExpired, wait); return invokeFunc(lastCallTime); }
                }
                if (timerId === undefined) { timerId = setTimeout(timerExpired, wait); }
                return result;
            }
            debounced.cancel = cancel; debounced.flush = flush; return debounced;
        }
        module.exports = debounce;
    }), (function (module, exports) { module.exports = { "Aacute": "Á", "aacute": "á", "Abreve": "Ă", "abreve": "ă", "ac": "∾", "acd": "∿", "acE": "∾̳", "Acirc": "Â", "acirc": "â", "acute": "´", "Acy": "А", "acy": "а", "AElig": "Æ", "aelig": "æ", "af": "⁡", "Afr": "𝔄", "afr": "𝔞", "Agrave": "À", "agrave": "à", "alefsym": "ℵ", "aleph": "ℵ", "Alpha": "Α", "alpha": "α", "Amacr": "Ā", "amacr": "ā", "amalg": "⨿", "amp": "&", "AMP": "&", "andand": "⩕", "And": "⩓", "and": "∧", "andd": "⩜", "andslope": "⩘", "andv": "⩚", "ang": "∠", "ange": "⦤", "angle": "∠", "angmsdaa": "⦨", "angmsdab": "⦩", "angmsdac": "⦪", "angmsdad": "⦫", "angmsdae": "⦬", "angmsdaf": "⦭", "angmsdag": "⦮", "angmsdah": "⦯", "angmsd": "∡", "angrt": "∟", "angrtvb": "⊾", "angrtvbd": "⦝", "angsph": "∢", "angst": "Å", "angzarr": "⍼", "Aogon": "Ą", "aogon": "ą", "Aopf": "𝔸", "aopf": "𝕒", "apacir": "⩯", "ap": "≈", "apE": "⩰", "ape": "≊", "apid": "≋", "apos": "'", "ApplyFunction": "⁡", "approx": "≈", "approxeq": "≊", "Aring": "Å", "aring": "å", "Ascr": "𝒜", "ascr": "𝒶", "Assign": "≔", "ast": "*", "asymp": "≈", "asympeq": "≍", "Atilde": "Ã", "atilde": "ã", "Auml": "Ä", "auml": "ä", "awconint": "∳", "awint": "⨑", "backcong": "≌", "backepsilon": "϶", "backprime": "‵", "backsim": "∽", "backsimeq": "⋍", "Backslash": "∖", "Barv": "⫧", "barvee": "⊽", "barwed": "⌅", "Barwed": "⌆", "barwedge": "⌅", "bbrk": "⎵", "bbrktbrk": "⎶", "bcong": "≌", "Bcy": "Б", "bcy": "б", "bdquo": "„", "becaus": "∵", "because": "∵", "Because": "∵", "bemptyv": "⦰", "bepsi": "϶", "bernou": "ℬ", "Bernoullis": "ℬ", "Beta": "Β", "beta": "β", "beth": "ℶ", "between": "≬", "Bfr": "𝔅", "bfr": "𝔟", "bigcap": "⋂", "bigcirc": "◯", "bigcup": "⋃", "bigodot": "⨀", "bigoplus": "⨁", "bigotimes": "⨂", "bigsqcup": "⨆", "bigstar": "★", "bigtriangledown": "▽", "bigtriangleup": "△", "biguplus": "⨄", "bigvee": "⋁", "bigwedge": "⋀", "bkarow": "⤍", "blacklozenge": "⧫", "blacksquare": "▪", "blacktriangle": "▴", "blacktriangledown": "▾", "blacktriangleleft": "◂", "blacktriangleright": "▸", "blank": "␣", "blk12": "▒", "blk14": "░", "blk34": "▓", "block": "█", "bne": "=⃥", "bnequiv": "≡⃥", "bNot": "⫭", "bnot": "⌐", "Bopf": "𝔹", "bopf": "𝕓", "bot": "⊥", "bottom": "⊥", "bowtie": "⋈", "boxbox": "⧉", "boxdl": "┐", "boxdL": "╕", "boxDl": "╖", "boxDL": "╗", "boxdr": "┌", "boxdR": "╒", "boxDr": "╓", "boxDR": "╔", "boxh": "─", "boxH": "═", "boxhd": "┬", "boxHd": "╤", "boxhD": "╥", "boxHD": "╦", "boxhu": "┴", "boxHu": "╧", "boxhU": "╨", "boxHU": "╩", "boxminus": "⊟", "boxplus": "⊞", "boxtimes": "⊠", "boxul": "┘", "boxuL": "╛", "boxUl": "╜", "boxUL": "╝", "boxur": "└", "boxuR": "╘", "boxUr": "╙", "boxUR": "╚", "boxv": "│", "boxV": "║", "boxvh": "┼", "boxvH": "╪", "boxVh": "╫", "boxVH": "╬", "boxvl": "┤", "boxvL": "╡", "boxVl": "╢", "boxVL": "╣", "boxvr": "├", "boxvR": "╞", "boxVr": "╟", "boxVR": "╠", "bprime": "‵", "breve": "˘", "Breve": "˘", "brvbar": "¦", "bscr": "𝒷", "Bscr": "ℬ", "bsemi": "⁏", "bsim": "∽", "bsime": "⋍", "bsolb": "⧅", "bsol": "\\", "bsolhsub": "⟈", "bull": "•", "bullet": "•", "bump": "≎", "bumpE": "⪮", "bumpe": "≏", "Bumpeq": "≎", "bumpeq": "≏", "Cacute": "Ć", "cacute": "ć", "capand": "⩄", "capbrcup": "⩉", "capcap": "⩋", "cap": "∩", "Cap": "⋒", "capcup": "⩇", "capdot": "⩀", "CapitalDifferentialD": "ⅅ", "caps": "∩︀", "caret": "⁁", "caron": "ˇ", "Cayleys": "ℭ", "ccaps": "⩍", "Ccaron": "Č", "ccaron": "č", "Ccedil": "Ç", "ccedil": "ç", "Ccirc": "Ĉ", "ccirc": "ĉ", "Cconint": "∰", "ccups": "⩌", "ccupssm": "⩐", "Cdot": "Ċ", "cdot": "ċ", "cedil": "¸", "Cedilla": "¸", "cemptyv": "⦲", "cent": "¢", "centerdot": "·", "CenterDot": "·", "cfr": "𝔠", "Cfr": "ℭ", "CHcy": "Ч", "chcy": "ч", "check": "✓", "checkmark": "✓", "Chi": "Χ", "chi": "χ", "circ": "ˆ", "circeq": "≗", "circlearrowleft": "↺", "circlearrowright": "↻", "circledast": "⊛", "circledcirc": "⊚", "circleddash": "⊝", "CircleDot": "⊙", "circledR": "®", "circledS": "Ⓢ", "CircleMinus": "⊖", "CirclePlus": "⊕", "CircleTimes": "⊗", "cir": "○", "cirE": "⧃", "cire": "≗", "cirfnint": "⨐", "cirmid": "⫯", "cirscir": "⧂", "ClockwiseContourIntegral": "∲", "CloseCurlyDoubleQuote": "”", "CloseCurlyQuote": "’", "clubs": "♣", "clubsuit": "♣", "colon": ":", "Colon": "∷", "Colone": "⩴", "colone": "≔", "coloneq": "≔", "comma": ",", "commat": "@", "comp": "∁", "compfn": "∘", "complement": "∁", "complexes": "ℂ", "cong": "≅", "congdot": "⩭", "Congruent": "≡", "conint": "∮", "Conint": "∯", "ContourIntegral": "∮", "copf": "𝕔", "Copf": "ℂ", "coprod": "∐", "Coproduct": "∐", "copy": "©", "COPY": "©", "copysr": "℗", "CounterClockwiseContourIntegral": "∳", "crarr": "↵", "cross": "✗", "Cross": "⨯", "Cscr": "𝒞", "cscr": "𝒸", "csub": "⫏", "csube": "⫑", "csup": "⫐", "csupe": "⫒", "ctdot": "⋯", "cudarrl": "⤸", "cudarrr": "⤵", "cuepr": "⋞", "cuesc": "⋟", "cularr": "↶", "cularrp": "⤽", "cupbrcap": "⩈", "cupcap": "⩆", "CupCap": "≍", "cup": "∪", "Cup": "⋓", "cupcup": "⩊", "cupdot": "⊍", "cupor": "⩅", "cups": "∪︀", "curarr": "↷", "curarrm": "⤼", "curlyeqprec": "⋞", "curlyeqsucc": "⋟", "curlyvee": "⋎", "curlywedge": "⋏", "curren": "¤", "curvearrowleft": "↶", "curvearrowright": "↷", "cuvee": "⋎", "cuwed": "⋏", "cwconint": "∲", "cwint": "∱", "cylcty": "⌭", "dagger": "†", "Dagger": "‡", "daleth": "ℸ", "darr": "↓", "Darr": "↡", "dArr": "⇓", "dash": "‐", "Dashv": "⫤", "dashv": "⊣", "dbkarow": "⤏", "dblac": "˝", "Dcaron": "Ď", "dcaron": "ď", "Dcy": "Д", "dcy": "д", "ddagger": "‡", "ddarr": "⇊", "DD": "ⅅ", "dd": "ⅆ", "DDotrahd": "⤑", "ddotseq": "⩷", "deg": "°", "Del": "∇", "Delta": "Δ", "delta": "δ", "demptyv": "⦱", "dfisht": "⥿", "Dfr": "𝔇", "dfr": "𝔡", "dHar": "⥥", "dharl": "⇃", "dharr": "⇂", "DiacriticalAcute": "´", "DiacriticalDot": "˙", "DiacriticalDoubleAcute": "˝", "DiacriticalGrave": "`", "DiacriticalTilde": "˜", "diam": "⋄", "diamond": "⋄", "Diamond": "⋄", "diamondsuit": "♦", "diams": "♦", "die": "¨", "DifferentialD": "ⅆ", "digamma": "ϝ", "disin": "⋲", "div": "÷", "divide": "÷", "divideontimes": "⋇", "divonx": "⋇", "DJcy": "Ђ", "djcy": "ђ", "dlcorn": "⌞", "dlcrop": "⌍", "dollar": "$", "Dopf": "𝔻", "dopf": "𝕕", "Dot": "¨", "dot": "˙", "DotDot": "⃜", "doteq": "≐", "doteqdot": "≑", "DotEqual": "≐", "dotminus": "∸", "dotplus": "∔", "dotsquare": "⊡", "doublebarwedge": "⌆", "DoubleContourIntegral": "∯", "DoubleDot": "¨", "DoubleDownArrow": "⇓", "DoubleLeftArrow": "⇐", "DoubleLeftRightArrow": "⇔", "DoubleLeftTee": "⫤", "DoubleLongLeftArrow": "⟸", "DoubleLongLeftRightArrow": "⟺", "DoubleLongRightArrow": "⟹", "DoubleRightArrow": "⇒", "DoubleRightTee": "⊨", "DoubleUpArrow": "⇑", "DoubleUpDownArrow": "⇕", "DoubleVerticalBar": "∥", "DownArrowBar": "⤓", "downarrow": "↓", "DownArrow": "↓", "Downarrow": "⇓", "DownArrowUpArrow": "⇵", "DownBreve": "̑", "downdownarrows": "⇊", "downharpoonleft": "⇃", "downharpoonright": "⇂", "DownLeftRightVector": "⥐", "DownLeftTeeVector": "⥞", "DownLeftVectorBar": "⥖", "DownLeftVector": "↽", "DownRightTeeVector": "⥟", "DownRightVectorBar": "⥗", "DownRightVector": "⇁", "DownTeeArrow": "↧", "DownTee": "⊤", "drbkarow": "⤐", "drcorn": "⌟", "drcrop": "⌌", "Dscr": "𝒟", "dscr": "𝒹", "DScy": "Ѕ", "dscy": "ѕ", "dsol": "⧶", "Dstrok": "Đ", "dstrok": "đ", "dtdot": "⋱", "dtri": "▿", "dtrif": "▾", "duarr": "⇵", "duhar": "⥯", "dwangle": "⦦", "DZcy": "Џ", "dzcy": "џ", "dzigrarr": "⟿", "Eacute": "É", "eacute": "é", "easter": "⩮", "Ecaron": "Ě", "ecaron": "ě", "Ecirc": "Ê", "ecirc": "ê", "ecir": "≖", "ecolon": "≕", "Ecy": "Э", "ecy": "э", "eDDot": "⩷", "Edot": "Ė", "edot": "ė", "eDot": "≑", "ee": "ⅇ", "efDot": "≒", "Efr": "𝔈", "efr": "𝔢", "eg": "⪚", "Egrave": "È", "egrave": "è", "egs": "⪖", "egsdot": "⪘", "el": "⪙", "Element": "∈", "elinters": "⏧", "ell": "ℓ", "els": "⪕", "elsdot": "⪗", "Emacr": "Ē", "emacr": "ē", "empty": "∅", "emptyset": "∅", "EmptySmallSquare": "◻", "emptyv": "∅", "EmptyVerySmallSquare": "▫", "emsp13": " ", "emsp14": " ", "emsp": " ", "ENG": "Ŋ", "eng": "ŋ", "ensp": " ", "Eogon": "Ę", "eogon": "ę", "Eopf": "𝔼", "eopf": "𝕖", "epar": "⋕", "eparsl": "⧣", "eplus": "⩱", "epsi": "ε", "Epsilon": "Ε", "epsilon": "ε", "epsiv": "ϵ", "eqcirc": "≖", "eqcolon": "≕", "eqsim": "≂", "eqslantgtr": "⪖", "eqslantless": "⪕", "Equal": "⩵", "equals": "=", "EqualTilde": "≂", "equest": "≟", "Equilibrium": "⇌", "equiv": "≡", "equivDD": "⩸", "eqvparsl": "⧥", "erarr": "⥱", "erDot": "≓", "escr": "ℯ", "Escr": "ℰ", "esdot": "≐", "Esim": "⩳", "esim": "≂", "Eta": "Η", "eta": "η", "ETH": "Ð", "eth": "ð", "Euml": "Ë", "euml": "ë", "euro": "€", "excl": "!", "exist": "∃", "Exists": "∃", "expectation": "ℰ", "exponentiale": "ⅇ", "ExponentialE": "ⅇ", "fallingdotseq": "≒", "Fcy": "Ф", "fcy": "ф", "female": "♀", "ffilig": "ﬃ", "fflig": "ﬀ", "ffllig": "ﬄ", "Ffr": "𝔉", "ffr": "𝔣", "filig": "ﬁ", "FilledSmallSquare": "◼", "FilledVerySmallSquare": "▪", "fjlig": "fj", "flat": "♭", "fllig": "ﬂ", "fltns": "▱", "fnof": "ƒ", "Fopf": "𝔽", "fopf": "𝕗", "forall": "∀", "ForAll": "∀", "fork": "⋔", "forkv": "⫙", "Fouriertrf": "ℱ", "fpartint": "⨍", "frac12": "½", "frac13": "⅓", "frac14": "¼", "frac15": "⅕", "frac16": "⅙", "frac18": "⅛", "frac23": "⅔", "frac25": "⅖", "frac34": "¾", "frac35": "⅗", "frac38": "⅜", "frac45": "⅘", "frac56": "⅚", "frac58": "⅝", "frac78": "⅞", "frasl": "⁄", "frown": "⌢", "fscr": "𝒻", "Fscr": "ℱ", "gacute": "ǵ", "Gamma": "Γ", "gamma": "γ", "Gammad": "Ϝ", "gammad": "ϝ", "gap": "⪆", "Gbreve": "Ğ", "gbreve": "ğ", "Gcedil": "Ģ", "Gcirc": "Ĝ", "gcirc": "ĝ", "Gcy": "Г", "gcy": "г", "Gdot": "Ġ", "gdot": "ġ", "ge": "≥", "gE": "≧", "gEl": "⪌", "gel": "⋛", "geq": "≥", "geqq": "≧", "geqslant": "⩾", "gescc": "⪩", "ges": "⩾", "gesdot": "⪀", "gesdoto": "⪂", "gesdotol": "⪄", "gesl": "⋛︀", "gesles": "⪔", "Gfr": "𝔊", "gfr": "𝔤", "gg": "≫", "Gg": "⋙", "ggg": "⋙", "gimel": "ℷ", "GJcy": "Ѓ", "gjcy": "ѓ", "gla": "⪥", "gl": "≷", "glE": "⪒", "glj": "⪤", "gnap": "⪊", "gnapprox": "⪊", "gne": "⪈", "gnE": "≩", "gneq": "⪈", "gneqq": "≩", "gnsim": "⋧", "Gopf": "𝔾", "gopf": "𝕘", "grave": "`", "GreaterEqual": "≥", "GreaterEqualLess": "⋛", "GreaterFullEqual": "≧", "GreaterGreater": "⪢", "GreaterLess": "≷", "GreaterSlantEqual": "⩾", "GreaterTilde": "≳", "Gscr": "𝒢", "gscr": "ℊ", "gsim": "≳", "gsime": "⪎", "gsiml": "⪐", "gtcc": "⪧", "gtcir": "⩺", "gt": ">", "GT": ">", "Gt": "≫", "gtdot": "⋗", "gtlPar": "⦕", "gtquest": "⩼", "gtrapprox": "⪆", "gtrarr": "⥸", "gtrdot": "⋗", "gtreqless": "⋛", "gtreqqless": "⪌", "gtrless": "≷", "gtrsim": "≳", "gvertneqq": "≩︀", "gvnE": "≩︀", "Hacek": "ˇ", "hairsp": " ", "half": "½", "hamilt": "ℋ", "HARDcy": "Ъ", "hardcy": "ъ", "harrcir": "⥈", "harr": "↔", "hArr": "⇔", "harrw": "↭", "Hat": "^", "hbar": "ℏ", "Hcirc": "Ĥ", "hcirc": "ĥ", "hearts": "♥", "heartsuit": "♥", "hellip": "…", "hercon": "⊹", "hfr": "𝔥", "Hfr": "ℌ", "HilbertSpace": "ℋ", "hksearow": "⤥", "hkswarow": "⤦", "hoarr": "⇿", "homtht": "∻", "hookleftarrow": "↩", "hookrightarrow": "↪", "hopf": "𝕙", "Hopf": "ℍ", "horbar": "―", "HorizontalLine": "─", "hscr": "𝒽", "Hscr": "ℋ", "hslash": "ℏ", "Hstrok": "Ħ", "hstrok": "ħ", "HumpDownHump": "≎", "HumpEqual": "≏", "hybull": "⁃", "hyphen": "‐", "Iacute": "Í", "iacute": "í", "ic": "⁣", "Icirc": "Î", "icirc": "î", "Icy": "И", "icy": "и", "Idot": "İ", "IEcy": "Е", "iecy": "е", "iexcl": "¡", "iff": "⇔", "ifr": "𝔦", "Ifr": "ℑ", "Igrave": "Ì", "igrave": "ì", "ii": "ⅈ", "iiiint": "⨌", "iiint": "∭", "iinfin": "⧜", "iiota": "℩", "IJlig": "Ĳ", "ijlig": "ĳ", "Imacr": "Ī", "imacr": "ī", "image": "ℑ", "ImaginaryI": "ⅈ", "imagline": "ℐ", "imagpart": "ℑ", "imath": "ı", "Im": "ℑ", "imof": "⊷", "imped": "Ƶ", "Implies": "⇒", "incare": "℅", "in": "∈", "infin": "∞", "infintie": "⧝", "inodot": "ı", "intcal": "⊺", "int": "∫", "Int": "∬", "integers": "ℤ", "Integral": "∫", "intercal": "⊺", "Intersection": "⋂", "intlarhk": "⨗", "intprod": "⨼", "InvisibleComma": "⁣", "InvisibleTimes": "⁢", "IOcy": "Ё", "iocy": "ё", "Iogon": "Į", "iogon": "į", "Iopf": "𝕀", "iopf": "𝕚", "Iota": "Ι", "iota": "ι", "iprod": "⨼", "iquest": "¿", "iscr": "𝒾", "Iscr": "ℐ", "isin": "∈", "isindot": "⋵", "isinE": "⋹", "isins": "⋴", "isinsv": "⋳", "isinv": "∈", "it": "⁢", "Itilde": "Ĩ", "itilde": "ĩ", "Iukcy": "І", "iukcy": "і", "Iuml": "Ï", "iuml": "ï", "Jcirc": "Ĵ", "jcirc": "ĵ", "Jcy": "Й", "jcy": "й", "Jfr": "𝔍", "jfr": "𝔧", "jmath": "ȷ", "Jopf": "𝕁", "jopf": "𝕛", "Jscr": "𝒥", "jscr": "𝒿", "Jsercy": "Ј", "jsercy": "ј", "Jukcy": "Є", "jukcy": "є", "Kappa": "Κ", "kappa": "κ", "kappav": "ϰ", "Kcedil": "Ķ", "kcedil": "ķ", "Kcy": "К", "kcy": "к", "Kfr": "𝔎", "kfr": "𝔨", "kgreen": "ĸ", "KHcy": "Х", "khcy": "х", "KJcy": "Ќ", "kjcy": "ќ", "Kopf": "𝕂", "kopf": "𝕜", "Kscr": "𝒦", "kscr": "𝓀", "lAarr": "⇚", "Lacute": "Ĺ", "lacute": "ĺ", "laemptyv": "⦴", "lagran": "ℒ", "Lambda": "Λ", "lambda": "λ", "lang": "⟨", "Lang": "⟪", "langd": "⦑", "langle": "⟨", "lap": "⪅", "Laplacetrf": "ℒ", "laquo": "«", "larrb": "⇤", "larrbfs": "⤟", "larr": "←", "Larr": "↞", "lArr": "⇐", "larrfs": "⤝", "larrhk": "↩", "larrlp": "↫", "larrpl": "⤹", "larrsim": "⥳", "larrtl": "↢", "latail": "⤙", "lAtail": "⤛", "lat": "⪫", "late": "⪭", "lates": "⪭︀", "lbarr": "⤌", "lBarr": "⤎", "lbbrk": "❲", "lbrace": "{", "lbrack": "[", "lbrke": "⦋", "lbrksld": "⦏", "lbrkslu": "⦍", "Lcaron": "Ľ", "lcaron": "ľ", "Lcedil": "Ļ", "lcedil": "ļ", "lceil": "⌈", "lcub": "{", "Lcy": "Л", "lcy": "л", "ldca": "⤶", "ldquo": "“", "ldquor": "„", "ldrdhar": "⥧", "ldrushar": "⥋", "ldsh": "↲", "le": "≤", "lE": "≦", "LeftAngleBracket": "⟨", "LeftArrowBar": "⇤", "leftarrow": "←", "LeftArrow": "←", "Leftarrow": "⇐", "LeftArrowRightArrow": "⇆", "leftarrowtail": "↢", "LeftCeiling": "⌈", "LeftDoubleBracket": "⟦", "LeftDownTeeVector": "⥡", "LeftDownVectorBar": "⥙", "LeftDownVector": "⇃", "LeftFloor": "⌊", "leftharpoondown": "↽", "leftharpoonup": "↼", "leftleftarrows": "⇇", "leftrightarrow": "↔", "LeftRightArrow": "↔", "Leftrightarrow": "⇔", "leftrightarrows": "⇆", "leftrightharpoons": "⇋", "leftrightsquigarrow": "↭", "LeftRightVector": "⥎", "LeftTeeArrow": "↤", "LeftTee": "⊣", "LeftTeeVector": "⥚", "leftthreetimes": "⋋", "LeftTriangleBar": "⧏", "LeftTriangle": "⊲", "LeftTriangleEqual": "⊴", "LeftUpDownVector": "⥑", "LeftUpTeeVector": "⥠", "LeftUpVectorBar": "⥘", "LeftUpVector": "↿", "LeftVectorBar": "⥒", "LeftVector": "↼", "lEg": "⪋", "leg": "⋚", "leq": "≤", "leqq": "≦", "leqslant": "⩽", "lescc": "⪨", "les": "⩽", "lesdot": "⩿", "lesdoto": "⪁", "lesdotor": "⪃", "lesg": "⋚︀", "lesges": "⪓", "lessapprox": "⪅", "lessdot": "⋖", "lesseqgtr": "⋚", "lesseqqgtr": "⪋", "LessEqualGreater": "⋚", "LessFullEqual": "≦", "LessGreater": "≶", "lessgtr": "≶", "LessLess": "⪡", "lesssim": "≲", "LessSlantEqual": "⩽", "LessTilde": "≲", "lfisht": "⥼", "lfloor": "⌊", "Lfr": "𝔏", "lfr": "𝔩", "lg": "≶", "lgE": "⪑", "lHar": "⥢", "lhard": "↽", "lharu": "↼", "lharul": "⥪", "lhblk": "▄", "LJcy": "Љ", "ljcy": "љ", "llarr": "⇇", "ll": "≪", "Ll": "⋘", "llcorner": "⌞", "Lleftarrow": "⇚", "llhard": "⥫", "lltri": "◺", "Lmidot": "Ŀ", "lmidot": "ŀ", "lmoustache": "⎰", "lmoust": "⎰", "lnap": "⪉", "lnapprox": "⪉", "lne": "⪇", "lnE": "≨", "lneq": "⪇", "lneqq": "≨", "lnsim": "⋦", "loang": "⟬", "loarr": "⇽", "lobrk": "⟦", "longleftarrow": "⟵", "LongLeftArrow": "⟵", "Longleftarrow": "⟸", "longleftrightarrow": "⟷", "LongLeftRightArrow": "⟷", "Longleftrightarrow": "⟺", "longmapsto": "⟼", "longrightarrow": "⟶", "LongRightArrow": "⟶", "Longrightarrow": "⟹", "looparrowleft": "↫", "looparrowright": "↬", "lopar": "⦅", "Lopf": "𝕃", "lopf": "𝕝", "loplus": "⨭", "lotimes": "⨴", "lowast": "∗", "lowbar": "_", "LowerLeftArrow": "↙", "LowerRightArrow": "↘", "loz": "◊", "lozenge": "◊", "lozf": "⧫", "lpar": "(", "lparlt": "⦓", "lrarr": "⇆", "lrcorner": "⌟", "lrhar": "⇋", "lrhard": "⥭", "lrm": "‎", "lrtri": "⊿", "lsaquo": "‹", "lscr": "𝓁", "Lscr": "ℒ", "lsh": "↰", "Lsh": "↰", "lsim": "≲", "lsime": "⪍", "lsimg": "⪏", "lsqb": "[", "lsquo": "‘", "lsquor": "‚", "Lstrok": "Ł", "lstrok": "ł", "ltcc": "⪦", "ltcir": "⩹", "lt": "<", "LT": "<", "Lt": "≪", "ltdot": "⋖", "lthree": "⋋", "ltimes": "⋉", "ltlarr": "⥶", "ltquest": "⩻", "ltri": "◃", "ltrie": "⊴", "ltrif": "◂", "ltrPar": "⦖", "lurdshar": "⥊", "luruhar": "⥦", "lvertneqq": "≨︀", "lvnE": "≨︀", "macr": "¯", "male": "♂", "malt": "✠", "maltese": "✠", "Map": "⤅", "map": "↦", "mapsto": "↦", "mapstodown": "↧", "mapstoleft": "↤", "mapstoup": "↥", "marker": "▮", "mcomma": "⨩", "Mcy": "М", "mcy": "м", "mdash": "—", "mDDot": "∺", "measuredangle": "∡", "MediumSpace": " ", "Mellintrf": "ℳ", "Mfr": "𝔐", "mfr": "𝔪", "mho": "℧", "micro": "µ", "midast": "*", "midcir": "⫰", "mid": "∣", "middot": "·", "minusb": "⊟", "minus": "−", "minusd": "∸", "minusdu": "⨪", "MinusPlus": "∓", "mlcp": "⫛", "mldr": "…", "mnplus": "∓", "models": "⊧", "Mopf": "𝕄", "mopf": "𝕞", "mp": "∓", "mscr": "𝓂", "Mscr": "ℳ", "mstpos": "∾", "Mu": "Μ", "mu": "μ", "multimap": "⊸", "mumap": "⊸", "nabla": "∇", "Nacute": "Ń", "nacute": "ń", "nang": "∠⃒", "nap": "≉", "napE": "⩰̸", "napid": "≋̸", "napos": "ŉ", "napprox": "≉", "natural": "♮", "naturals": "ℕ", "natur": "♮", "nbsp": " ", "nbump": "≎̸", "nbumpe": "≏̸", "ncap": "⩃", "Ncaron": "Ň", "ncaron": "ň", "Ncedil": "Ņ", "ncedil": "ņ", "ncong": "≇", "ncongdot": "⩭̸", "ncup": "⩂", "Ncy": "Н", "ncy": "н", "ndash": "–", "nearhk": "⤤", "nearr": "↗", "neArr": "⇗", "nearrow": "↗", "ne": "≠", "nedot": "≐̸", "NegativeMediumSpace": "​", "NegativeThickSpace": "​", "NegativeThinSpace": "​", "NegativeVeryThinSpace": "​", "nequiv": "≢", "nesear": "⤨", "nesim": "≂̸", "NestedGreaterGreater": "≫", "NestedLessLess": "≪", "NewLine": "\n", "nexist": "∄", "nexists": "∄", "Nfr": "𝔑", "nfr": "𝔫", "ngE": "≧̸", "nge": "≱", "ngeq": "≱", "ngeqq": "≧̸", "ngeqslant": "⩾̸", "nges": "⩾̸", "nGg": "⋙̸", "ngsim": "≵", "nGt": "≫⃒", "ngt": "≯", "ngtr": "≯", "nGtv": "≫̸", "nharr": "↮", "nhArr": "⇎", "nhpar": "⫲", "ni": "∋", "nis": "⋼", "nisd": "⋺", "niv": "∋", "NJcy": "Њ", "njcy": "њ", "nlarr": "↚", "nlArr": "⇍", "nldr": "‥", "nlE": "≦̸", "nle": "≰", "nleftarrow": "↚", "nLeftarrow": "⇍", "nleftrightarrow": "↮", "nLeftrightarrow": "⇎", "nleq": "≰", "nleqq": "≦̸", "nleqslant": "⩽̸", "nles": "⩽̸", "nless": "≮", "nLl": "⋘̸", "nlsim": "≴", "nLt": "≪⃒", "nlt": "≮", "nltri": "⋪", "nltrie": "⋬", "nLtv": "≪̸", "nmid": "∤", "NoBreak": "⁠", "NonBreakingSpace": " ", "nopf": "𝕟", "Nopf": "ℕ", "Not": "⫬", "not": "¬", "NotCongruent": "≢", "NotCupCap": "≭", "NotDoubleVerticalBar": "∦", "NotElement": "∉", "NotEqual": "≠", "NotEqualTilde": "≂̸", "NotExists": "∄", "NotGreater": "≯", "NotGreaterEqual": "≱", "NotGreaterFullEqual": "≧̸", "NotGreaterGreater": "≫̸", "NotGreaterLess": "≹", "NotGreaterSlantEqual": "⩾̸", "NotGreaterTilde": "≵", "NotHumpDownHump": "≎̸", "NotHumpEqual": "≏̸", "notin": "∉", "notindot": "⋵̸", "notinE": "⋹̸", "notinva": "∉", "notinvb": "⋷", "notinvc": "⋶", "NotLeftTriangleBar": "⧏̸", "NotLeftTriangle": "⋪", "NotLeftTriangleEqual": "⋬", "NotLess": "≮", "NotLessEqual": "≰", "NotLessGreater": "≸", "NotLessLess": "≪̸", "NotLessSlantEqual": "⩽̸", "NotLessTilde": "≴", "NotNestedGreaterGreater": "⪢̸", "NotNestedLessLess": "⪡̸", "notni": "∌", "notniva": "∌", "notnivb": "⋾", "notnivc": "⋽", "NotPrecedes": "⊀", "NotPrecedesEqual": "⪯̸", "NotPrecedesSlantEqual": "⋠", "NotReverseElement": "∌", "NotRightTriangleBar": "⧐̸", "NotRightTriangle": "⋫", "NotRightTriangleEqual": "⋭", "NotSquareSubset": "⊏̸", "NotSquareSubsetEqual": "⋢", "NotSquareSuperset": "⊐̸", "NotSquareSupersetEqual": "⋣", "NotSubset": "⊂⃒", "NotSubsetEqual": "⊈", "NotSucceeds": "⊁", "NotSucceedsEqual": "⪰̸", "NotSucceedsSlantEqual": "⋡", "NotSucceedsTilde": "≿̸", "NotSuperset": "⊃⃒", "NotSupersetEqual": "⊉", "NotTilde": "≁", "NotTildeEqual": "≄", "NotTildeFullEqual": "≇", "NotTildeTilde": "≉", "NotVerticalBar": "∤", "nparallel": "∦", "npar": "∦", "nparsl": "⫽⃥", "npart": "∂̸", "npolint": "⨔", "npr": "⊀", "nprcue": "⋠", "nprec": "⊀", "npreceq": "⪯̸", "npre": "⪯̸", "nrarrc": "⤳̸", "nrarr": "↛", "nrArr": "⇏", "nrarrw": "↝̸", "nrightarrow": "↛", "nRightarrow": "⇏", "nrtri": "⋫", "nrtrie": "⋭", "nsc": "⊁", "nsccue": "⋡", "nsce": "⪰̸", "Nscr": "𝒩", "nscr": "𝓃", "nshortmid": "∤", "nshortparallel": "∦", "nsim": "≁", "nsime": "≄", "nsimeq": "≄", "nsmid": "∤", "nspar": "∦", "nsqsube": "⋢", "nsqsupe": "⋣", "nsub": "⊄", "nsubE": "⫅̸", "nsube": "⊈", "nsubset": "⊂⃒", "nsubseteq": "⊈", "nsubseteqq": "⫅̸", "nsucc": "⊁", "nsucceq": "⪰̸", "nsup": "⊅", "nsupE": "⫆̸", "nsupe": "⊉", "nsupset": "⊃⃒", "nsupseteq": "⊉", "nsupseteqq": "⫆̸", "ntgl": "≹", "Ntilde": "Ñ", "ntilde": "ñ", "ntlg": "≸", "ntriangleleft": "⋪", "ntrianglelefteq": "⋬", "ntriangleright": "⋫", "ntrianglerighteq": "⋭", "Nu": "Ν", "nu": "ν", "num": "#", "numero": "№", "numsp": " ", "nvap": "≍⃒", "nvdash": "⊬", "nvDash": "⊭", "nVdash": "⊮", "nVDash": "⊯", "nvge": "≥⃒", "nvgt": ">⃒", "nvHarr": "⤄", "nvinfin": "⧞", "nvlArr": "⤂", "nvle": "≤⃒", "nvlt": "<⃒", "nvltrie": "⊴⃒", "nvrArr": "⤃", "nvrtrie": "⊵⃒", "nvsim": "∼⃒", "nwarhk": "⤣", "nwarr": "↖", "nwArr": "⇖", "nwarrow": "↖", "nwnear": "⤧", "Oacute": "Ó", "oacute": "ó", "oast": "⊛", "Ocirc": "Ô", "ocirc": "ô", "ocir": "⊚", "Ocy": "О", "ocy": "о", "odash": "⊝", "Odblac": "Ő", "odblac": "ő", "odiv": "⨸", "odot": "⊙", "odsold": "⦼", "OElig": "Œ", "oelig": "œ", "ofcir": "⦿", "Ofr": "𝔒", "ofr": "𝔬", "ogon": "˛", "Ograve": "Ò", "ograve": "ò", "ogt": "⧁", "ohbar": "⦵", "ohm": "Ω", "oint": "∮", "olarr": "↺", "olcir": "⦾", "olcross": "⦻", "oline": "‾", "olt": "⧀", "Omacr": "Ō", "omacr": "ō", "Omega": "Ω", "omega": "ω", "Omicron": "Ο", "omicron": "ο", "omid": "⦶", "ominus": "⊖", "Oopf": "𝕆", "oopf": "𝕠", "opar": "⦷", "OpenCurlyDoubleQuote": "“", "OpenCurlyQuote": "‘", "operp": "⦹", "oplus": "⊕", "orarr": "↻", "Or": "⩔", "or": "∨", "ord": "⩝", "order": "ℴ", "orderof": "ℴ", "ordf": "ª", "ordm": "º", "origof": "⊶", "oror": "⩖", "orslope": "⩗", "orv": "⩛", "oS": "Ⓢ", "Oscr": "𝒪", "oscr": "ℴ", "Oslash": "Ø", "oslash": "ø", "osol": "⊘", "Otilde": "Õ", "otilde": "õ", "otimesas": "⨶", "Otimes": "⨷", "otimes": "⊗", "Ouml": "Ö", "ouml": "ö", "ovbar": "⌽", "OverBar": "‾", "OverBrace": "⏞", "OverBracket": "⎴", "OverParenthesis": "⏜", "para": "¶", "parallel": "∥", "par": "∥", "parsim": "⫳", "parsl": "⫽", "part": "∂", "PartialD": "∂", "Pcy": "П", "pcy": "п", "percnt": "%", "period": ".", "permil": "‰", "perp": "⊥", "pertenk": "‱", "Pfr": "𝔓", "pfr": "𝔭", "Phi": "Φ", "phi": "φ", "phiv": "ϕ", "phmmat": "ℳ", "phone": "☎", "Pi": "Π", "pi": "π", "pitchfork": "⋔", "piv": "ϖ", "planck": "ℏ", "planckh": "ℎ", "plankv": "ℏ", "plusacir": "⨣", "plusb": "⊞", "pluscir": "⨢", "plus": "+", "plusdo": "∔", "plusdu": "⨥", "pluse": "⩲", "PlusMinus": "±", "plusmn": "±", "plussim": "⨦", "plustwo": "⨧", "pm": "±", "Poincareplane": "ℌ", "pointint": "⨕", "popf": "𝕡", "Popf": "ℙ", "pound": "£", "prap": "⪷", "Pr": "⪻", "pr": "≺", "prcue": "≼", "precapprox": "⪷", "prec": "≺", "preccurlyeq": "≼", "Precedes": "≺", "PrecedesEqual": "⪯", "PrecedesSlantEqual": "≼", "PrecedesTilde": "≾", "preceq": "⪯", "precnapprox": "⪹", "precneqq": "⪵", "precnsim": "⋨", "pre": "⪯", "prE": "⪳", "precsim": "≾", "prime": "′", "Prime": "″", "primes": "ℙ", "prnap": "⪹", "prnE": "⪵", "prnsim": "⋨", "prod": "∏", "Product": "∏", "profalar": "⌮", "profline": "⌒", "profsurf": "⌓", "prop": "∝", "Proportional": "∝", "Proportion": "∷", "propto": "∝", "prsim": "≾", "prurel": "⊰", "Pscr": "𝒫", "pscr": "𝓅", "Psi": "Ψ", "psi": "ψ", "puncsp": " ", "Qfr": "𝔔", "qfr": "𝔮", "qint": "⨌", "qopf": "𝕢", "Qopf": "ℚ", "qprime": "⁗", "Qscr": "𝒬", "qscr": "𝓆", "quaternions": "ℍ", "quatint": "⨖", "quest": "?", "questeq": "≟", "quot": "\"", "QUOT": "\"", "rAarr": "⇛", "race": "∽̱", "Racute": "Ŕ", "racute": "ŕ", "radic": "√", "raemptyv": "⦳", "rang": "⟩", "Rang": "⟫", "rangd": "⦒", "range": "⦥", "rangle": "⟩", "raquo": "»", "rarrap": "⥵", "rarrb": "⇥", "rarrbfs": "⤠", "rarrc": "⤳", "rarr": "→", "Rarr": "↠", "rArr": "⇒", "rarrfs": "⤞", "rarrhk": "↪", "rarrlp": "↬", "rarrpl": "⥅", "rarrsim": "⥴", "Rarrtl": "⤖", "rarrtl": "↣", "rarrw": "↝", "ratail": "⤚", "rAtail": "⤜", "ratio": "∶", "rationals": "ℚ", "rbarr": "⤍", "rBarr": "⤏", "RBarr": "⤐", "rbbrk": "❳", "rbrace": "}", "rbrack": "]", "rbrke": "⦌", "rbrksld": "⦎", "rbrkslu": "⦐", "Rcaron": "Ř", "rcaron": "ř", "Rcedil": "Ŗ", "rcedil": "ŗ", "rceil": "⌉", "rcub": "}", "Rcy": "Р", "rcy": "р", "rdca": "⤷", "rdldhar": "⥩", "rdquo": "”", "rdquor": "”", "rdsh": "↳", "real": "ℜ", "realine": "ℛ", "realpart": "ℜ", "reals": "ℝ", "Re": "ℜ", "rect": "▭", "reg": "®", "REG": "®", "ReverseElement": "∋", "ReverseEquilibrium": "⇋", "ReverseUpEquilibrium": "⥯", "rfisht": "⥽", "rfloor": "⌋", "rfr": "𝔯", "Rfr": "ℜ", "rHar": "⥤", "rhard": "⇁", "rharu": "⇀", "rharul": "⥬", "Rho": "Ρ", "rho": "ρ", "rhov": "ϱ", "RightAngleBracket": "⟩", "RightArrowBar": "⇥", "rightarrow": "→", "RightArrow": "→", "Rightarrow": "⇒", "RightArrowLeftArrow": "⇄", "rightarrowtail": "↣", "RightCeiling": "⌉", "RightDoubleBracket": "⟧", "RightDownTeeVector": "⥝", "RightDownVectorBar": "⥕", "RightDownVector": "⇂", "RightFloor": "⌋", "rightharpoondown": "⇁", "rightharpoonup": "⇀", "rightleftarrows": "⇄", "rightleftharpoons": "⇌", "rightrightarrows": "⇉", "rightsquigarrow": "↝", "RightTeeArrow": "↦", "RightTee": "⊢", "RightTeeVector": "⥛", "rightthreetimes": "⋌", "RightTriangleBar": "⧐", "RightTriangle": "⊳", "RightTriangleEqual": "⊵", "RightUpDownVector": "⥏", "RightUpTeeVector": "⥜", "RightUpVectorBar": "⥔", "RightUpVector": "↾", "RightVectorBar": "⥓", "RightVector": "⇀", "ring": "˚", "risingdotseq": "≓", "rlarr": "⇄", "rlhar": "⇌", "rlm": "‏", "rmoustache": "⎱", "rmoust": "⎱", "rnmid": "⫮", "roang": "⟭", "roarr": "⇾", "robrk": "⟧", "ropar": "⦆", "ropf": "𝕣", "Ropf": "ℝ", "roplus": "⨮", "rotimes": "⨵", "RoundImplies": "⥰", "rpar": ")", "rpargt": "⦔", "rppolint": "⨒", "rrarr": "⇉", "Rrightarrow": "⇛", "rsaquo": "›", "rscr": "𝓇", "Rscr": "ℛ", "rsh": "↱", "Rsh": "↱", "rsqb": "]", "rsquo": "’", "rsquor": "’", "rthree": "⋌", "rtimes": "⋊", "rtri": "▹", "rtrie": "⊵", "rtrif": "▸", "rtriltri": "⧎", "RuleDelayed": "⧴", "ruluhar": "⥨", "rx": "℞", "Sacute": "Ś", "sacute": "ś", "sbquo": "‚", "scap": "⪸", "Scaron": "Š", "scaron": "š", "Sc": "⪼", "sc": "≻", "sccue": "≽", "sce": "⪰", "scE": "⪴", "Scedil": "Ş", "scedil": "ş", "Scirc": "Ŝ", "scirc": "ŝ", "scnap": "⪺", "scnE": "⪶", "scnsim": "⋩", "scpolint": "⨓", "scsim": "≿", "Scy": "С", "scy": "с", "sdotb": "⊡", "sdot": "⋅", "sdote": "⩦", "searhk": "⤥", "searr": "↘", "seArr": "⇘", "searrow": "↘", "sect": "§", "semi": ";", "seswar": "⤩", "setminus": "∖", "setmn": "∖", "sext": "✶", "Sfr": "𝔖", "sfr": "𝔰", "sfrown": "⌢", "sharp": "♯", "SHCHcy": "Щ", "shchcy": "щ", "SHcy": "Ш", "shcy": "ш", "ShortDownArrow": "↓", "ShortLeftArrow": "←", "shortmid": "∣", "shortparallel": "∥", "ShortRightArrow": "→", "ShortUpArrow": "↑", "shy": "­", "Sigma": "Σ", "sigma": "σ", "sigmaf": "ς", "sigmav": "ς", "sim": "∼", "simdot": "⩪", "sime": "≃", "simeq": "≃", "simg": "⪞", "simgE": "⪠", "siml": "⪝", "simlE": "⪟", "simne": "≆", "simplus": "⨤", "simrarr": "⥲", "slarr": "←", "SmallCircle": "∘", "smallsetminus": "∖", "smashp": "⨳", "smeparsl": "⧤", "smid": "∣", "smile": "⌣", "smt": "⪪", "smte": "⪬", "smtes": "⪬︀", "SOFTcy": "Ь", "softcy": "ь", "solbar": "⌿", "solb": "⧄", "sol": "/", "Sopf": "𝕊", "sopf": "𝕤", "spades": "♠", "spadesuit": "♠", "spar": "∥", "sqcap": "⊓", "sqcaps": "⊓︀", "sqcup": "⊔", "sqcups": "⊔︀", "Sqrt": "√", "sqsub": "⊏", "sqsube": "⊑", "sqsubset": "⊏", "sqsubseteq": "⊑", "sqsup": "⊐", "sqsupe": "⊒", "sqsupset": "⊐", "sqsupseteq": "⊒", "square": "□", "Square": "□", "SquareIntersection": "⊓", "SquareSubset": "⊏", "SquareSubsetEqual": "⊑", "SquareSuperset": "⊐", "SquareSupersetEqual": "⊒", "SquareUnion": "⊔", "squarf": "▪", "squ": "□", "squf": "▪", "srarr": "→", "Sscr": "𝒮", "sscr": "𝓈", "ssetmn": "∖", "ssmile": "⌣", "sstarf": "⋆", "Star": "⋆", "star": "☆", "starf": "★", "straightepsilon": "ϵ", "straightphi": "ϕ", "strns": "¯", "sub": "⊂", "Sub": "⋐", "subdot": "⪽", "subE": "⫅", "sube": "⊆", "subedot": "⫃", "submult": "⫁", "subnE": "⫋", "subne": "⊊", "subplus": "⪿", "subrarr": "⥹", "subset": "⊂", "Subset": "⋐", "subseteq": "⊆", "subseteqq": "⫅", "SubsetEqual": "⊆", "subsetneq": "⊊", "subsetneqq": "⫋", "subsim": "⫇", "subsub": "⫕", "subsup": "⫓", "succapprox": "⪸", "succ": "≻", "succcurlyeq": "≽", "Succeeds": "≻", "SucceedsEqual": "⪰", "SucceedsSlantEqual": "≽", "SucceedsTilde": "≿", "succeq": "⪰", "succnapprox": "⪺", "succneqq": "⪶", "succnsim": "⋩", "succsim": "≿", "SuchThat": "∋", "sum": "∑", "Sum": "∑", "sung": "♪", "sup1": "¹", "sup2": "²", "sup3": "³", "sup": "⊃", "Sup": "⋑", "supdot": "⪾", "supdsub": "⫘", "supE": "⫆", "supe": "⊇", "supedot": "⫄", "Superset": "⊃", "SupersetEqual": "⊇", "suphsol": "⟉", "suphsub": "⫗", "suplarr": "⥻", "supmult": "⫂", "supnE": "⫌", "supne": "⊋", "supplus": "⫀", "supset": "⊃", "Supset": "⋑", "supseteq": "⊇", "supseteqq": "⫆", "supsetneq": "⊋", "supsetneqq": "⫌", "supsim": "⫈", "supsub": "⫔", "supsup": "⫖", "swarhk": "⤦", "swarr": "↙", "swArr": "⇙", "swarrow": "↙", "swnwar": "⤪", "szlig": "ß", "Tab": "\t", "target": "⌖", "Tau": "Τ", "tau": "τ", "tbrk": "⎴", "Tcaron": "Ť", "tcaron": "ť", "Tcedil": "Ţ", "tcedil": "ţ", "Tcy": "Т", "tcy": "т", "tdot": "⃛", "telrec": "⌕", "Tfr": "𝔗", "tfr": "𝔱", "there4": "∴", "therefore": "∴", "Therefore": "∴", "Theta": "Θ", "theta": "θ", "thetasym": "ϑ", "thetav": "ϑ", "thickapprox": "≈", "thicksim": "∼", "ThickSpace": "  ", "ThinSpace": " ", "thinsp": " ", "thkap": "≈", "thksim": "∼", "THORN": "Þ", "thorn": "þ", "tilde": "˜", "Tilde": "∼", "TildeEqual": "≃", "TildeFullEqual": "≅", "TildeTilde": "≈", "timesbar": "⨱", "timesb": "⊠", "times": "×", "timesd": "⨰", "tint": "∭", "toea": "⤨", "topbot": "⌶", "topcir": "⫱", "top": "⊤", "Topf": "𝕋", "topf": "𝕥", "topfork": "⫚", "tosa": "⤩", "tprime": "‴", "trade": "™", "TRADE": "™", "triangle": "▵", "triangledown": "▿", "triangleleft": "◃", "trianglelefteq": "⊴", "triangleq": "≜", "triangleright": "▹", "trianglerighteq": "⊵", "tridot": "◬", "trie": "≜", "triminus": "⨺", "TripleDot": "⃛", "triplus": "⨹", "trisb": "⧍", "tritime": "⨻", "trpezium": "⏢", "Tscr": "𝒯", "tscr": "𝓉", "TScy": "Ц", "tscy": "ц", "TSHcy": "Ћ", "tshcy": "ћ", "Tstrok": "Ŧ", "tstrok": "ŧ", "twixt": "≬", "twoheadleftarrow": "↞", "twoheadrightarrow": "↠", "Uacute": "Ú", "uacute": "ú", "uarr": "↑", "Uarr": "↟", "uArr": "⇑", "Uarrocir": "⥉", "Ubrcy": "Ў", "ubrcy": "ў", "Ubreve": "Ŭ", "ubreve": "ŭ", "Ucirc": "Û", "ucirc": "û", "Ucy": "У", "ucy": "у", "udarr": "⇅", "Udblac": "Ű", "udblac": "ű", "udhar": "⥮", "ufisht": "⥾", "Ufr": "𝔘", "ufr": "𝔲", "Ugrave": "Ù", "ugrave": "ù", "uHar": "⥣", "uharl": "↿", "uharr": "↾", "uhblk": "▀", "ulcorn": "⌜", "ulcorner": "⌜", "ulcrop": "⌏", "ultri": "◸", "Umacr": "Ū", "umacr": "ū", "uml": "¨", "UnderBar": "_", "UnderBrace": "⏟", "UnderBracket": "⎵", "UnderParenthesis": "⏝", "Union": "⋃", "UnionPlus": "⊎", "Uogon": "Ų", "uogon": "ų", "Uopf": "𝕌", "uopf": "𝕦", "UpArrowBar": "⤒", "uparrow": "↑", "UpArrow": "↑", "Uparrow": "⇑", "UpArrowDownArrow": "⇅", "updownarrow": "↕", "UpDownArrow": "↕", "Updownarrow": "⇕", "UpEquilibrium": "⥮", "upharpoonleft": "↿", "upharpoonright": "↾", "uplus": "⊎", "UpperLeftArrow": "↖", "UpperRightArrow": "↗", "upsi": "υ", "Upsi": "ϒ", "upsih": "ϒ", "Upsilon": "Υ", "upsilon": "υ", "UpTeeArrow": "↥", "UpTee": "⊥", "upuparrows": "⇈", "urcorn": "⌝", "urcorner": "⌝", "urcrop": "⌎", "Uring": "Ů", "uring": "ů", "urtri": "◹", "Uscr": "𝒰", "uscr": "𝓊", "utdot": "⋰", "Utilde": "Ũ", "utilde": "ũ", "utri": "▵", "utrif": "▴", "uuarr": "⇈", "Uuml": "Ü", "uuml": "ü", "uwangle": "⦧", "vangrt": "⦜", "varepsilon": "ϵ", "varkappa": "ϰ", "varnothing": "∅", "varphi": "ϕ", "varpi": "ϖ", "varpropto": "∝", "varr": "↕", "vArr": "⇕", "varrho": "ϱ", "varsigma": "ς", "varsubsetneq": "⊊︀", "varsubsetneqq": "⫋︀", "varsupsetneq": "⊋︀", "varsupsetneqq": "⫌︀", "vartheta": "ϑ", "vartriangleleft": "⊲", "vartriangleright": "⊳", "vBar": "⫨", "Vbar": "⫫", "vBarv": "⫩", "Vcy": "В", "vcy": "в", "vdash": "⊢", "vDash": "⊨", "Vdash": "⊩", "VDash": "⊫", "Vdashl": "⫦", "veebar": "⊻", "vee": "∨", "Vee": "⋁", "veeeq": "≚", "vellip": "⋮", "verbar": "|", "Verbar": "‖", "vert": "|", "Vert": "‖", "VerticalBar": "∣", "VerticalLine": "|", "VerticalSeparator": "❘", "VerticalTilde": "≀", "VeryThinSpace": " ", "Vfr": "𝔙", "vfr": "𝔳", "vltri": "⊲", "vnsub": "⊂⃒", "vnsup": "⊃⃒", "Vopf": "𝕍", "vopf": "𝕧", "vprop": "∝", "vrtri": "⊳", "Vscr": "𝒱", "vscr": "𝓋", "vsubnE": "⫋︀", "vsubne": "⊊︀", "vsupnE": "⫌︀", "vsupne": "⊋︀", "Vvdash": "⊪", "vzigzag": "⦚", "Wcirc": "Ŵ", "wcirc": "ŵ", "wedbar": "⩟", "wedge": "∧", "Wedge": "⋀", "wedgeq": "≙", "weierp": "℘", "Wfr": "𝔚", "wfr": "𝔴", "Wopf": "𝕎", "wopf": "𝕨", "wp": "℘", "wr": "≀", "wreath": "≀", "Wscr": "𝒲", "wscr": "𝓌", "xcap": "⋂", "xcirc": "◯", "xcup": "⋃", "xdtri": "▽", "Xfr": "𝔛", "xfr": "𝔵", "xharr": "⟷", "xhArr": "⟺", "Xi": "Ξ", "xi": "ξ", "xlarr": "⟵", "xlArr": "⟸", "xmap": "⟼", "xnis": "⋻", "xodot": "⨀", "Xopf": "𝕏", "xopf": "𝕩", "xoplus": "⨁", "xotime": "⨂", "xrarr": "⟶", "xrArr": "⟹", "Xscr": "𝒳", "xscr": "𝓍", "xsqcup": "⨆", "xuplus": "⨄", "xutri": "△", "xvee": "⋁", "xwedge": "⋀", "Yacute": "Ý", "yacute": "ý", "YAcy": "Я", "yacy": "я", "Ycirc": "Ŷ", "ycirc": "ŷ", "Ycy": "Ы", "ycy": "ы", "yen": "¥", "Yfr": "𝔜", "yfr": "𝔶", "YIcy": "Ї", "yicy": "ї", "Yopf": "𝕐", "yopf": "𝕪", "Yscr": "𝒴", "yscr": "𝓎", "YUcy": "Ю", "yucy": "ю", "yuml": "ÿ", "Yuml": "Ÿ", "Zacute": "Ź", "zacute": "ź", "Zcaron": "Ž", "zcaron": "ž", "Zcy": "З", "zcy": "з", "Zdot": "Ż", "zdot": "ż", "zeetrf": "ℨ", "ZeroWidthSpace": "​", "Zeta": "Ζ", "zeta": "ζ", "zfr": "𝔷", "Zfr": "ℨ", "ZHcy": "Ж", "zhcy": "ж", "zigrarr": "⇝", "zopf": "𝕫", "Zopf": "ℤ", "Zscr": "𝒵", "zscr": "𝓏", "zwj": "‍", "zwnj": "‌" } }), (function (module, exports) { module.exports = { "amp": "&", "apos": "'", "gt": ">", "lt": "<", "quot": "\"" } }), (function (module, exports, __webpack_require__) { exports = module.exports = __webpack_require__(233); exports.Stream = exports; exports.Readable = exports; exports.Writable = __webpack_require__(124); exports.Duplex = __webpack_require__(33); exports.Transform = __webpack_require__(237); exports.PassThrough = __webpack_require__(499); }), (function (module, exports, __webpack_require__) {
        "use strict"; (function (global) {/*!
* The buffer module from node.js, for the browser.
*
* @author Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
* @license MIT
*/var base64 = __webpack_require__(492)
            var ieee754 = __webpack_require__(493)
            var isArray = __webpack_require__(234)
            exports.Buffer = Buffer
            exports.SlowBuffer = SlowBuffer
            exports.INSPECT_MAX_BYTES = 50
            Buffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined ? global.TYPED_ARRAY_SUPPORT : typedArraySupport()
            exports.kMaxLength = kMaxLength()
            function typedArraySupport() {
                try {
                    var arr = new Uint8Array(1)
                    arr.__proto__ = { __proto__: Uint8Array.prototype, foo: function () { return 42 } }
                    return arr.foo() === 42 && typeof arr.subarray === 'function' && arr.subarray(1, 1).byteLength === 0
                } catch (e) { return false }
            }
            function kMaxLength() { return Buffer.TYPED_ARRAY_SUPPORT ? 0x7fffffff : 0x3fffffff }
            function createBuffer(that, length) {
                if (kMaxLength() < length) { throw new RangeError('Invalid typed array length') }
                if (Buffer.TYPED_ARRAY_SUPPORT) {
                    that = new Uint8Array(length)
                    that.__proto__ = Buffer.prototype
                } else {
                    if (that === null) { that = new Buffer(length) }
                    that.length = length
                }
                return that
            }
            function Buffer(arg, encodingOrOffset, length) {
                if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) { return new Buffer(arg, encodingOrOffset, length) }
                if (typeof arg === 'number') {
                    if (typeof encodingOrOffset === 'string') { throw new Error('If encoding is specified then the first argument must be a string') }
                    return allocUnsafe(this, arg)
                }
                return from(this, arg, encodingOrOffset, length)
            }
            Buffer.poolSize = 8192
            Buffer._augment = function (arr) {
                arr.__proto__ = Buffer.prototype
                return arr
            }
            function from(that, value, encodingOrOffset, length) {
                if (typeof value === 'number') { throw new TypeError('"value" argument must not be a number') }
                if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) { return fromArrayBuffer(that, value, encodingOrOffset, length) }
                if (typeof value === 'string') { return fromString(that, value, encodingOrOffset) }
                return fromObject(that, value)
            }
            Buffer.from = function (value, encodingOrOffset, length) { return from(null, value, encodingOrOffset, length) }
            if (Buffer.TYPED_ARRAY_SUPPORT) {
                Buffer.prototype.__proto__ = Uint8Array.prototype
                Buffer.__proto__ = Uint8Array
                if (typeof Symbol !== 'undefined' && Symbol.species && Buffer[Symbol.species] === Buffer) { Object.defineProperty(Buffer, Symbol.species, { value: null, configurable: true }) }
            }
            function assertSize(size) { if (typeof size !== 'number') { throw new TypeError('"size" argument must be a number') } else if (size < 0) { throw new RangeError('"size" argument must not be negative') } }
            function alloc(that, size, fill, encoding) {
                assertSize(size)
                if (size <= 0) { return createBuffer(that, size) }
                if (fill !== undefined) { return typeof encoding === 'string' ? createBuffer(that, size).fill(fill, encoding) : createBuffer(that, size).fill(fill) }
                return createBuffer(that, size)
            }
            Buffer.alloc = function (size, fill, encoding) { return alloc(null, size, fill, encoding) }
            function allocUnsafe(that, size) {
                assertSize(size)
                that = createBuffer(that, size < 0 ? 0 : checked(size) | 0)
                if (!Buffer.TYPED_ARRAY_SUPPORT) { for (var i = 0; i < size; ++i) { that[i] = 0 } }
                return that
            }
            Buffer.allocUnsafe = function (size) { return allocUnsafe(null, size) }
            Buffer.allocUnsafeSlow = function (size) { return allocUnsafe(null, size) }
            function fromString(that, string, encoding) {
                if (typeof encoding !== 'string' || encoding === '') { encoding = 'utf8' }
                if (!Buffer.isEncoding(encoding)) { throw new TypeError('"encoding" must be a valid string encoding') }
                var length = byteLength(string, encoding) | 0
                that = createBuffer(that, length)
                var actual = that.write(string, encoding)
                if (actual !== length) { that = that.slice(0, actual) }
                return that
            }
            function fromArrayLike(that, array) {
                var length = array.length < 0 ? 0 : checked(array.length) | 0
                that = createBuffer(that, length)
                for (var i = 0; i < length; i += 1) { that[i] = array[i] & 255 }
                return that
            }
            function fromArrayBuffer(that, array, byteOffset, length) {
                array.byteLength
                if (byteOffset < 0 || array.byteLength < byteOffset) { throw new RangeError('\'offset\' is out of bounds') }
                if (array.byteLength < byteOffset + (length || 0)) { throw new RangeError('\'length\' is out of bounds') }
                if (byteOffset === undefined && length === undefined) { array = new Uint8Array(array) } else if (length === undefined) { array = new Uint8Array(array, byteOffset) } else { array = new Uint8Array(array, byteOffset, length) }
                if (Buffer.TYPED_ARRAY_SUPPORT) {
                    that = array
                    that.__proto__ = Buffer.prototype
                } else { that = fromArrayLike(that, array) }
                return that
            }
            function fromObject(that, obj) {
                if (Buffer.isBuffer(obj)) {
                    var len = checked(obj.length) | 0
                    that = createBuffer(that, len)
                    if (that.length === 0) { return that }
                    obj.copy(that, 0, 0, len)
                    return that
                }
                if (obj) {
                    if ((typeof ArrayBuffer !== 'undefined' && obj.buffer instanceof ArrayBuffer) || 'length' in obj) {
                        if (typeof obj.length !== 'number' || isnan(obj.length)) { return createBuffer(that, 0) }
                        return fromArrayLike(that, obj)
                    }
                    if (obj.type === 'Buffer' && isArray(obj.data)) { return fromArrayLike(that, obj.data) }
                }
                throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')
            }
            function checked(length) {
                if (length >= kMaxLength()) {
                    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                        'size: 0x' + kMaxLength().toString(16) + ' bytes')
                }
                return length | 0
            }
            function SlowBuffer(length) {
                if (+length != length) { length = 0 }
                return Buffer.alloc(+length)
            }
            Buffer.isBuffer = function isBuffer(b) { return !!(b != null && b._isBuffer) }
            Buffer.compare = function compare(a, b) {
                if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) { throw new TypeError('Arguments must be Buffers') }
                if (a === b) return 0
                var x = a.length
                var y = b.length
                for (var i = 0, len = Math.min(x, y); i < len; ++i) {
                    if (a[i] !== b[i]) {
                        x = a[i]
                        y = b[i]
                        break
                    }
                }
                if (x < y) return -1
                if (y < x) return 1
                return 0
            }
            Buffer.isEncoding = function isEncoding(encoding) {
                switch (String(encoding).toLowerCase()) {
                    case 'hex': case 'utf8': case 'utf-8': case 'ascii': case 'latin1': case 'binary': case 'base64': case 'ucs2': case 'ucs-2': case 'utf16le': case 'utf-16le': return true
                    default: return false
                }
            }
            Buffer.concat = function concat(list, length) {
                if (!isArray(list)) { throw new TypeError('"list" argument must be an Array of Buffers') }
                if (list.length === 0) { return Buffer.alloc(0) }
                var i
                if (length === undefined) {
                    length = 0
                    for (i = 0; i < list.length; ++i) { length += list[i].length }
                }
                var buffer = Buffer.allocUnsafe(length)
                var pos = 0
                for (i = 0; i < list.length; ++i) {
                    var buf = list[i]
                    if (!Buffer.isBuffer(buf)) { throw new TypeError('"list" argument must be an Array of Buffers') }
                    buf.copy(buffer, pos)
                    pos += buf.length
                }
                return buffer
            }
            function byteLength(string, encoding) {
                if (Buffer.isBuffer(string)) { return string.length }
                if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' && (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) { return string.byteLength }
                if (typeof string !== 'string') { string = '' + string }
                var len = string.length
                if (len === 0) return 0
                var loweredCase = false
                for (; ;) {
                    switch (encoding) {
                        case 'ascii': case 'latin1': case 'binary': return len
                        case 'utf8': case 'utf-8': case undefined: return utf8ToBytes(string).length
                        case 'ucs2': case 'ucs-2': case 'utf16le': case 'utf-16le': return len * 2
                        case 'hex': return len >>> 1
                        case 'base64': return base64ToBytes(string).length
                        default: if (loweredCase) return utf8ToBytes(string).length
                            encoding = ('' + encoding).toLowerCase()
                            loweredCase = true
                    }
                }
            }
            Buffer.byteLength = byteLength
            function slowToString(encoding, start, end) {
                var loweredCase = false
                if (start === undefined || start < 0) { start = 0 }
                if (start > this.length) { return '' }
                if (end === undefined || end > this.length) { end = this.length }
                if (end <= 0) { return '' }
                end >>>= 0
                start >>>= 0
                if (end <= start) { return '' }
                if (!encoding) encoding = 'utf8'
                while (true) {
                    switch (encoding) {
                        case 'hex': return hexSlice(this, start, end)
                        case 'utf8': case 'utf-8': return utf8Slice(this, start, end)
                        case 'ascii': return asciiSlice(this, start, end)
                        case 'latin1': case 'binary': return latin1Slice(this, start, end)
                        case 'base64': return base64Slice(this, start, end)
                        case 'ucs2': case 'ucs-2': case 'utf16le': case 'utf-16le': return utf16leSlice(this, start, end)
                        default: if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
                            encoding = (encoding + '').toLowerCase()
                            loweredCase = true
                    }
                }
            }
            Buffer.prototype._isBuffer = true
            function swap(b, n, m) {
                var i = b[n]
                b[n] = b[m]
                b[m] = i
            }
            Buffer.prototype.swap16 = function swap16() {
                var len = this.length
                if (len % 2 !== 0) { throw new RangeError('Buffer size must be a multiple of 16-bits') }
                for (var i = 0; i < len; i += 2) { swap(this, i, i + 1) }
                return this
            }
            Buffer.prototype.swap32 = function swap32() {
                var len = this.length
                if (len % 4 !== 0) { throw new RangeError('Buffer size must be a multiple of 32-bits') }
                for (var i = 0; i < len; i += 4) {
                    swap(this, i, i + 3)
                    swap(this, i + 1, i + 2)
                }
                return this
            }
            Buffer.prototype.swap64 = function swap64() {
                var len = this.length
                if (len % 8 !== 0) { throw new RangeError('Buffer size must be a multiple of 64-bits') }
                for (var i = 0; i < len; i += 8) {
                    swap(this, i, i + 7)
                    swap(this, i + 1, i + 6)
                    swap(this, i + 2, i + 5)
                    swap(this, i + 3, i + 4)
                }
                return this
            }
            Buffer.prototype.toString = function toString() {
                var length = this.length | 0
                if (length === 0) return ''
                if (arguments.length === 0) return utf8Slice(this, 0, length)
                return slowToString.apply(this, arguments)
            }
            Buffer.prototype.equals = function equals(b) {
                if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
                if (this === b) return true
                return Buffer.compare(this, b) === 0
            }
            Buffer.prototype.inspect = function inspect() {
                var str = ''
                var max = exports.INSPECT_MAX_BYTES
                if (this.length > 0) {
                    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')
                    if (this.length > max) str += ' ... '
                }
                return '<Buffer ' + str + '>'
            }
            Buffer.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
                if (!Buffer.isBuffer(target)) { throw new TypeError('Argument must be a Buffer') }
                if (start === undefined) { start = 0 }
                if (end === undefined) { end = target ? target.length : 0 }
                if (thisStart === undefined) { thisStart = 0 }
                if (thisEnd === undefined) { thisEnd = this.length }
                if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) { throw new RangeError('out of range index') }
                if (thisStart >= thisEnd && start >= end) { return 0 }
                if (thisStart >= thisEnd) { return -1 }
                if (start >= end) { return 1 }
                start >>>= 0
                end >>>= 0
                thisStart >>>= 0
                thisEnd >>>= 0
                if (this === target) return 0
                var x = thisEnd - thisStart
                var y = end - start
                var len = Math.min(x, y)
                var thisCopy = this.slice(thisStart, thisEnd)
                var targetCopy = target.slice(start, end)
                for (var i = 0; i < len; ++i) {
                    if (thisCopy[i] !== targetCopy[i]) {
                        x = thisCopy[i]
                        y = targetCopy[i]
                        break
                    }
                }
                if (x < y) return -1
                if (y < x) return 1
                return 0
            }
            function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
                if (buffer.length === 0) return -1
                if (typeof byteOffset === 'string') {
                    encoding = byteOffset
                    byteOffset = 0
                } else if (byteOffset > 0x7fffffff) { byteOffset = 0x7fffffff } else if (byteOffset < -0x80000000) { byteOffset = -0x80000000 }
                byteOffset = +byteOffset
                if (isNaN(byteOffset)) { byteOffset = dir ? 0 : (buffer.length - 1) }
                if (byteOffset < 0) byteOffset = buffer.length + byteOffset
                if (byteOffset >= buffer.length) {
                    if (dir) return -1
                    else byteOffset = buffer.length - 1
                } else if (byteOffset < 0) {
                    if (dir) byteOffset = 0
                    else return -1
                }
                if (typeof val === 'string') { val = Buffer.from(val, encoding) }
                if (Buffer.isBuffer(val)) {
                    if (val.length === 0) { return -1 }
                    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
                } else if (typeof val === 'number') {
                    val = val & 0xFF
                    if (Buffer.TYPED_ARRAY_SUPPORT && typeof Uint8Array.prototype.indexOf === 'function') { if (dir) { return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset) } else { return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset) } }
                    return arrayIndexOf(buffer, [val], byteOffset, encoding, dir)
                }
                throw new TypeError('val must be string, number or Buffer')
            }
            function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
                var indexSize = 1
                var arrLength = arr.length
                var valLength = val.length
                if (encoding !== undefined) {
                    encoding = String(encoding).toLowerCase()
                    if (encoding === 'ucs2' || encoding === 'ucs-2' || encoding === 'utf16le' || encoding === 'utf-16le') {
                        if (arr.length < 2 || val.length < 2) { return -1 }
                        indexSize = 2
                        arrLength /= 2
                        valLength /= 2
                        byteOffset /= 2
                    }
                }
                function read(buf, i) { if (indexSize === 1) { return buf[i] } else { return buf.readUInt16BE(i * indexSize) } }
                var i
                if (dir) {
                    var foundIndex = -1
                    for (i = byteOffset; i < arrLength; i++) {
                        if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
                            if (foundIndex === -1) foundIndex = i
                            if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
                        } else {
                            if (foundIndex !== -1) i -= i - foundIndex
                            foundIndex = -1
                        }
                    }
                } else {
                    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
                    for (i = byteOffset; i >= 0; i--) {
                        var found = true
                        for (var j = 0; j < valLength; j++) {
                            if (read(arr, i + j) !== read(val, j)) {
                                found = false
                                break
                            }
                        }
                        if (found) return i
                    }
                }
                return -1
            }
            Buffer.prototype.includes = function includes(val, byteOffset, encoding) { return this.indexOf(val, byteOffset, encoding) !== -1 }
            Buffer.prototype.indexOf = function indexOf(val, byteOffset, encoding) { return bidirectionalIndexOf(this, val, byteOffset, encoding, true) }
            Buffer.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) { return bidirectionalIndexOf(this, val, byteOffset, encoding, false) }
            function hexWrite(buf, string, offset, length) {
                offset = Number(offset) || 0
                var remaining = buf.length - offset
                if (!length) { length = remaining } else {
                    length = Number(length)
                    if (length > remaining) { length = remaining }
                }
                var strLen = string.length
                if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')
                if (length > strLen / 2) { length = strLen / 2 }
                for (var i = 0; i < length; ++i) {
                    var parsed = parseInt(string.substr(i * 2, 2), 16)
                    if (isNaN(parsed)) return i
                    buf[offset + i] = parsed
                }
                return i
            }
            function utf8Write(buf, string, offset, length) { return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length) }
            function asciiWrite(buf, string, offset, length) { return blitBuffer(asciiToBytes(string), buf, offset, length) }
            function latin1Write(buf, string, offset, length) { return asciiWrite(buf, string, offset, length) }
            function base64Write(buf, string, offset, length) { return blitBuffer(base64ToBytes(string), buf, offset, length) }
            function ucs2Write(buf, string, offset, length) { return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length) }
            Buffer.prototype.write = function write(string, offset, length, encoding) {
                if (offset === undefined) {
                    encoding = 'utf8'
                    length = this.length
                    offset = 0
                } else if (length === undefined && typeof offset === 'string') {
                    encoding = offset
                    length = this.length
                    offset = 0
                } else if (isFinite(offset)) {
                    offset = offset | 0
                    if (isFinite(length)) {
                        length = length | 0
                        if (encoding === undefined) encoding = 'utf8'
                    } else {
                        encoding = length
                        length = undefined
                    }
                } else { throw new Error('Buffer.write(string, encoding, offset[, length]) is no longer supported') }
                var remaining = this.length - offset
                if (length === undefined || length > remaining) length = remaining
                if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) { throw new RangeError('Attempt to write outside buffer bounds') }
                if (!encoding) encoding = 'utf8'
                var loweredCase = false
                for (; ;) {
                    switch (encoding) {
                        case 'hex': return hexWrite(this, string, offset, length)
                        case 'utf8': case 'utf-8': return utf8Write(this, string, offset, length)
                        case 'ascii': return asciiWrite(this, string, offset, length)
                        case 'latin1': case 'binary': return latin1Write(this, string, offset, length)
                        case 'base64': return base64Write(this, string, offset, length)
                        case 'ucs2': case 'ucs-2': case 'utf16le': case 'utf-16le': return ucs2Write(this, string, offset, length)
                        default: if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
                            encoding = ('' + encoding).toLowerCase()
                            loweredCase = true
                    }
                }
            }
            Buffer.prototype.toJSON = function toJSON() { return { type: 'Buffer', data: Array.prototype.slice.call(this._arr || this, 0) } }
            function base64Slice(buf, start, end) { if (start === 0 && end === buf.length) { return base64.fromByteArray(buf) } else { return base64.fromByteArray(buf.slice(start, end)) } }
            function utf8Slice(buf, start, end) {
                end = Math.min(buf.length, end)
                var res = []
                var i = start
                while (i < end) {
                    var firstByte = buf[i]
                    var codePoint = null
                    var bytesPerSequence = (firstByte > 0xEF) ? 4 : (firstByte > 0xDF) ? 3 : (firstByte > 0xBF) ? 2 : 1
                    if (i + bytesPerSequence <= end) {
                        var secondByte, thirdByte, fourthByte, tempCodePoint
                        switch (bytesPerSequence) {
                            case 1: if (firstByte < 0x80) { codePoint = firstByte }
                                break
                            case 2: secondByte = buf[i + 1]
                                if ((secondByte & 0xC0) === 0x80) {
                                    tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
                                    if (tempCodePoint > 0x7F) { codePoint = tempCodePoint }
                                }
                                break
                            case 3: secondByte = buf[i + 1]
                                thirdByte = buf[i + 2]
                                if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
                                    tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
                                    if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) { codePoint = tempCodePoint }
                                }
                                break
                            case 4: secondByte = buf[i + 1]
                                thirdByte = buf[i + 2]
                                fourthByte = buf[i + 3]
                                if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
                                    tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
                                    if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) { codePoint = tempCodePoint }
                                }
                        }
                    }
                    if (codePoint === null) {
                        codePoint = 0xFFFD
                        bytesPerSequence = 1
                    } else if (codePoint > 0xFFFF) {
                        codePoint -= 0x10000
                        res.push(codePoint >>> 10 & 0x3FF | 0xD800)
                        codePoint = 0xDC00 | codePoint & 0x3FF
                    }
                    res.push(codePoint)
                    i += bytesPerSequence
                }
                return decodeCodePointsArray(res)
            }
            var MAX_ARGUMENTS_LENGTH = 0x1000
            function decodeCodePointsArray(codePoints) {
                var len = codePoints.length
                if (len <= MAX_ARGUMENTS_LENGTH) { return String.fromCharCode.apply(String, codePoints) }
                var res = ''
                var i = 0
                while (i < len) { res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)) }
                return res
            }
            function asciiSlice(buf, start, end) {
                var ret = ''
                end = Math.min(buf.length, end)
                for (var i = start; i < end; ++i) { ret += String.fromCharCode(buf[i] & 0x7F) }
                return ret
            }
            function latin1Slice(buf, start, end) {
                var ret = ''
                end = Math.min(buf.length, end)
                for (var i = start; i < end; ++i) { ret += String.fromCharCode(buf[i]) }
                return ret
            }
            function hexSlice(buf, start, end) {
                var len = buf.length
                if (!start || start < 0) start = 0
                if (!end || end < 0 || end > len) end = len
                var out = ''
                for (var i = start; i < end; ++i) { out += toHex(buf[i]) }
                return out
            }
            function utf16leSlice(buf, start, end) {
                var bytes = buf.slice(start, end)
                var res = ''
                for (var i = 0; i < bytes.length; i += 2) { res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256) }
                return res
            }
            Buffer.prototype.slice = function slice(start, end) {
                var len = this.length
                start = ~~start
                end = end === undefined ? len : ~~end
                if (start < 0) {
                    start += len
                    if (start < 0) start = 0
                } else if (start > len) { start = len }
                if (end < 0) {
                    end += len
                    if (end < 0) end = 0
                } else if (end > len) { end = len }
                if (end < start) end = start
                var newBuf
                if (Buffer.TYPED_ARRAY_SUPPORT) {
                    newBuf = this.subarray(start, end)
                    newBuf.__proto__ = Buffer.prototype
                } else {
                    var sliceLen = end - start
                    newBuf = new Buffer(sliceLen, undefined)
                    for (var i = 0; i < sliceLen; ++i) { newBuf[i] = this[i + start] }
                }
                return newBuf
            }
            function checkOffset(offset, ext, length) {
                if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
                if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
            }
            Buffer.prototype.readUIntLE = function readUIntLE(offset, byteLength, noAssert) {
                offset = offset | 0
                byteLength = byteLength | 0
                if (!noAssert) checkOffset(offset, byteLength, this.length)
                var val = this[offset]
                var mul = 1
                var i = 0
                while (++i < byteLength && (mul *= 0x100)) { val += this[offset + i] * mul }
                return val
            }
            Buffer.prototype.readUIntBE = function readUIntBE(offset, byteLength, noAssert) {
                offset = offset | 0
                byteLength = byteLength | 0
                if (!noAssert) { checkOffset(offset, byteLength, this.length) }
                var val = this[offset + --byteLength]
                var mul = 1
                while (byteLength > 0 && (mul *= 0x100)) { val += this[offset + --byteLength] * mul }
                return val
            }
            Buffer.prototype.readUInt8 = function readUInt8(offset, noAssert) {
                if (!noAssert) checkOffset(offset, 1, this.length)
                return this[offset]
            }
            Buffer.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
                if (!noAssert) checkOffset(offset, 2, this.length)
                return this[offset] | (this[offset + 1] << 8)
            }
            Buffer.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
                if (!noAssert) checkOffset(offset, 2, this.length)
                return (this[offset] << 8) | this[offset + 1]
            }
            Buffer.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
                if (!noAssert) checkOffset(offset, 4, this.length)
                return ((this[offset]) | (this[offset + 1] << 8) | (this[offset + 2] << 16)) +
                    (this[offset + 3] * 0x1000000)
            }
            Buffer.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
                if (!noAssert) checkOffset(offset, 4, this.length)
                return (this[offset] * 0x1000000) +
                    ((this[offset + 1] << 16) | (this[offset + 2] << 8) | this[offset + 3])
            }
            Buffer.prototype.readIntLE = function readIntLE(offset, byteLength, noAssert) {
                offset = offset | 0
                byteLength = byteLength | 0
                if (!noAssert) checkOffset(offset, byteLength, this.length)
                var val = this[offset]
                var mul = 1
                var i = 0
                while (++i < byteLength && (mul *= 0x100)) { val += this[offset + i] * mul }
                mul *= 0x80
                if (val >= mul) val -= Math.pow(2, 8 * byteLength)
                return val
            }
            Buffer.prototype.readIntBE = function readIntBE(offset, byteLength, noAssert) {
                offset = offset | 0
                byteLength = byteLength | 0
                if (!noAssert) checkOffset(offset, byteLength, this.length)
                var i = byteLength
                var mul = 1
                var val = this[offset + --i]
                while (i > 0 && (mul *= 0x100)) { val += this[offset + --i] * mul }
                mul *= 0x80
                if (val >= mul) val -= Math.pow(2, 8 * byteLength)
                return val
            }
            Buffer.prototype.readInt8 = function readInt8(offset, noAssert) {
                if (!noAssert) checkOffset(offset, 1, this.length)
                if (!(this[offset] & 0x80)) return (this[offset])
                return ((0xff - this[offset] + 1) * -1)
            }
            Buffer.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
                if (!noAssert) checkOffset(offset, 2, this.length)
                var val = this[offset] | (this[offset + 1] << 8)
                return (val & 0x8000) ? val | 0xFFFF0000 : val
            }
            Buffer.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
                if (!noAssert) checkOffset(offset, 2, this.length)
                var val = this[offset + 1] | (this[offset] << 8)
                return (val & 0x8000) ? val | 0xFFFF0000 : val
            }
            Buffer.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
                if (!noAssert) checkOffset(offset, 4, this.length)
                return (this[offset]) | (this[offset + 1] << 8) | (this[offset + 2] << 16) | (this[offset + 3] << 24)
            }
            Buffer.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
                if (!noAssert) checkOffset(offset, 4, this.length)
                return (this[offset] << 24) | (this[offset + 1] << 16) | (this[offset + 2] << 8) | (this[offset + 3])
            }
            Buffer.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
                if (!noAssert) checkOffset(offset, 4, this.length)
                return ieee754.read(this, offset, true, 23, 4)
            }
            Buffer.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
                if (!noAssert) checkOffset(offset, 4, this.length)
                return ieee754.read(this, offset, false, 23, 4)
            }
            Buffer.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
                if (!noAssert) checkOffset(offset, 8, this.length)
                return ieee754.read(this, offset, true, 52, 8)
            }
            Buffer.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
                if (!noAssert) checkOffset(offset, 8, this.length)
                return ieee754.read(this, offset, false, 52, 8)
            }
            function checkInt(buf, value, offset, ext, max, min) {
                if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
                if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
                if (offset + ext > buf.length) throw new RangeError('Index out of range')
            }
            Buffer.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength, noAssert) {
                value = +value
                offset = offset | 0
                byteLength = byteLength | 0
                if (!noAssert) {
                    var maxBytes = Math.pow(2, 8 * byteLength) - 1
                    checkInt(this, value, offset, byteLength, maxBytes, 0)
                }
                var mul = 1
                var i = 0
                this[offset] = value & 0xFF
                while (++i < byteLength && (mul *= 0x100)) { this[offset + i] = (value / mul) & 0xFF }
                return offset + byteLength
            }
            Buffer.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength, noAssert) {
                value = +value
                offset = offset | 0
                byteLength = byteLength | 0
                if (!noAssert) {
                    var maxBytes = Math.pow(2, 8 * byteLength) - 1
                    checkInt(this, value, offset, byteLength, maxBytes, 0)
                }
                var i = byteLength - 1
                var mul = 1
                this[offset + i] = value & 0xFF
                while (--i >= 0 && (mul *= 0x100)) { this[offset + i] = (value / mul) & 0xFF }
                return offset + byteLength
            }
            Buffer.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
                value = +value
                offset = offset | 0
                if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
                if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
                this[offset] = (value & 0xff)
                return offset + 1
            }
            function objectWriteUInt16(buf, value, offset, littleEndian) {
                if (value < 0) value = 0xffff + value + 1
                for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) { buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>> (littleEndian ? i : 1 - i) * 8 }
            }
            Buffer.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
                value = +value
                offset = offset | 0
                if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
                if (Buffer.TYPED_ARRAY_SUPPORT) {
                    this[offset] = (value & 0xff)
                    this[offset + 1] = (value >>> 8)
                } else { objectWriteUInt16(this, value, offset, true) }
                return offset + 2
            }
            Buffer.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
                value = +value
                offset = offset | 0
                if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
                if (Buffer.TYPED_ARRAY_SUPPORT) {
                    this[offset] = (value >>> 8)
                    this[offset + 1] = (value & 0xff)
                } else { objectWriteUInt16(this, value, offset, false) }
                return offset + 2
            }
            function objectWriteUInt32(buf, value, offset, littleEndian) {
                if (value < 0) value = 0xffffffff + value + 1
                for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) { buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff }
            }
            Buffer.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
                value = +value
                offset = offset | 0
                if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
                if (Buffer.TYPED_ARRAY_SUPPORT) {
                    this[offset + 3] = (value >>> 24)
                    this[offset + 2] = (value >>> 16)
                    this[offset + 1] = (value >>> 8)
                    this[offset] = (value & 0xff)
                } else { objectWriteUInt32(this, value, offset, true) }
                return offset + 4
            }
            Buffer.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
                value = +value
                offset = offset | 0
                if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
                if (Buffer.TYPED_ARRAY_SUPPORT) {
                    this[offset] = (value >>> 24)
                    this[offset + 1] = (value >>> 16)
                    this[offset + 2] = (value >>> 8)
                    this[offset + 3] = (value & 0xff)
                } else { objectWriteUInt32(this, value, offset, false) }
                return offset + 4
            }
            Buffer.prototype.writeIntLE = function writeIntLE(value, offset, byteLength, noAssert) {
                value = +value
                offset = offset | 0
                if (!noAssert) {
                    var limit = Math.pow(2, 8 * byteLength - 1)
                    checkInt(this, value, offset, byteLength, limit - 1, -limit)
                }
                var i = 0
                var mul = 1
                var sub = 0
                this[offset] = value & 0xFF
                while (++i < byteLength && (mul *= 0x100)) {
                    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) { sub = 1 }
                    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
                }
                return offset + byteLength
            }
            Buffer.prototype.writeIntBE = function writeIntBE(value, offset, byteLength, noAssert) {
                value = +value
                offset = offset | 0
                if (!noAssert) {
                    var limit = Math.pow(2, 8 * byteLength - 1)
                    checkInt(this, value, offset, byteLength, limit - 1, -limit)
                }
                var i = byteLength - 1
                var mul = 1
                var sub = 0
                this[offset + i] = value & 0xFF
                while (--i >= 0 && (mul *= 0x100)) {
                    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) { sub = 1 }
                    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
                }
                return offset + byteLength
            }
            Buffer.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
                value = +value
                offset = offset | 0
                if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
                if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
                if (value < 0) value = 0xff + value + 1
                this[offset] = (value & 0xff)
                return offset + 1
            }
            Buffer.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
                value = +value
                offset = offset | 0
                if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
                if (Buffer.TYPED_ARRAY_SUPPORT) {
                    this[offset] = (value & 0xff)
                    this[offset + 1] = (value >>> 8)
                } else { objectWriteUInt16(this, value, offset, true) }
                return offset + 2
            }
            Buffer.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
                value = +value
                offset = offset | 0
                if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
                if (Buffer.TYPED_ARRAY_SUPPORT) {
                    this[offset] = (value >>> 8)
                    this[offset + 1] = (value & 0xff)
                } else { objectWriteUInt16(this, value, offset, false) }
                return offset + 2
            }
            Buffer.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
                value = +value
                offset = offset | 0
                if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
                if (Buffer.TYPED_ARRAY_SUPPORT) {
                    this[offset] = (value & 0xff)
                    this[offset + 1] = (value >>> 8)
                    this[offset + 2] = (value >>> 16)
                    this[offset + 3] = (value >>> 24)
                } else { objectWriteUInt32(this, value, offset, true) }
                return offset + 4
            }
            Buffer.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
                value = +value
                offset = offset | 0
                if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
                if (value < 0) value = 0xffffffff + value + 1
                if (Buffer.TYPED_ARRAY_SUPPORT) {
                    this[offset] = (value >>> 24)
                    this[offset + 1] = (value >>> 16)
                    this[offset + 2] = (value >>> 8)
                    this[offset + 3] = (value & 0xff)
                } else { objectWriteUInt32(this, value, offset, false) }
                return offset + 4
            }
            function checkIEEE754(buf, value, offset, ext, max, min) {
                if (offset + ext > buf.length) throw new RangeError('Index out of range')
                if (offset < 0) throw new RangeError('Index out of range')
            }
            function writeFloat(buf, value, offset, littleEndian, noAssert) {
                if (!noAssert) { checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38) }
                ieee754.write(buf, value, offset, littleEndian, 23, 4)
                return offset + 4
            }
            Buffer.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) { return writeFloat(this, value, offset, true, noAssert) }
            Buffer.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) { return writeFloat(this, value, offset, false, noAssert) }
            function writeDouble(buf, value, offset, littleEndian, noAssert) {
                if (!noAssert) { checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308) }
                ieee754.write(buf, value, offset, littleEndian, 52, 8)
                return offset + 8
            }
            Buffer.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) { return writeDouble(this, value, offset, true, noAssert) }
            Buffer.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) { return writeDouble(this, value, offset, false, noAssert) }
            Buffer.prototype.copy = function copy(target, targetStart, start, end) {
                if (!start) start = 0
                if (!end && end !== 0) end = this.length
                if (targetStart >= target.length) targetStart = target.length
                if (!targetStart) targetStart = 0
                if (end > 0 && end < start) end = start
                if (end === start) return 0
                if (target.length === 0 || this.length === 0) return 0
                if (targetStart < 0) { throw new RangeError('targetStart out of bounds') }
                if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
                if (end < 0) throw new RangeError('sourceEnd out of bounds')
                if (end > this.length) end = this.length
                if (target.length - targetStart < end - start) { end = target.length - targetStart + start }
                var len = end - start
                var i
                if (this === target && start < targetStart && targetStart < end) { for (i = len - 1; i >= 0; --i) { target[i + targetStart] = this[i + start] } } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) { for (i = 0; i < len; ++i) { target[i + targetStart] = this[i + start] } } else { Uint8Array.prototype.set.call(target, this.subarray(start, start + len), targetStart) }
                return len
            }
            Buffer.prototype.fill = function fill(val, start, end, encoding) {
                if (typeof val === 'string') {
                    if (typeof start === 'string') {
                        encoding = start
                        start = 0
                        end = this.length
                    } else if (typeof end === 'string') {
                        encoding = end
                        end = this.length
                    }
                    if (val.length === 1) {
                        var code = val.charCodeAt(0)
                        if (code < 256) { val = code }
                    }
                    if (encoding !== undefined && typeof encoding !== 'string') { throw new TypeError('encoding must be a string') }
                    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) { throw new TypeError('Unknown encoding: ' + encoding) }
                } else if (typeof val === 'number') { val = val & 255 }
                if (start < 0 || this.length < start || this.length < end) { throw new RangeError('Out of range index') }
                if (end <= start) { return this }
                start = start >>> 0
                end = end === undefined ? this.length : end >>> 0
                if (!val) val = 0
                var i
                if (typeof val === 'number') { for (i = start; i < end; ++i) { this[i] = val } } else {
                    var bytes = Buffer.isBuffer(val) ? val : utf8ToBytes(new Buffer(val, encoding).toString())
                    var len = bytes.length
                    for (i = 0; i < end - start; ++i) { this[i + start] = bytes[i % len] }
                }
                return this
            }
            var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g
            function base64clean(str) {
                str = stringtrim(str).replace(INVALID_BASE64_RE, '')
                if (str.length < 2) return ''
                while (str.length % 4 !== 0) { str = str + '=' }
                return str
            }
            function stringtrim(str) {
                if (str.trim) return str.trim()
                return str.replace(/^\s+|\s+$/g, '')
            }
            function toHex(n) {
                if (n < 16) return '0' + n.toString(16)
                return n.toString(16)
            }
            function utf8ToBytes(string, units) {
                units = units || Infinity
                var codePoint
                var length = string.length
                var leadSurrogate = null
                var bytes = []
                for (var i = 0; i < length; ++i) {
                    codePoint = string.charCodeAt(i)
                    if (codePoint > 0xD7FF && codePoint < 0xE000) {
                        if (!leadSurrogate) {
                            if (codePoint > 0xDBFF) {
                                if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
                                continue
                            } else if (i + 1 === length) {
                                if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
                                continue
                            }
                            leadSurrogate = codePoint
                            continue
                        }
                        if (codePoint < 0xDC00) {
                            if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
                            leadSurrogate = codePoint
                            continue
                        }
                        codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
                    } else if (leadSurrogate) { if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD) }
                    leadSurrogate = null
                    if (codePoint < 0x80) {
                        if ((units -= 1) < 0) break
                        bytes.push(codePoint)
                    } else if (codePoint < 0x800) {
                        if ((units -= 2) < 0) break
                        bytes.push(codePoint >> 0x6 | 0xC0, codePoint & 0x3F | 0x80)
                    } else if (codePoint < 0x10000) {
                        if ((units -= 3) < 0) break
                        bytes.push(codePoint >> 0xC | 0xE0, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80)
                    } else if (codePoint < 0x110000) {
                        if ((units -= 4) < 0) break
                        bytes.push(codePoint >> 0x12 | 0xF0, codePoint >> 0xC & 0x3F | 0x80, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80)
                    } else { throw new Error('Invalid code point') }
                }
                return bytes
            }
            function asciiToBytes(str) {
                var byteArray = []
                for (var i = 0; i < str.length; ++i) { byteArray.push(str.charCodeAt(i) & 0xFF) }
                return byteArray
            }
            function utf16leToBytes(str, units) {
                var c, hi, lo
                var byteArray = []
                for (var i = 0; i < str.length; ++i) {
                    if ((units -= 2) < 0) break
                    c = str.charCodeAt(i)
                    hi = c >> 8
                    lo = c % 256
                    byteArray.push(lo)
                    byteArray.push(hi)
                }
                return byteArray
            }
            function base64ToBytes(str) { return base64.toByteArray(base64clean(str)) }
            function blitBuffer(src, dst, offset, length) {
                for (var i = 0; i < length; ++i) {
                    if ((i + offset >= dst.length) || (i >= src.length)) break
                    dst[i + offset] = src[i]
                }
                return i
            }
            function isnan(val) { return val !== val }
        }.call(exports, __webpack_require__(17)))
    }), (function (module, exports, __webpack_require__) {
        "use strict"; (function (process, setImmediate, global) {
            var processNextTick = __webpack_require__(77); module.exports = Writable; function WriteReq(chunk, encoding, cb) { this.chunk = chunk; this.encoding = encoding; this.callback = cb; this.next = null; }
            function CorkedRequest(state) { var _this = this; this.next = null; this.entry = null; this.finish = function () { onCorkedFinish(_this, state); }; }
            var asyncWrite = !process.browser && ['v0.10', 'v0.9.'].indexOf(process.version.slice(0, 5)) > -1 ? setImmediate : processNextTick; var Duplex; Writable.WritableState = WritableState; var util = __webpack_require__(56); util.inherits = __webpack_require__(16); var internalUtil = { deprecate: __webpack_require__(498) }; var Stream = __webpack_require__(235); var Buffer = __webpack_require__(78).Buffer; var OurUint8Array = global.Uint8Array || function () { }; function _uint8ArrayToBuffer(chunk) { return Buffer.from(chunk); }
            function _isUint8Array(obj) { return Buffer.isBuffer(obj) || obj instanceof OurUint8Array; }
            var destroyImpl = __webpack_require__(236); util.inherits(Writable, Stream); function nop() { }
            function WritableState(options, stream) { Duplex = Duplex || __webpack_require__(33); options = options || {}; this.objectMode = !!options.objectMode; if (stream instanceof Duplex) this.objectMode = this.objectMode || !!options.writableObjectMode; var hwm = options.highWaterMark; var defaultHwm = this.objectMode ? 16 : 16 * 1024; this.highWaterMark = hwm || hwm === 0 ? hwm : defaultHwm; this.highWaterMark = Math.floor(this.highWaterMark); this.finalCalled = false; this.needDrain = false; this.ending = false; this.ended = false; this.finished = false; this.destroyed = false; var noDecode = options.decodeStrings === false; this.decodeStrings = !noDecode; this.defaultEncoding = options.defaultEncoding || 'utf8'; this.length = 0; this.writing = false; this.corked = 0; this.sync = true; this.bufferProcessing = false; this.onwrite = function (er) { onwrite(stream, er); }; this.writecb = null; this.writelen = 0; this.bufferedRequest = null; this.lastBufferedRequest = null; this.pendingcb = 0; this.prefinished = false; this.errorEmitted = false; this.bufferedRequestCount = 0; this.corkedRequestsFree = new CorkedRequest(this); }
            WritableState.prototype.getBuffer = function getBuffer() {
                var current = this.bufferedRequest; var out = []; while (current) { out.push(current); current = current.next; }
                return out;
            }; (function () { try { Object.defineProperty(WritableState.prototype, 'buffer', { get: internalUtil.deprecate(function () { return this.getBuffer(); }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.', 'DEP0003') }); } catch (_) { } })(); var realHasInstance; if (typeof Symbol === 'function' && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === 'function') { realHasInstance = Function.prototype[Symbol.hasInstance]; Object.defineProperty(Writable, Symbol.hasInstance, { value: function (object) { if (realHasInstance.call(this, object)) return true; return object && object._writableState instanceof WritableState; } }); } else { realHasInstance = function (object) { return object instanceof this; }; }
            function Writable(options) {
                Duplex = Duplex || __webpack_require__(33); if (!realHasInstance.call(Writable, this) && !(this instanceof Duplex)) { return new Writable(options); }
                this._writableState = new WritableState(options, this); this.writable = true; if (options) { if (typeof options.write === 'function') this._write = options.write; if (typeof options.writev === 'function') this._writev = options.writev; if (typeof options.destroy === 'function') this._destroy = options.destroy; if (typeof options.final === 'function') this._final = options.final; }
                Stream.call(this);
            }
            Writable.prototype.pipe = function () { this.emit('error', new Error('Cannot pipe, not readable')); }; function writeAfterEnd(stream, cb) { var er = new Error('write after end'); stream.emit('error', er); processNextTick(cb, er); }
            function validChunk(stream, state, chunk, cb) {
                var valid = true; var er = false; if (chunk === null) { er = new TypeError('May not write null values to stream'); } else if (typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) { er = new TypeError('Invalid non-string/buffer chunk'); }
                if (er) { stream.emit('error', er); processNextTick(cb, er); valid = false; }
                return valid;
            }
            Writable.prototype.write = function (chunk, encoding, cb) {
                var state = this._writableState; var ret = false; var isBuf = _isUint8Array(chunk) && !state.objectMode; if (isBuf && !Buffer.isBuffer(chunk)) { chunk = _uint8ArrayToBuffer(chunk); }
                if (typeof encoding === 'function') { cb = encoding; encoding = null; }
                if (isBuf) encoding = 'buffer'; else if (!encoding) encoding = state.defaultEncoding; if (typeof cb !== 'function') cb = nop; if (state.ended) writeAfterEnd(this, cb); else if (isBuf || validChunk(this, state, chunk, cb)) { state.pendingcb++; ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb); }
                return ret;
            }; Writable.prototype.cork = function () { var state = this._writableState; state.corked++; }; Writable.prototype.uncork = function () { var state = this._writableState; if (state.corked) { state.corked--; if (!state.writing && !state.corked && !state.finished && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state); } }; Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) { if (typeof encoding === 'string') encoding = encoding.toLowerCase(); if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new TypeError('Unknown encoding: ' + encoding); this._writableState.defaultEncoding = encoding; return this; }; function decodeChunk(state, chunk, encoding) {
                if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') { chunk = Buffer.from(chunk, encoding); }
                return chunk;
            }
            function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
                if (!isBuf) { var newChunk = decodeChunk(state, chunk, encoding); if (chunk !== newChunk) { isBuf = true; encoding = 'buffer'; chunk = newChunk; } }
                var len = state.objectMode ? 1 : chunk.length; state.length += len; var ret = state.length < state.highWaterMark; if (!ret) state.needDrain = true; if (state.writing || state.corked) {
                    var last = state.lastBufferedRequest; state.lastBufferedRequest = { chunk: chunk, encoding: encoding, isBuf: isBuf, callback: cb, next: null }; if (last) { last.next = state.lastBufferedRequest; } else { state.bufferedRequest = state.lastBufferedRequest; }
                    state.bufferedRequestCount += 1;
                } else { doWrite(stream, state, false, len, chunk, encoding, cb); }
                return ret;
            }
            function doWrite(stream, state, writev, len, chunk, encoding, cb) { state.writelen = len; state.writecb = cb; state.writing = true; state.sync = true; if (writev) stream._writev(chunk, state.onwrite); else stream._write(chunk, encoding, state.onwrite); state.sync = false; }
            function onwriteError(stream, state, sync, er, cb) { --state.pendingcb; if (sync) { processNextTick(cb, er); processNextTick(finishMaybe, stream, state); stream._writableState.errorEmitted = true; stream.emit('error', er); } else { cb(er); stream._writableState.errorEmitted = true; stream.emit('error', er); finishMaybe(stream, state); } }
            function onwriteStateUpdate(state) { state.writing = false; state.writecb = null; state.length -= state.writelen; state.writelen = 0; }
            function onwrite(stream, er) {
                var state = stream._writableState; var sync = state.sync; var cb = state.writecb; onwriteStateUpdate(state); if (er) onwriteError(stream, state, sync, er, cb); else {
                    var finished = needFinish(state); if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) { clearBuffer(stream, state); }
                    if (sync) { asyncWrite(afterWrite, stream, state, finished, cb); } else { afterWrite(stream, state, finished, cb); }
                }
            }
            function afterWrite(stream, state, finished, cb) { if (!finished) onwriteDrain(stream, state); state.pendingcb--; cb(); finishMaybe(stream, state); }
            function onwriteDrain(stream, state) { if (state.length === 0 && state.needDrain) { state.needDrain = false; stream.emit('drain'); } }
            function clearBuffer(stream, state) {
                state.bufferProcessing = true; var entry = state.bufferedRequest; if (stream._writev && entry && entry.next) {
                    var l = state.bufferedRequestCount; var buffer = new Array(l); var holder = state.corkedRequestsFree; holder.entry = entry; var count = 0; var allBuffers = true; while (entry) { buffer[count] = entry; if (!entry.isBuf) allBuffers = false; entry = entry.next; count += 1; }
                    buffer.allBuffers = allBuffers; doWrite(stream, state, true, state.length, buffer, '', holder.finish); state.pendingcb++; state.lastBufferedRequest = null; if (holder.next) { state.corkedRequestsFree = holder.next; holder.next = null; } else { state.corkedRequestsFree = new CorkedRequest(state); }
                } else {
                    while (entry) { var chunk = entry.chunk; var encoding = entry.encoding; var cb = entry.callback; var len = state.objectMode ? 1 : chunk.length; doWrite(stream, state, false, len, chunk, encoding, cb); entry = entry.next; if (state.writing) { break; } }
                    if (entry === null) state.lastBufferedRequest = null;
                }
                state.bufferedRequestCount = 0; state.bufferedRequest = entry; state.bufferProcessing = false;
            }
            Writable.prototype._write = function (chunk, encoding, cb) { cb(new Error('_write() is not implemented')); }; Writable.prototype._writev = null; Writable.prototype.end = function (chunk, encoding, cb) {
                var state = this._writableState; if (typeof chunk === 'function') { cb = chunk; chunk = null; encoding = null; } else if (typeof encoding === 'function') { cb = encoding; encoding = null; }
                if (chunk !== null && chunk !== undefined) this.write(chunk, encoding); if (state.corked) { state.corked = 1; this.uncork(); }
                if (!state.ending && !state.finished) endWritable(this, state, cb);
            }; function needFinish(state) { return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing; }
            function callFinal(stream, state) {
                stream._final(function (err) {
                    state.pendingcb--; if (err) { stream.emit('error', err); }
                    state.prefinished = true; stream.emit('prefinish'); finishMaybe(stream, state);
                });
            }
            function prefinish(stream, state) { if (!state.prefinished && !state.finalCalled) { if (typeof stream._final === 'function') { state.pendingcb++; state.finalCalled = true; processNextTick(callFinal, stream, state); } else { state.prefinished = true; stream.emit('prefinish'); } } }
            function finishMaybe(stream, state) {
                var need = needFinish(state); if (need) { prefinish(stream, state); if (state.pendingcb === 0) { state.finished = true; stream.emit('finish'); } }
                return need;
            }
            function endWritable(stream, state, cb) {
                state.ending = true; finishMaybe(stream, state); if (cb) { if (state.finished) processNextTick(cb); else stream.once('finish', cb); }
                state.ended = true; stream.writable = false;
            }
            function onCorkedFinish(corkReq, state, err) {
                var entry = corkReq.entry; corkReq.entry = null; while (entry) { var cb = entry.callback; state.pendingcb--; cb(err); entry = entry.next; }
                if (state.corkedRequestsFree) { state.corkedRequestsFree.next = corkReq; } else { state.corkedRequestsFree = corkReq; }
            }
            Object.defineProperty(Writable.prototype, 'destroyed', {
                get: function () {
                    if (this._writableState === undefined) { return false; }
                    return this._writableState.destroyed;
                }, set: function (value) {
                    if (!this._writableState) { return; }
                    this._writableState.destroyed = value;
                }
            }); Writable.prototype.destroy = destroyImpl.destroy; Writable.prototype._undestroy = destroyImpl.undestroy; Writable.prototype._destroy = function (err, cb) { this.end(); cb(err); };
        }.call(exports, __webpack_require__(41), __webpack_require__(496).setImmediate, __webpack_require__(17)))
    }), (function (module, exports, __webpack_require__) {
        "use strict"; var Buffer = __webpack_require__(78).Buffer; var isEncoding = Buffer.isEncoding || function (encoding) { encoding = '' + encoding; switch (encoding && encoding.toLowerCase()) { case 'hex': case 'utf8': case 'utf-8': case 'ascii': case 'binary': case 'base64': case 'ucs2': case 'ucs-2': case 'utf16le': case 'utf-16le': case 'raw': return true; default: return false; } }; function _normalizeEncoding(enc) { if (!enc) return 'utf8'; var retried; while (true) { switch (enc) { case 'utf8': case 'utf-8': return 'utf8'; case 'ucs2': case 'ucs-2': case 'utf16le': case 'utf-16le': return 'utf16le'; case 'latin1': case 'binary': return 'latin1'; case 'base64': case 'ascii': case 'hex': return enc; default: if (retried) return; enc = ('' + enc).toLowerCase(); retried = true; } } }; function normalizeEncoding(enc) { var nenc = _normalizeEncoding(enc); if (typeof nenc !== 'string' && (Buffer.isEncoding === isEncoding || !isEncoding(enc))) throw new Error('Unknown encoding: ' + enc); return nenc || enc; }
        exports.StringDecoder = StringDecoder; function StringDecoder(encoding) {
            this.encoding = normalizeEncoding(encoding); var nb; switch (this.encoding) { case 'utf16le': this.text = utf16Text; this.end = utf16End; nb = 4; break; case 'utf8': this.fillLast = utf8FillLast; nb = 4; break; case 'base64': this.text = base64Text; this.end = base64End; nb = 3; break; default: this.write = simpleWrite; this.end = simpleEnd; return; }
            this.lastNeed = 0; this.lastTotal = 0; this.lastChar = Buffer.allocUnsafe(nb);
        }
        StringDecoder.prototype.write = function (buf) {
            if (buf.length === 0) return ''; var r; var i; if (this.lastNeed) { r = this.fillLast(buf); if (r === undefined) return ''; i = this.lastNeed; this.lastNeed = 0; } else { i = 0; }
            if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i); return r || '';
        }; StringDecoder.prototype.end = utf8End; StringDecoder.prototype.text = utf8Text; StringDecoder.prototype.fillLast = function (buf) {
            if (this.lastNeed <= buf.length) { buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed); return this.lastChar.toString(this.encoding, 0, this.lastTotal); }
            buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length); this.lastNeed -= buf.length;
        }; function utf8CheckByte(byte) { if (byte <= 0x7F) return 0; else if (byte >> 5 === 0x06) return 2; else if (byte >> 4 === 0x0E) return 3; else if (byte >> 3 === 0x1E) return 4; return -1; }
        function utf8CheckIncomplete(self, buf, i) {
            var j = buf.length - 1; if (j < i) return 0; var nb = utf8CheckByte(buf[j]); if (nb >= 0) { if (nb > 0) self.lastNeed = nb - 1; return nb; }
            if (--j < i) return 0; nb = utf8CheckByte(buf[j]); if (nb >= 0) { if (nb > 0) self.lastNeed = nb - 2; return nb; }
            if (--j < i) return 0; nb = utf8CheckByte(buf[j]); if (nb >= 0) {
                if (nb > 0) { if (nb === 2) nb = 0; else self.lastNeed = nb - 3; }
                return nb;
            }
            return 0;
        }
        function utf8CheckExtraBytes(self, buf, p) {
            if ((buf[0] & 0xC0) !== 0x80) { self.lastNeed = 0; return '\ufffd'.repeat(p); }
            if (self.lastNeed > 1 && buf.length > 1) {
                if ((buf[1] & 0xC0) !== 0x80) { self.lastNeed = 1; return '\ufffd'.repeat(p + 1); }
                if (self.lastNeed > 2 && buf.length > 2) { if ((buf[2] & 0xC0) !== 0x80) { self.lastNeed = 2; return '\ufffd'.repeat(p + 2); } }
            }
        }
        function utf8FillLast(buf) {
            var p = this.lastTotal - this.lastNeed; var r = utf8CheckExtraBytes(this, buf, p); if (r !== undefined) return r; if (this.lastNeed <= buf.length) { buf.copy(this.lastChar, p, 0, this.lastNeed); return this.lastChar.toString(this.encoding, 0, this.lastTotal); }
            buf.copy(this.lastChar, p, 0, buf.length); this.lastNeed -= buf.length;
        }
        function utf8Text(buf, i) { var total = utf8CheckIncomplete(this, buf, i); if (!this.lastNeed) return buf.toString('utf8', i); this.lastTotal = total; var end = buf.length - (total - this.lastNeed); buf.copy(this.lastChar, 0, end); return buf.toString('utf8', i, end); }
        function utf8End(buf) { var r = buf && buf.length ? this.write(buf) : ''; if (this.lastNeed) return r + '\ufffd'.repeat(this.lastTotal - this.lastNeed); return r; }
        function utf16Text(buf, i) {
            if ((buf.length - i) % 2 === 0) {
                var r = buf.toString('utf16le', i); if (r) { var c = r.charCodeAt(r.length - 1); if (c >= 0xD800 && c <= 0xDBFF) { this.lastNeed = 2; this.lastTotal = 4; this.lastChar[0] = buf[buf.length - 2]; this.lastChar[1] = buf[buf.length - 1]; return r.slice(0, -1); } }
                return r;
            }
            this.lastNeed = 1; this.lastTotal = 2; this.lastChar[0] = buf[buf.length - 1]; return buf.toString('utf16le', i, buf.length - 1);
        }
        function utf16End(buf) {
            var r = buf && buf.length ? this.write(buf) : ''; if (this.lastNeed) { var end = this.lastTotal - this.lastNeed; return r + this.lastChar.toString('utf16le', 0, end); }
            return r;
        }
        function base64Text(buf, i) {
            var n = (buf.length - i) % 3; if (n === 0) return buf.toString('base64', i); this.lastNeed = 3 - n; this.lastTotal = 3; if (n === 1) { this.lastChar[0] = buf[buf.length - 1]; } else { this.lastChar[0] = buf[buf.length - 2]; this.lastChar[1] = buf[buf.length - 1]; }
            return buf.toString('base64', i, buf.length - n);
        }
        function base64End(buf) { var r = buf && buf.length ? this.write(buf) : ''; if (this.lastNeed) return r + this.lastChar.toString('base64', 0, 3 - this.lastNeed); return r; }
        function simpleWrite(buf) { return buf.toString(this.encoding); }
        function simpleEnd(buf) { return buf && buf.length ? this.write(buf) : ''; }
    }), (function (module, exports, __webpack_require__) { 
        var plugins = { usedKeywords: __webpack_require__(240) }; 
        var helpers = { scoreToRating: __webpack_require__(80) }; 
        module.exports = { 
            Assessor: __webpack_require__(42), 
            SEOAssessor: __webpack_require__(114), 
            ContentAssessor: __webpack_require__(115), 
            App: __webpack_require__(454), 
            Pluggable: __webpack_require__(225), Researcher: __webpack_require__(81), SnippetPreview: __webpack_require__(221), Paper: __webpack_require__(226), AssessmentResult: __webpack_require__(0), bundledPlugins: plugins, helpers: helpers }; }), (function (module, exports, __webpack_require__) { (function (global) { var freeGlobal = typeof global == 'object' && global && global.Object === Object && global; module.exports = freeGlobal; }.call(exports, __webpack_require__(17))) }), (function (module, exports) {
        var funcProto = Function.prototype; var funcToString = funcProto.toString; function toSource(func) {
            if (func != null) {
                try { return funcToString.call(func); } catch (e) { }
                try { return (func + ''); } catch (e) { }
            }
            return '';
        }
        module.exports = toSource;
    }), (function (module, exports, __webpack_require__) {
        var baseIsEqualDeep = __webpack_require__(274), isObjectLike = __webpack_require__(13); function baseIsEqual(value, other, bitmask, customizer, stack) {
            if (value === other) { return true; }
            if (value == null || other == null || (!isObjectLike(value) && !isObjectLike(other))) { return value !== value && other !== other; }
            return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
        }
        module.exports = baseIsEqual;
    }), (function (module, exports, __webpack_require__) {
        var SetCache = __webpack_require__(64), arraySome = __webpack_require__(277), cacheHas = __webpack_require__(65); var COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2; function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
            var isPartial = bitmask & COMPARE_PARTIAL_FLAG, arrLength = array.length, othLength = other.length; if (arrLength != othLength && !(isPartial && othLength > arrLength)) { return false; }
            var stacked = stack.get(array); if (stacked && stack.get(other)) { return stacked == other; }
            var index = -1, result = true, seen = (bitmask & COMPARE_UNORDERED_FLAG) ? new SetCache : undefined; stack.set(array, other); stack.set(other, array); while (++index < arrLength) {
                var arrValue = array[index], othValue = other[index]; if (customizer) { var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack); }
                if (compared !== undefined) {
                    if (compared) { continue; }
                    result = false; break;
                }
                if (seen) { if (!arraySome(other, function (othValue, othIndex) { if (!cacheHas(seen, othIndex) && (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) { return seen.push(othIndex); } })) { result = false; break; } } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) { result = false; break; }
            }
            stack['delete'](array); stack['delete'](other); return result;
        }
        module.exports = equalArrays;
    }), (function (module, exports, __webpack_require__) { var root = __webpack_require__(9); var Uint8Array = root.Uint8Array; module.exports = Uint8Array; }), (function (module, exports) {
        function mapToArray(map) { var index = -1, result = Array(map.size); map.forEach(function (value, key) { result[++index] = [key, value]; }); return result; }
        module.exports = mapToArray;
    }), (function (module, exports, __webpack_require__) {
        var baseGetAllKeys = __webpack_require__(134), getSymbols = __webpack_require__(85), keys = __webpack_require__(26); function getAllKeys(object) { return baseGetAllKeys(object, keys, getSymbols); }
        module.exports = getAllKeys;
    }), (function (module, exports, __webpack_require__) {
        var arrayPush = __webpack_require__(84), isArray = __webpack_require__(4); function baseGetAllKeys(object, keysFunc, symbolsFunc) { var result = keysFunc(object); return isArray(object) ? result : arrayPush(result, symbolsFunc(object)); }
        module.exports = baseGetAllKeys;
    }), (function (module, exports) {
        function stubArray() { return []; }
        module.exports = stubArray;
    }), (function (module, exports, __webpack_require__) {
        var baseTimes = __webpack_require__(280), isArguments = __webpack_require__(43), isArray = __webpack_require__(4), isBuffer = __webpack_require__(44), isIndex = __webpack_require__(67), isTypedArray = __webpack_require__(68); var objectProto = Object.prototype; var hasOwnProperty = objectProto.hasOwnProperty; function arrayLikeKeys(value, inherited) {
            var isArr = isArray(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer(value), isType = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes(value.length, String) : [], length = result.length; for (var key in value) { if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && (key == 'length' || (isBuff && (key == 'offset' || key == 'parent')) || (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) || isIndex(key, length)))) { result.push(key); } }
            return result;
        }
        module.exports = arrayLikeKeys;
    }), (function (module, exports, __webpack_require__) {
        var isPrototype = __webpack_require__(70), nativeKeys = __webpack_require__(285); var objectProto = Object.prototype; var hasOwnProperty = objectProto.hasOwnProperty; function baseKeys(object) {
            if (!isPrototype(object)) { return nativeKeys(object); }
            var result = []; for (var key in Object(object)) { if (hasOwnProperty.call(object, key) && key != 'constructor') { result.push(key); } }
            return result;
        }
        module.exports = baseKeys;
    }), (function (module, exports) {
        function overArg(func, transform) { return function (arg) { return func(transform(arg)); }; }
        module.exports = overArg;
    }), (function (module, exports, __webpack_require__) { var getNative = __webpack_require__(25), root = __webpack_require__(9); var Set = getNative(root, 'Set'); module.exports = Set; }), (function (module, exports, __webpack_require__) {
        var isObject = __webpack_require__(5); function isStrictComparable(value) { return value === value && !isObject(value); }
        module.exports = isStrictComparable;
    }), (function (module, exports) {
        function matchesStrictComparable(key, srcValue) {
            return function (object) {
                if (object == null) { return false; }
                return object[key] === srcValue && (srcValue !== undefined || (key in Object(object)));
            };
        }
        module.exports = matchesStrictComparable;
    }), (function (module, exports, __webpack_require__) {
        var baseHasIn = __webpack_require__(295), hasPath = __webpack_require__(143); function hasIn(object, path) { return object != null && hasPath(object, path, baseHasIn); }
        module.exports = hasIn;
    }), (function (module, exports, __webpack_require__) {
        var castPath = __webpack_require__(71), isArguments = __webpack_require__(43), isArray = __webpack_require__(4), isIndex = __webpack_require__(67), isLength = __webpack_require__(87), toKey = __webpack_require__(47); function hasPath(object, path, hasFunc) {
            path = castPath(path, object); var index = -1, length = path.length, result = false; while (++index < length) {
                var key = toKey(path[index]); if (!(result = object != null && hasFunc(object, key))) { break; }
                object = object[key];
            }
            if (result || ++index != length) { return result; }
            length = object == null ? 0 : object.length; return !!length && isLength(length) && isIndex(key, length) && (isArray(object) || isArguments(object));
        }
        module.exports = hasPath;
    }), (function (module, exports, __webpack_require__) {
        var baseEach = __webpack_require__(48), isArrayLike = __webpack_require__(19); function baseMap(collection, iteratee) { var index = -1, result = isArrayLike(collection) ? Array(collection.length) : []; baseEach(collection, function (value, key, collection) { result[++index] = iteratee(value, key, collection); }); return result; }
        module.exports = baseMap;
    }), (function (module, exports, __webpack_require__) { var createBaseFor = __webpack_require__(300); var baseFor = createBaseFor(); module.exports = baseFor; }), (function (module, exports) {
        function arrayEach(array, iteratee) {
            var index = -1, length = array == null ? 0 : array.length; while (++index < length) { if (iteratee(array[index], index, array) === false) { break; } }
            return array;
        }
        module.exports = arrayEach;
    }), (function (module, exports, __webpack_require__) {
        var baseEach = __webpack_require__(48); function baseFilter(collection, predicate) { var result = []; baseEach(collection, function (value, index, collection) { if (predicate(value, index, collection)) { result.push(value); } }); return result; }
        module.exports = baseFilter;
    }), (function (module, exports) {
        var FUNC_ERROR_TEXT = 'Expected a function'; function negate(predicate) {
            if (typeof predicate != 'function') { throw new TypeError(FUNC_ERROR_TEXT); }
            return function () {
                var args = arguments; switch (args.length) { case 0: return !predicate.call(this); case 1: return !predicate.call(this, args[0]); case 2: return !predicate.call(this, args[0], args[1]); case 3: return !predicate.call(this, args[0], args[1], args[2]); }
                return !predicate.apply(this, args);
            };
        }
        module.exports = negate;
    }), (function (module, exports) {
        var findMatchingRule = function (rules, text) {
            var i; for (i = 0; i < rules.length; i++)
                if (rules[i].regex.test(text))
                    return rules[i]; return undefined;
        }; var findMaxIndexAndRule = function (rules, text) {
            var i, rule, last_matching_rule; for (i = 0; i < text.length; i++) {
                rule = findMatchingRule(rules, text.substring(0, i + 1)); if (rule)
                    last_matching_rule = rule; else if (last_matching_rule)
                    return { max_index: i, rule: last_matching_rule };
            }
            return last_matching_rule ? { max_index: text.length, rule: last_matching_rule } : undefined;
        }; module.exports = function (onToken_orig) {
            var buffer = ""; var rules = []; var line = 1; var col = 1; var onToken = function (src, type) { onToken_orig({ type: type, src: src, line: line, col: col }); var lines = src.split("\n"); line += lines.length - 1; col = (lines.length > 1 ? 1 : col) + lines[lines.length - 1].length; }; return {
                addRule: function (regex, type) { rules.push({ regex: regex, type: type }); }, onText: function (text) {
                    var str = buffer + text; var m = findMaxIndexAndRule(rules, str); while (m && m.max_index !== str.length) { onToken(str.substring(0, m.max_index), m.rule.type); str = str.substring(m.max_index); m = findMaxIndexAndRule(rules, str); }
                    buffer = str;
                }, end: function () {
                    if (buffer.length === 0)
                        return; var rule = findMatchingRule(rules, buffer); if (!rule) { var err = new Error("unable to tokenize"); err.tokenizer2 = { buffer: buffer, line: line, col: col }; throw err; }
                    onToken(buffer, rule.type);
                }
            };
        };
    }), (function (module, exports, __webpack_require__) { "use strict"; var unifyNonBreakingSpace = function unifyNonBreakingSpace(text) { return text.replace(/&nbsp;/g, " "); }; var unifyWhiteSpace = function unifyWhiteSpace(text) { return text.replace(/\s/g, " "); }; var unifyAllSpaces = function unifyAllSpaces(text) { text = unifyNonBreakingSpace(text); return unifyWhiteSpace(text); }; module.exports = { unifyNonBreakingSpace: unifyNonBreakingSpace, unifyWhiteSpace: unifyWhiteSpace, unifyAllSpaces: unifyAllSpaces }; }), (function (module, exports, __webpack_require__) {
        var baseAssignValue = __webpack_require__(94), eq = __webpack_require__(35); function assignMergeValue(object, key, value) { if ((value !== undefined && !eq(object[key], value)) || (value === undefined && !(key in object))) { baseAssignValue(object, key, value); } }
        module.exports = assignMergeValue;
    }), (function (module, exports, __webpack_require__) { var getNative = __webpack_require__(25); var defineProperty = (function () { try { var func = getNative(Object, 'defineProperty'); func({}, '', {}); return func; } catch (e) { } }()); module.exports = defineProperty; }), (function (module, exports, __webpack_require__) {
        (function (module) {
            var root = __webpack_require__(9); var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports; var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module; var moduleExports = freeModule && freeModule.exports === freeExports; var Buffer = moduleExports ? root.Buffer : undefined, allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined; function cloneBuffer(buffer, isDeep) {
                if (isDeep) { return buffer.slice(); }
                var length = buffer.length, result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length); buffer.copy(result); return result;
            }
            module.exports = cloneBuffer;
        }.call(exports, __webpack_require__(45)(module)))
    }), (function (module, exports, __webpack_require__) {
        var cloneArrayBuffer = __webpack_require__(95); function cloneTypedArray(typedArray, isDeep) { var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer; return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length); }
        module.exports = cloneTypedArray;
    }), (function (module, exports) {
        function copyArray(source, array) {
            var index = -1, length = source.length; array || (array = Array(length)); while (++index < length) { array[index] = source[index]; }
            return array;
        }
        module.exports = copyArray;
    }), (function (module, exports, __webpack_require__) {
        var baseCreate = __webpack_require__(306), getPrototype = __webpack_require__(96), isPrototype = __webpack_require__(70); function initCloneObject(object) { return (typeof object.constructor == 'function' && !isPrototype(object)) ? baseCreate(getPrototype(object)) : {}; }
        module.exports = initCloneObject;
    }), (function (module, exports, __webpack_require__) {
        var baseGetTag = __webpack_require__(21), getPrototype = __webpack_require__(96), isObjectLike = __webpack_require__(13); var objectTag = '[object Object]'; var funcProto = Function.prototype, objectProto = Object.prototype; var funcToString = funcProto.toString; var hasOwnProperty = objectProto.hasOwnProperty; var objectCtorString = funcToString.call(Object); function isPlainObject(value) {
            if (!isObjectLike(value) || baseGetTag(value) != objectTag) { return false; }
            var proto = getPrototype(value); if (proto === null) { return true; }
            var Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor; return typeof Ctor == 'function' && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
        }
        module.exports = isPlainObject;
    }), (function (module, exports, __webpack_require__) {
        var apply = __webpack_require__(100); var nativeMax = Math.max; function overRest(func, start, transform) {
            start = nativeMax(start === undefined ? (func.length - 1) : start, 0); return function () {
                var args = arguments, index = -1, length = nativeMax(args.length - start, 0), array = Array(length); while (++index < length) { array[index] = args[start + index]; }
                index = -1; var otherArgs = Array(start + 1); while (++index < start) { otherArgs[index] = args[index]; }
                otherArgs[start] = transform(array); return apply(func, this, otherArgs);
            };
        }
        module.exports = overRest;
    }), (function (module, exports, __webpack_require__) { var baseSetToString = __webpack_require__(310), shortOut = __webpack_require__(312); var setToString = shortOut(baseSetToString); module.exports = setToString; }), (function (module, exports, __webpack_require__) {
        var eq = __webpack_require__(35), isArrayLike = __webpack_require__(19), isIndex = __webpack_require__(67), isObject = __webpack_require__(5); function isIterateeCall(value, index, object) {
            if (!isObject(object)) { return false; }
            var type = typeof index; if (type == 'number' ? (isArrayLike(object) && isIndex(index, object.length)) : (type == 'string' && index in object)) { return eq(object[index], value); }
            return false;
        }
        module.exports = isIterateeCall;
    }), (function (module, exports, __webpack_require__) { "use strict"; module.exports = function InvalidTypeError(message) { Error.captureStackTrace(this, this.constructor); this.name = this.constructor.name; this.message = message; }; __webpack_require__(14).inherits(module.exports, Error); }), (function (module, exports, __webpack_require__) {
        "use strict"; module.exports = function (text) {
            var matches; matches = text.match(/<a(?:[^>]+)?>(.*?)<\/a>/ig); if (matches === null) { matches = []; }
            return matches;
        };
    }), (function (module, exports, __webpack_require__) {
        "use strict"; var transliterationsMap = __webpack_require__(317); module.exports = function (text, locale) {
            var map = transliterationsMap(locale); for (var i = 0; i < map.length; i++) { text = text.replace(map[i].letter, map[i].alternative); }
            return text;
        };
    }), (function (module, exports, __webpack_require__) { "use strict"; var getAnchors = __webpack_require__(162); var map = __webpack_require__(2); var url = __webpack_require__(102); module.exports = function (paper) { var anchors = getAnchors(paper.getText()); return map(anchors, url.getFromAnchorTag); }; }), (function (module, exports, __webpack_require__) { "use strict"; var stripSpaces = __webpack_require__(8); module.exports = function (text) { text = text.replace(/<(?!li|\/li|p|\/p|h1|\/h1|h2|\/h2|h3|\/h3|h4|\/h4|h5|\/h5|h6|\/h6|dd).*?\>/g, ""); text = stripSpaces(text); return text; }; }), (function (module, exports, __webpack_require__) {
        "use strict"; var stopwords = __webpack_require__(336)(); var toRegex = __webpack_require__(167); module.exports = function (text) {
            var i, matches = []; for (i = 0; i < stopwords.length; i++) { if (text.match(toRegex(stopwords[i])) !== null) { matches.push(stopwords[i]); } }
            return matches;
        };
    }), (function (module, exports, __webpack_require__) {
        "use strict"; var isUndefined = __webpack_require__(3); var replaceDiacritics = __webpack_require__(168); var addWordBoundary = __webpack_require__(50); var sanitizeString = __webpack_require__(169); var escapeRegExp = __webpack_require__(12); var memoize = __webpack_require__(36); module.exports = memoize(function (string, extraBoundary, doReplaceDiacritics) {
            if (isUndefined(extraBoundary)) { extraBoundary = ""; }
            if (isUndefined(doReplaceDiacritics) || doReplaceDiacritics === true) { string = replaceDiacritics(string); }
            string = sanitizeString(string); string = escapeRegExp(string); string = addWordBoundary(string, false, extraBoundary); return new RegExp(string, "ig");
        });
    }), (function (module, exports, __webpack_require__) {
        "use strict"; var diacriticsRemovalMap = __webpack_require__(337); module.exports = function (text) {
            var map = diacriticsRemovalMap(); for (var i = 0; i < map.length; i++) { text = text.replace(map[i].letters, map[i].base); }
            return text;
        };
    }), (function (module, exports, __webpack_require__) { "use strict"; var stripTags = __webpack_require__(7).stripFullTags; var stripSpaces = __webpack_require__(8); module.exports = function (text) { text = stripTags(text); text = stripSpaces(text); return text; }; }), (function (module, exports, __webpack_require__) {
        "use strict"; var syllableMatchers = __webpack_require__(342); var getWords = __webpack_require__(27); var forEach = __webpack_require__(1); var filter = __webpack_require__(6); var find = __webpack_require__(103); var isUndefined = __webpack_require__(3); var map = __webpack_require__(2); var sum = __webpack_require__(174); var memoize = __webpack_require__(36); var flatMap = __webpack_require__(72); var SyllableCountIterator = __webpack_require__(349); var DeviationFragment = __webpack_require__(351); var countVowelGroups = function countVowelGroups(word, locale) { var numberOfSyllables = 0; var vowelRegex = new RegExp("[^" + syllableMatchers(locale).vowels + "]", "ig"); var foundVowels = word.split(vowelRegex); var filteredWords = filter(foundVowels, function (vowel) { return vowel !== ""; }); numberOfSyllables += filteredWords.length; return numberOfSyllables; }; var countVowelDeviations = function countVowelDeviations(word, locale) { var syllableCountIterator = new SyllableCountIterator(syllableMatchers(locale)); return syllableCountIterator.countSyllables(word); }; var countFullWordDeviations = function countFullWordDeviations(word, locale) {
            var fullWordDeviations = syllableMatchers(locale).deviations.words.full; var deviation = find(fullWordDeviations, function (fullWordDeviation) { return fullWordDeviation.word === word; }); if (!isUndefined(deviation)) { return deviation.syllables; }
            return 0;
        }; function createDeviationFragments(syllableConfig) {
            var deviationFragments = []; var deviations = syllableConfig.deviations; if (!isUndefined(deviations.words) && !isUndefined(deviations.words.fragments)) { deviationFragments = flatMap(deviations.words.fragments, function (fragments, fragmentLocation) { return map(fragments, function (fragment) { fragment.location = fragmentLocation; return new DeviationFragment(fragment); }); }); }
            return deviationFragments;
        }
        var createDeviationFragmentsMemoized = memoize(createDeviationFragments); var countPartialWordDeviations = function countPartialWordDeviations(word, locale) { var deviationFragments = createDeviationFragmentsMemoized(syllableMatchers(locale)); var remainingParts = word; var syllableCount = 0; forEach(deviationFragments, function (deviationFragment) { if (deviationFragment.occursIn(remainingParts)) { remainingParts = deviationFragment.removeFrom(remainingParts); syllableCount += deviationFragment.getSyllables(); } }); return { word: remainingParts, syllableCount: syllableCount }; }; var countUsingVowels = function countUsingVowels(word, locale) { var syllableCount = 0; syllableCount += countVowelGroups(word, locale); syllableCount += countVowelDeviations(word, locale); return syllableCount; }; var countSyllablesInWord = function countSyllablesInWord(word, locale) {
            var syllableCount = 0; var fullWordExclusion = countFullWordDeviations(word, locale); if (fullWordExclusion !== 0) { return fullWordExclusion; }
            var partialExclusions = countPartialWordDeviations(word, locale); word = partialExclusions.word; syllableCount += partialExclusions.syllableCount; syllableCount += countUsingVowels(word, locale); return syllableCount;
        }; var countSyllablesInText = function countSyllablesInText(text, locale) { text = text.toLocaleLowerCase(); var words = getWords(text); var syllableCounts = map(words, function (word) { return countSyllablesInWord(word, locale); }); return sum(syllableCounts); }; module.exports = countSyllablesInText;
    }), (function (module, exports, __webpack_require__) {
        var baseFindIndex = __webpack_require__(172), baseIteratee = __webpack_require__(18), toInteger = __webpack_require__(75); var nativeMax = Math.max; function findIndex(array, predicate, fromIndex) {
            var length = array == null ? 0 : array.length; if (!length) { return -1; }
            var index = fromIndex == null ? 0 : toInteger(fromIndex); if (index < 0) { index = nativeMax(length + index, 0); }
            return baseFindIndex(array, baseIteratee(predicate, 3), index);
        }
        module.exports = findIndex;
    }), (function (module, exports) {
        function baseFindIndex(array, predicate, fromIndex, fromRight) {
            var length = array.length, index = fromIndex + (fromRight ? 1 : -1); while ((fromRight ? index-- : ++index < length)) { if (predicate(array[index], index, array)) { return index; } }
            return -1;
        }
        module.exports = baseFindIndex;
    }), (function (module, exports, __webpack_require__) {
        var toNumber = __webpack_require__(104); var INFINITY = 1 / 0, MAX_INTEGER = 1.7976931348623157e+308; function toFinite(value) {
            if (!value) { return value === 0 ? value : 0; }
            value = toNumber(value); if (value === INFINITY || value === -INFINITY) { var sign = (value < 0 ? -1 : 1); return sign * MAX_INTEGER; }
            return value === value ? value : 0;
        }
        module.exports = toFinite;
    }), (function (module, exports, __webpack_require__) {
        var baseSum = __webpack_require__(348), identity = __webpack_require__(37); function sum(array) { return (array && array.length) ? baseSum(array, identity) : 0; }
        module.exports = sum;
    }), (function (module, exports, __webpack_require__) {
        var baseFlatten = __webpack_require__(73); function flatten(array) { var length = array == null ? 0 : array.length; return length ? baseFlatten(array, 1) : []; }
        module.exports = flatten;
    }), (function (module, exports, __webpack_require__) { "use strict"; var matchStringWithRegex = __webpack_require__(359); module.exports = function (text) { return matchStringWithRegex(text, "<img(?:[^>]+)?>"); }; }), (function (module, exports, __webpack_require__) {
        "use strict"; var map = __webpack_require__(2); var flatMap = __webpack_require__(72); var filter = __webpack_require__(6); var getBlocks = __webpack_require__(92).getBlocks; var getParagraphsInTags = function getParagraphsInTags(text) {
            var paragraphs = []; var regex = /<p(?:[^>]+)?>(.*?)<\/p>/ig; var match; while ((match = regex.exec(text)) !== null) { paragraphs.push(match); }
            return map(paragraphs, function (paragraph) { return paragraph[1]; });
        }; module.exports = function (text) {
            var paragraphs = getParagraphsInTags(text); if (paragraphs.length > 0) { return paragraphs; }
            var blocks = getBlocks(text); blocks = filter(blocks, function (block) { return 0 !== block.indexOf("<h"); }); paragraphs = flatMap(blocks, function (block) { return block.split("\n\n"); }); if (paragraphs.length > 0) { return paragraphs; }
            return [text];
        };
    }), (function (module, exports, __webpack_require__) {
        "use strict"; var wordCount = __webpack_require__(23); var forEach = __webpack_require__(1); var stripHTMLTags = __webpack_require__(7).stripFullTags; module.exports = function (sentences) {
            var sentencesWordCount = []; forEach(sentences, function (sentence) {
                var strippedSentence = stripHTMLTags(sentence); var length = wordCount(strippedSentence); if (length <= 0) { return; }
                sentencesWordCount.push({ sentence: sentence, sentenceLength: wordCount(sentence) });
            }); return sentencesWordCount;
        };
    }), (function (module, exports, __webpack_require__) { "use strict"; var singleWords = ["accordingly", "additionally", "afterward", "afterwards", "albeit", "also", "although", "altogether", "another", "basically", "because", "before", "besides", "but", "certainly", "chiefly", "comparatively", "concurrently", "consequently", "contrarily", "conversely", "correspondingly", "despite", "doubtedly", "during", "e.g.", "earlier", "emphatically", "equally", "especially", "eventually", "evidently", "explicitly", "finally", "firstly", "following", "formerly", "forthwith", "fourthly", "further", "furthermore", "generally", "hence", "henceforth", "however", "i.e.", "identically", "indeed", "instead", "last", "lastly", "later", "lest", "likewise", "markedly", "meanwhile", "moreover", "nevertheless", "nonetheless", "nor", "notwithstanding", "obviously", "occasionally", "otherwise", "overall", "particularly", "presently", "previously", "rather", "regardless", "secondly", "shortly", "significantly", "similarly", "simultaneously", "since", "so", "soon", "specifically", "still", "straightaway", "subsequently", "surely", "surprisingly", "than", "then", "thereafter", "therefore", "thereupon", "thirdly", "though", "thus", "till", "undeniably", "undoubtedly", "unless", "unlike", "unquestionably", "until", "when", "whenever", "whereas", "while"]; var multipleWords = ["above all", "after all", "after that", "all in all", "all of a sudden", "all things considered", "analogous to", "although this may be true", "analogous to", "another key point", "as a matter of fact", "as a result", "as an illustration", "as can be seen", "as has been noted", "as I have noted", "as I have said", "as I have shown", "as long as", "as much as", "as shown above", "as soon as", "as well as", "at any rate", "at first", "at last", "at least", "at length", "at the present time", "at the same time", "at this instant", "at this point", "at this time", "balanced against", "being that", "by all means", "by and large", "by comparison", "by the same token", "by the time", "compared to", "be that as it may", "coupled with", "different from", "due to", "equally important", "even if", "even more", "even so", "even though", "first thing to remember", "for example", "for fear that", "for instance", "for one thing", "for that reason", "for the most part", "for the purpose of", "for the same reason", "for this purpose", "for this reason", "from time to time", "given that", "given these points", "important to realize", "in a word", "in addition", "in another case", "in any case", "in any event", "in brief", "in case", "in conclusion", "in contrast", "in detail", "in due time", "in effect", "in either case", "in essence", "in fact", "in general", "in light of", "in like fashion", "in like manner", "in order that", "in order to", "in other words", "in particular", "in reality", "in short", "in similar fashion", "in spite of", "in sum", "in summary", "in that case", "in the event that", "in the final analysis", "in the first place", "in the fourth place", "in the hope that", "in the light of", "in the long run", "in the meantime", "in the same fashion", "in the same way", "in the second place", "in the third place", "in this case", "in this situation", "in time", "in truth", "in view of", "inasmuch as", "most compelling evidence", "most important", "must be remembered", "not to mention", "now that", "of course", "on account of", "on balance", "on condition that", "on one hand", "on the condition that", "on the contrary", "on the negative side", "on the other hand", "on the positive side", "on the whole", "on this occasion", "once", "once in a while", "only if", "owing to", "point often overlooked", "prior to", "provided that", "seeing that", "so as to", "so far", "so long as", "so that", "sooner or later", "such as", "summing up", "take the case of", "that is", "that is to say", "then again", "this time", "to be sure", "to begin with", "to clarify", "to conclude", "to demonstrate", "to emphasize", "to enumerate", "to explain", "to illustrate", "to list", "to point out", "to put it another way", "to put it differently", "to repeat", "to rephrase it", "to say nothing of", "to sum up", "to summarize", "to that end", "to the end that", "to this end", "together with", "under those circumstances", "until now", "up against", "up to the present time", "vis a vis", "what's more", "while it may be true", "while this may be true", "with attention to", "with the result that", "with this in mind", "with this intention", "with this purpose in mind", "without a doubt", "without delay", "without doubt", "without reservation"]; module.exports = function () { return { singleWords: singleWords, multipleWords: multipleWords, allWords: singleWords.concat(multipleWords) }; }; }), (function (module, exports, __webpack_require__) { "use strict"; var singleWords = ["aber", "abschließend", "abschliessend", "alldieweil", "allerdings", "also", "anderenteils", "andererseits", "andernteils", "anfaenglich", "anfänglich", "anfangs", "angenommen", "anschliessend", "anschließend", "aufgrund", "ausgenommen", "ausserdem", "außerdem", "beispielsweise", "bevor", "beziehungsweise", "bspw", "bzw", "d.h", "da", "dabei", "dadurch", "dafuer", "dafür", "dagegen", "daher", "dahingegen", "danach", "dann", "darauf", "darum", "dass", "davor", "dazu", "dementgegen", "dementsprechend", "demgegenüber", "demgegenueber", "demgemaess", "demgemäß", "demzufolge", "denn", "dennoch", "dergestalt", "desto", "deshalb", "desungeachtet", "deswegen", "doch", "dort", "drittens", "ebenfalls", "ebenso", "endlich", "ehe", "einerseits", "einesteils", "entsprechend", "entweder", "erst", "erstens", "falls", "ferner", "folgerichtig", "folglich", "fürderhin", "fuerderhin", "genauso", "hierdurch", "hierzu", "hingegen", "immerhin", "indem", "indes", "indessen", "infolge", "infolgedessen", "insofern", "insoweit", "inzwischen", "jedenfalls", "jedoch", "kurzum", "m.a.w", "mitnichten", "mitunter", "möglicherweise", "moeglicherweise", "nachdem", "nebenher", "nichtsdestotrotz", "nichtsdestoweniger", "ob", "obenrein", "obgleich", "obschon", "obwohl", "obzwar", "ohnehin", "richtigerweise", "schliesslich", "schließlich", "seit", "seitdem", "sobald", "sodass", "so dass", "sofern", "sogar", "solang", "solange", "somit", "sondern", "sooft", "soviel", "soweit", "sowie", "sowohl", "statt", "stattdessen", "trotz", "trotzdem", "überdies", "übrigens", "ueberdies", "uebrigens", "ungeachtet", "vielmehr", "vorausgesetzt", "vorher", "waehrend", "während", "währenddessen", "waehrenddessen", "weder", "wegen", "weil", "weiter", "weiterhin", "wenn", "wenngleich", "wennschon", "wennzwar", "weshalb", "widrigenfalls", "wiewohl", "wobei", "wohingegen", "z.b", "zudem", "zuerst", "zufolge", "zuletzt", "zumal", "zuvor", "zwar", "zweitens"]; var multipleWords = ["abgesehen von", "abgesehen davon", "als dass", "als wenn", "anders ausgedrückt", "anders ausgedrueckt", "anders formuliert", "anders gefasst", "anders gefragt", "anders gesagt", "anders gesprochen", "anstatt dass", "auch wenn", "auf grund", "auf jeden fall", "aus diesem grund", "ausser dass", "außer dass", "ausser wenn", "außer wenn", "besser ausgedrückt", "besser ausgedrueckt", "besser formuliert", "besser gesagt", "besser gesprochen", "bloss dass", "bloß dass", "das heisst", "das heißt", "des weiteren", "dessen ungeachtet", "ebenso wie", "genauso wie", "geschweige denn", "im fall", "im falle", "im folgenden", "im gegensatz dazu", "im grunde genommen", "in diesem sinne", "je nachdem", "kurz gesagt", "mit anderen worten", "ohne dass", "so dass", "umso mehr als", "umso weniger als", "umso mehr, als", "umso weniger, als", "unbeschadet dessen", "und zwar", "ungeachtet dessen", "unter dem strich", "zum beispiel"]; module.exports = function () { return { singleWords: singleWords, multipleWords: multipleWords, allWords: singleWords.concat(multipleWords) }; }; }), (function (module, exports, __webpack_require__) { "use strict"; var singleWords = ["ainsi", "alors", "aussi", "car", "cependant", "certainement", "certes", "conséquemment", "d'abord", "d'ailleurs", "d'après", "davantage", "désormais", "deuxièmement", "donc", "dorénavant", "effectivement", "également", "enfin", "ensuite", "entre-temps", "essentiellement", "excepté", "finalement", "globalement", "jusqu'ici", "là-dessus", "lorsque", "mais", "malgré", "néanmoins", "notamment", "partant", "plutôt", "pourtant", "précédemment", "premièrement", "probablement", "puis", "puisque", "quoique", "sauf", "selon", "semblablement", "sinon", "suivant", "toutefois", "troisièmement"]; var multipleWords = ["à cause de", "à ce jour", "à ce propos", "à ce sujet", "à cet égard", "à cette fin", "à compter de", "à condition que", "à défaut de", "à force de", "à juste titre", "à la lumière de", "à la suite de", "à l'aide de", "à l'appui de", "à l'encontre de", "à l'époque actuelle", "à l'exception de", "à l'exclusion de", "à l'heure actuelle", "à l'image de", "à l'instar de", "à l'inverse", "à l'inverse de", "à l'opposé", "à la condition que", "à mesure que", "à moins que", "à nouveau", "à partir de", "à première vue", "à savoir", "à seule fin que", "à supposer que", "à tel point que", "à tout prendre", "à vrai dire", "afin de", "afin d'attirer l'attention sur", "afin que", "ainsi donc", "ainsi que", "alors que", "antérieurement", "apès réflexion", "après cela", "après quoi", "après que", "après réflexion", "après tout", "attendu que", "au cas où", "au contraire", "au fond", "au fur et à mesure", "au lieu de", "au même temps", "au moment où", "au moyen de", "au point que", "au risque de", "au surplus", "au total", "aussi bien que", "aussitôt que", "autant que", "autrement dit", "avant que", "avant tout", "ayant fini", "bien que", "c'est à dire que", "c'est ainsi que", "c'est dans ce but que", "c'est dire", "c'est le cas de", "c'est pour cela que", "c'est la raison pour laquelle", "c'est pourquoi", "c'est qu'en effet", "c'est-à-dire", "ça confirme que", "ça montre que", "ça prouve que", "cela étant", "cela dit", "cependant que", "compte tenu", "comme l'illustre", "comme le souligne", "comme on pouvait s'y attendre", "comme quoi", "comme si", "commençons par examiner", "comparativement à", "conformément à", "contrairement à", "considérons par exemple", "d'autant plus", "d'autant que", "d'autre part", "d'ici là", "d'où", "d'un autre côté", "d'un côté", "d'une façon générale", "dans ce cas", "dans ces conditions", "dans cet esprit", "dans l'ensemble", "dans l'état actuel des choses", "dans l'éventualité où", "dans l'hypothèse où", "dans la mesure où", "dans le but de", "dans le cadre de", "dans le cas où", "dans les circonstances actuelles", "dans les grandes lignes", "dans un autre ordre d'idée", "dans un délai de", "de ce fait", "de cette façon", "de crainte que", "de façon à", "de façon à ce que", "de façon que", "de fait", "de l'autre côté", "de la même manière", "de la même façon que", "de manière que", "de même", "de même qu'à", "de même que", "de nos jours", "de peur que", "de prime abord", "de sorte que", "de surcroît", "de telle manière que", "de telle sorte que", "de toute évidence", "de toute façon", "de toute manière", "depuis que", "dès lors que", "dès maintenant", "dès qua", "dès que", "du fait que", "du moins", "du moment que", "du point de vue de", "du reste", "d'ici là", "d'ores et déjà", "en admettant que", "en attendant que", "en bref", "en cas de", "en cas que", "en ce cas", "en ce domaine", "en ce moment", "en ce qui a trait à", "en ce qui concerne", "en ce sens", "en cela", "en concequence", "en comparaison de", "en concequence", "en conclusion", "en conformité avec", "en conséquence", "en d'autres termes", "en définitive", "en dépit de", "en dernier lieu", "en deuxième lieu", "en effet", "en face de", "en fait", "en fin de compte", "en général", "en guise de conclusion", "en matière de", "en même temps que", "en outre", "en particulier", "en plus", "en premier lieu", "en principe", "en raison de", "en réalité", "en règle générale", "en résumé", "en revanche", "en second lieu", "en somme", "en sorte que", "en supposant que", "en tant que", "en terminant", "en théorie", "en tout cas", "en tout premier lieu", "en troisième lieu", "en un mot", "en vérité", "en vue que", "encore que", "encore une fois", "entre autres", "et même", "et puis", "étant donné qu'a", "étant donné qua", "étant donné que", "face à", "grâce à", "il est à noter que", "il est indéniable que", "il est question de", "il est vrai que", "il faut dire aussi que", "il faut reconnaître que", "il faut souligner que", "il ne faut pas oublier que", "il s'ensuit que", "il suffit de prendre pour exemple", "jusqu'ici", "il y a aussi", "jusqu'à ce que", "jusqu'à ce jour", "jusqu'à maintenant", "jusqu'à présent", "jusqu'au moment où", "jusqu'ici", "l'aspect le plus important de", "l'exemple le plus significatif", "jusqu'au moment où", "la preuve c'est que", "loin que", "mais en réalité", "malgré cela", "malgré tout", "même si", "mentionnons que", "mis à part le fait que", "notons que", "nul doute que", "ou bien", "outre cela", "où que", "par ailleurs", "par conséquent", "par contre", "par exception", "par exemple", "par la suite", "par l'entremise de", "par l'intermédiaire de", "par rapport à", "par suite", "par suite de", "par surcroît", "parce que", "pareillement", "partant de ce fait", "pas du tout", "pendant que", "plus précisément", "plus tard", "pour ainsi dire", "pour autant que", "pour ce qui est de", "pour ces motifs", "pour ces raisons", "pour cette raison", "pour commencer", "pour conclure", "pour le moment", "pour marquer la causalité", "pour l'instant", "pour peu que", "pour prendre un autre exemple", "pour que", "pour résumé", "pour terminer", "pour tout dire", "pour toutes ces raisons", "pourvu que", "prenons le cas de", "quand bien même que", "quand même", "quant à", "quel que soit", "qui plus est", "qui que", "quitte à", "quoi qu'il en soit", "quoi que", "quoiqu'il en soit", "sans délai", "sans doute", "sans parler de", "sans préjuger", "sans tarder", "sauf si", "selon que", "si bien que", "si ce n'est que", "si l'on songe que", "sitôt que", "somme toute", "sous cette réserve", "sous prétexte que", "sous réserve de", "sous réserve que", "suivant que", "supposé que", "sur le plan de", "tandis que", "tant et si bien que", "tant que", "tel que", "tellement que", "touchant à", "tout à fait", "tout bien pesé", "tout compte fait", "tout d'abord", "tout d'abord examinons", "tout d'abord il faut dire que", "tout de même", "tout en reconnaissant que", "une fois de plus", "vu que"]; module.exports = function () { return { singleWords: singleWords, multipleWords: multipleWords, allWords: singleWords.concat(multipleWords) }; }; }), (function (module, exports, __webpack_require__) { "use strict"; var singleWords = ["además", "adicional", "así", "asimismo", "aún", "aunque", "ciertamente", "como", "concluyendo", "conque", "contrariamente", "cuando", "decididamente", "decisivamente", "después", "diferentemente", "efectivamente", "entonces", "especialmente", "específicamente", "eventualmente", "evidentemente", "finalmente", "frecuentemente", "generalmente", "igualmente", "lógicamente", "luego", "mas", "mientras", "pero", "por", "porque", "posteriormente", "primero", "principalmente", "pronto", "próximamente", "pues", "raramente", "realmente", "seguidamente", "segundo", "semejantemente", "si", "siguiente", "sino", "súbitamente", "supongamos", "también", "tampoco", "tercero", "verbigracia", "vice-versa", "ya"]; var multipleWords = ["a causa de", "a continuación", "a diferencia de", "a fin de cuentas", "a la inversa", "a la misma vez", "a más de", "a más de esto", "a menos que", "a no ser que", "a pesar de", "a pesar de eso", "a pesar de todo", "a peser de", "a propósito", "a saber", "a todo esto", "ahora bien", "al contrario", "al fin y al cabo", "al final", "al inicio", "al mismo tiempo", "al principio", "ante todo", "antes bien", "antes de", "antes de nada", "antes que nada", "aparte de", "as así como", "así como", "así mismo", "así pues", "así que", "así y todo", "aún así", "claro está que", "claro que", "claro que sí", "como caso típico", "como decíamos", "como era de esperar", "como es de esperar", "como muestra", "como resultado", "como se ha notado", "como sigue", "comparado con", "con el objeto de", "con el propósito de", "con que", "con relación a", "con tal de que", "con todo", "dado que", "de ahí", "de cierta manera", "de cualquier manera", "de cualquier modo", "de ello resulta que", "de este modo", "de golpe", "de hecho", "de igual manera", "de igual modo", "de igualmanera", "de la manera siguiente", "de la misma forma", "de la misma manera", "de manera semejante", "del mismo modo", "de modo que", "de nuevo", "de otra manera", "de otro modo", "de pronto", "de qualquier manera", "de repente", "de suerte que", "de tal modo", "de todas formas", "de todas maneras", "de todos modos", "de veras", "debido a", "debido a que", "del mismo modo", "dentro de poco", "desde entonces", "después de", "después de todo", "ejemplo de esto", "el caso es que", "en aquel tiempo", "en cambio", "en cierto modo", "en comparación con", "en conclusión", "en concreto", "en conformidad con", "en consecuencia", "en consiguiente", "en contraste con", "en cualquier caso", "en cuanto", "en cuanto a", "en definitiva", "en efecto", "en el caso de que", "en este sentido", "en fin", "en fin de cuentas", "en general", "en lugar de", "en otras palabras", "en otro orden", "en otros términos", "en particular", "en primer lugar", "en primer término", "en primera instancia", "en realidad", "en relación a", "en relación con", "en representación de", "en resumen", "en resumidas cuentas", "en segundo lugar", "en seguida", "en síntesis", "en suma", "en todo caso", "en último término", "en verdad", "en vez de", "en virtud de", "entre ellas figura", "entre ellos figura", "es cierto que", "es decir", "es evidente que", "es incuestionable", "es indudable", "es más", "está claro que", "esto indica", "excepto si", "generalmente por ejemplo", "gracias a", "hasta aquí", "hasta cierto punto", "hasta el momento", "hay que añadir", "igual que", "la mayor parte del tiempo", "la mayoría del tiempo", "lo que es peor", "más tarde", "mejor dicho", "mientras tanto", "mirándolo todo", "nadie puede ignorar", "no faltaría más", "no obstante", "o sea", "otra vez", "otro aspecto", "par ilustrar", "para concluir", "para conclusión", "para continuar", "para empezar", "para finalizar", "para mencionar una cosa", "para que", "para resumir", "para terminar", "pongamos por caso", "por añadidura", "por cierto", "por consiguiente", "por ejemplo", "por el consiguiente", "por el contrario", "por el hecho que", "por eso", "por esta razón", "por esto", "por fin", "por la mayor parte", "por lo general", "por lo que", "por lo tanto", "por otro lado", "por otra parte", "por otro lado", "por supuesto", "por tanto", "por último", "por un lado", "por una parte", "primero que nada", "primero que todo", "pues bien", "puesto que", "rara vez", "resulta que", "sea como sea", "seguidamente entre tanto", "si bien", "siempre que", "siempre y cuando", "sigue que", "sin duda", "sin embargo", "sin ir más lejos", "sobre todo", "supuesto que", "tal como", "tales como", "tan pronto como", "tanto como", "una vez", "ya que"]; module.exports = function () { return { singleWords: singleWords, multipleWords: multipleWords, allWords: singleWords.concat(multipleWords) }; }; }), (function (module, exports, __webpack_require__) { "use strict"; var singleWords = ["aangezien", "al", "aldus", "allereerst", "als", "alsook", "anderzijds", "bijgevolg", "bijvoorbeeld", "bovendien", "concluderend", "daardoor", "daarentegen", "daarmee", "daarna", "daarnaast", "daarom", "daartoe", "daarvoor", "dadelijk", "dan", "desondanks", "dienovereenkomstig", "dientegevolge", "doch", "doordat", "dus", "echter", "eerst", "evenals", "eveneens", "evenzeer", "hierom", "hoewel", "immers", "indien", "integendeel", "intussen", "kortom", "later", "maar", "mits", "nadat", "namelijk", "net als", "niettemin", "noch", "ofschoon", "omdat", "ondanks", "ondertussen", "ook", "opdat", "resumerend", "samengevat", "samenvattend", "tegenwoordig", "teneinde", "tenzij", "terwijl", "tevens", "toch", "toen", "uiteindelijk", "vanwege", "vervolgens", "voorafgaand", "vooralsnog", "voordat", "voorts", "vroeger", "waardoor", "waarmee", "waaronder", "wanneer", "want", "zoals", "zodat", "zodoende", "zodra"]; var multipleWords = ["aan de andere kant", "aan de ene kant", "aangenomen dat", "al met al", "alles afwegend", "alles bij elkaar", "alles in aanmerking nemend", "als gevolg van", "anders gezegd", "daar staat tegenover", "daarbij komt", "daaruit volgt", "dat betekent", "dat blijkt uit", "de oorzaak daarvan is", "de oorzaak hiervan is", "door middel van", "een voorbeeld hiervan", "een voorbeeld van", "gesteld dat", "hetzelfde als", "hieruit kunnen we afleiden", "hieruit volgt", "hoe het ook zij", "in de derde plaats", "in de eerste plaats", "in de tweede plaats", "in één woord", "in het bijzonder", "in het geval dat", "in plaats van", "in tegenstelling tot", "in vergelijking met", "maar ook", "met als doel", "met andere woorden", "met behulp van", "met de bedoeling", "neem nou", "net als", "om kort te gaan", "onder andere", "op dezelfde wijze", "stel dat", "te danken aan", "te wijten aan", "ten derde", "ten eerste", "ten gevolge van", "ten slotte", "ten tweede", "ter conclusie", "ter illustratie", "ter verduidelijking", "tot nog toe", "tot slot", "vandaar dat", "vergeleken met", "voor het geval dat"]; module.exports = function () { return { singleWords: singleWords, multipleWords: multipleWords, allWords: singleWords.concat(multipleWords) }; }; }), (function (module, exports, __webpack_require__) { "use strict"; var singleWords = ["abbastanza", "acciocché", "acciocchè", "adesso", "affinché", "affinchè", "allora", "almeno", "alquanto", "altrettanto", "altrimenti", "analogamente", "anche", "ancora", "antecedentemente", "anzi", "anzitutto", "apertamente", "appena", "assai", "attualmente", "benché", "benchè", "beninteso", "bensì", "brevemente", "bruscamente", "casomai", "celermente", "certamente", "certo", "chiaramente", "ciononostante", "cioé", "cioè", "comparabilmente", "come", "complessivamente", "completamente", "comunque", "concisamente", "concludendo", "conformemente", "congiuntamente", "conseguentemente", "considerando", "considerato", "considerevolmente", "contemporaneamente", "continuamente", "contrariamente", "controbilanciato", "così", "cosicché", "cosicchè", "dapprima", "dato", "davvero", "definitivamente", "dettagliatamente", "differentemente", "diversamente", "dopo", "dopodiché", "dopodichè", "durante", "dunque", "eccetto", "eccome", "effettivamente", "egualmente", "elencando", "enfaticamente", "eppure", "esaurientemente", "esplicitamente", "espressamente", "estesamente", "evidentemente", "finalmente", "finché", "finchè", "fino", "finora", "fintanto", "fintanto che", "fintantoché", "fintantochè", "fondamentalmente", "frattanto", "frequentemente", "generalmente", "già", "gradualmente", "illustrando", "immantinente", "immediatamente", "importantissimo", "incontestabilmente", "incredibilmente", "indipendentemente", "indiscutibilmente", "indubbiamente", "infatti", "infine", "innanzitutto", "innegabilmente", "inoltre", "insomma", "intanto", "interamente", "istantaneamente", "invece", "logicamente", "lentamente", "ma", "malgrado", "marcatamente", "memorabile", "mentre", "motivatamente", "naturalmente", "né", "nè", "neanche", "neppure", "nonché", "nonchè", "nondimeno", "nonostante", "notevolmente", "occasionalmente", "oltretutto", "onde", "onestamente", "ossia", "ostinatamente", "ovvero", "ovviamente", "parimenti", "particolarmente", "peraltro", "perché", "perchè", "perciò", "perlomeno", "però", "pertanto", "pesantemente", "piuttosto", "poi", "poiché", "poichè", "praticamente", "precedentemente", "preferibilmente", "precisamente", "prematuramente", "presto", "prima", "primariamente", "primo", "principalmente", "prontamente", "proporzionalmente", "pure", "purché", "purchè", "quando", "quanto", "quantomeno", "quindi", "raramente", "realmente", "relativamente", "riassumendo", "riformulando", "ripetutamente", "saltuariamente", "schiettamente", "sebbene", "secondariamente", "secondo", "sempre", "sennò", "seguente", "sensibilmente", "seppure", "seriamente", "siccome", "sicuramente", "significativamente", "similmente", "simultaneamente", "singolarmente", "sinteticamente", "solitamente", "solo", "soltanto", "soprattutto", "sopravvalutato", "sorprendentemente", "sostanzialmente", "sottolineando", "sottovalutato", "specialmente", "specificamente", "specificatamente", "subitamente", "subito", "successivamente", "successivo", "talmente", "terzo", "totalmente", "tranne", "tuttavia", "ugualmente", "ulteriormente", "ultimamente", "veramente", "verosimilmente", "visto"]; var multipleWords = ["a breve", "a causa", "a causa di", "a condizione che", "a conseguenza", "a conti fatti", "a differenza di", "a differenza del", "a differenza della", "a differenza dei", "a differenza degli", "a differenza delle", "a dire il vero", "a dire la verità", "a dirla tutta", "a dispetto di", "a lungo", "a lungo termine", "a maggior ragione", "a meno che non", "a parte", "a patto che", "a prescindere", "a prima vista", "a proposito", "a qualunque costo", "a quanto", "a quel proposito", "a quel tempo", "a quell'epoca", "a questo fine", "a questo proposito", "a questo punto", "a questo riguardo", "a questo scopo", "a riguardo", "a seguire", "a seguito", "a sottolineare", "a tal fine", "a tal proposito", "a tempo debito", "a tutti gli effetti", "a tutti i costi", "a una prima occhiata", "ad eccezione di", "ad esempio", "ad essere maliziosi", "ad essere sinceri", "ad ogni buon conto", "ad ogni costo", "ad ogni modo", "ad una prima occhiata", "adesso che", "al che", "al contrario", "al contrario di", "al fine di", "al fine di fare", "al giorno d'oggi", "al momento", "al momento giusto", "al momento opportuno", "al più presto", "al posto di", "al suo posto", "al termine", "all'epoca", "all'infuori di", "all'inizio", "all'opposto", "all'ultimo", "alla fine", "alla fine della fiera", "alla luce", "alla luce di", "alla lunga", "alla moda", "alla stessa maniera", "allo scopo di", "allo stesso modo", "allo stesso tempo", "anch'esso", "anch'io", "anche se", "ancora più", "ancora di più", "assumendo che", "bisogna chiarire che", "bisogna considerare che", "causato da", "ciò nondimeno", "ciò nonostante", "col tempo", "con il tempo", "come a dire", "come abbiamo dimostrato", "come è stato notato", "come è stato detto", "come è stato dimostrato", "come hanno detto", "come ho detto", "come ho dimostrato", "come ho notato", "come potete notare", "come potete vedere", "come puoi notare", "come puoi vedere", "come si è dimostrato", "come si può vedere", "come si può notare", "come sopra indicato", "comunque sia", "con attenzione", "con enfasi", "con il risultato che", "con l'obiettivo di", "con ostinazione", "con questa intenzione", "con questa idea", "con queste idee", "con questo in testa", "con questo scopo", "così che", "così da", "d'altra parte", "d'altro canto", "d'altro lato", "d'altronde", "d'ora in avanti", "d'ora in poi", "da allora", "da quando", "da quanto", "da quel momento", "da quella volta", "da questo momento in poi", "da questo momento", "da qui", "da ultimo", "da un certo punto di vista", "da un lato", "da una parte", "dall'altro lato", "dall'epoca", "dal che", "dato che", "dato per assunto che", "davanti a", "del tutto", "dell'epoca", "detto questo", "di certo", "di colpo", "di conseguenza", "di fatto", "di fronte", "di fronte a", "di lì a poco", "di punto in bianco", "di quando in quando", "di quanto non sia", "di quel tempo", "di qui a", "di rado", "di seguito", "di si", "di sicuro", "di solito", "di tanto in tanto", "di tutt'altra pasta", "di quando in quando", "differente da", "diversamente da", "diverso da", "dopotutto", "dovuto a", "e anche", "e inoltre", "entro breve", "fermo restando che", "faccia a faccia", "fin da", "fin dall'inizio", "fin quando", "finché non", "finchè non", "fin dal primo momento", "fin dall'inizio", "fino a", "fino a questo momento", "fino ad oggi", "fino ai giorni nostri", "fino adesso", "fino a un certo punto", "fino adesso", "fra quanto", "il prima possibile", "in aggiunta", "in altre parole", "in altri termini", "in ambo i casi", "in breve", "in caso di", "in conclusione", "in conformità", "in confronto", "in confronto a", "in conseguenza", "in considerazione", "in considerazione di", "in definitiva", "in dettaglio", "importante rendersi conto", "in effetti", "in entrambi i casi", "in fin dei conti", "in generale", "in genere", "in linea di massima", "in poche parole", "il più possibile", "in maggior parte", "in maniera analoga", "in maniera convincente", "in maniera esauriente", "in maniera esaustiva", "in maniera esplicita", "in maniera evidente", "in maniera incontestabile", "in maniera indiscutibile", "in maniera innegabile", "in maniera significativa", "in maniera simile", "in modo allusivo", "in modo analogo", "in modo che", "in modo convincente", "in modo da", "in modo identico", "in modo notevole", "in modo significativo", "in modo significativo", "in modo simile", "in ogni caso", "in ogni modo", "in ogni momento", "in parte considerevole", "in parti uguali", "in particolare", "in particolare per", "in particolare", "in più", "in pratica", "in precedenza", "in prima battuta", "in prima istanza", "in primo luogo", "in rapporto", "in qualche modo", "in qualsiasi modo", "in qualsiasi momento", "in qualunque modo", "in qualunque momento", "in quarta battuta", "in quarta istanza", "in quarto luogo", "in quel caso", "in quelle circostanze", "in questa occasione", "in questa situazione", "in questo caso", "in questo caso particolare", "in questo istante", "in questo momento", "in rare occasioni", "in realtà", "in seconda battuta", "in seconda istanza", "in secondo luogo", "in seguito", "in sintesi", "in sostanza", "in tempo", "in terza battuta", "in terza istanza", "in terzo luogo", "in totale", "in tutto", "in ugual maniera", "in ugual misura", "in ugual modo", "in ultima analisi", "in ultima istanza", "in un altro caso", "in una parola", "in verità", "insieme a", "insieme con", "invece che", "invece di", "la prima cosa da considerare", "la prima cosa da tenere a mente", "lo stesso", "mentre potrebbe essere vero", "motivo per cui", "motivo per il quale", "ne consegue che", "ne deriva che", "nei dettagli", "nel caso", "nel caso che", "nel caso in cui", "nel complesso", "nel corso del", "nel corso di", "nel frattempo", "nel lungo periodo", "nel mentre", "nell'eventualità che", "nella misura in cui", "nella speranza che", "nella stessa maniera", "nella stessa misura", "nello specifico", "nello stesso modo", "nello stesso momento", "nello stesso stile", "non appena", "non per essere maliziosi", "non più da", "nonostante ciò", "nonostante tutto", "ogni qualvolta", "ogni tanto", "ogni volta", "oltre a", "oltre a ciò", "ora che", "passo dopo passo", "per causa di", "per certo", "per chiarezza", "per chiarire", "per come", "per concludere", "per conto di", "per contro", "per cui", "per davvero", "per di più", "per dirla in altro modo", "per dirla meglio", "per dirla tutta", "per es.", "per esempio", "per essere sinceri", "per far vedere", "per farla breve", "per finire", "per l'avvenire", "per l'ultima volta", "per la maggior parte", "per la stessa ragione", "per la verità", "per lo più", "per mettere in luce", "per metterla in altro modo", "per non dire di", "per non parlare di", "per ora", "per ovvi motivi", "per paura di", "per paura dei", "per paura delle", "per paura degli", "per prima cosa", "per quanto", "per questa ragione", "per questo motivo", "per riassumere", "per sottolineare", "per timore", "per trarre le conclusioni", "per ultima", "per ultime", "per ultimi", "per ultimo", "per via di", "perché si", "perchè si", "perfino se", "piano piano", "più di ogni altra cosa", "più di tutto", "più facilmente", "più importante", "più tardi", "poco a poco", "poco dopo", "prendiamo il caso di", "presto o tardi", "prima che", "prima di", "prima di ogni cosa", "prima di tutto", "prima o dopo", "prima o poi", "questo è probabilmente vero", "questo potrebbe essere vero", "restando inteso che", "riassumendo", "quanto prima", "questa volta", "se confrontato con", "se e solo se", "se no", "seduta stante", "sempreché", "semprechè", "sempre che", "senz'altro", "senza alcun riguardo", "senza dubbio", "senz'ombra di dubbio", "senza ombra di dubbio", "senza riguardo per", "senza tregua", "senza ulteriore ritardo", "sia quel che sia", "solo se", "sotto questa luce", "sperando che", "sta volta", "su tutto", "subito dopo", "sul serio", "tanto per cominciare", "tanto quanto", "tra breve", "tra l'altro", "tra poco", "tra quanto", "tutte le volte", "tutti insieme", "tutto a un tratto", "tutto ad un tratto", "tutto d'un tratto", "tutto considerato", "tutto sommato", "un passo alla volta", "un tempo", "una volta", "una volta ogni tanto", "unito a", "va chiarito che", "va considerato che", "vada come vada", "vale a dire", "visto che"]; module.exports = function () { return { singleWords: singleWords, multipleWords: multipleWords, allWords: singleWords.concat(multipleWords) }; }; }), (function (module, exports, __webpack_require__) {
        var baseValues = __webpack_require__(386), keys = __webpack_require__(26); function values(object) { return object == null ? [] : baseValues(object, keys(object)); }
        module.exports = values;
    }), (function (module, exports, __webpack_require__) { "use strict"; var SentencePart = function SentencePart(sentencePartText, auxiliaries, locale) { this._sentencePartText = sentencePartText; this._auxiliaries = auxiliaries; this._locale = locale; this._isPassive = false; }; SentencePart.prototype.getSentencePartText = function () { return this._sentencePartText; }; SentencePart.prototype.isPassive = function () { return this._isPassive; }; SentencePart.prototype.getAuxiliaries = function () { return this._auxiliaries; }; SentencePart.prototype.getLocale = function () { return this._locale; }; SentencePart.prototype.setPassive = function (passive) { this._isPassive = passive; }; module.exports = SentencePart; }), (function (module, exports, __webpack_require__) {
        "use strict"; var getWords = __webpack_require__(27); var regexFunction = __webpack_require__(391)(); var regularParticiples = regexFunction.regularParticiples; var irregularParticiples = regexFunction.irregularParticiples; var EnglishParticiple = __webpack_require__(393); var forEach = __webpack_require__(1); module.exports = function (sentencePartText, auxiliaries) {
            var words = getWords(sentencePartText); var foundParticiples = []; forEach(words, function (word) {
                var type = ""; if (regularParticiples(word).length !== 0) { type = "regular"; }
                if (irregularParticiples(word).length !== 0) { type = "irregular"; }
                if (type !== "") { foundParticiples.push(new EnglishParticiple(word, sentencePartText, { auxiliaries: auxiliaries, type: type })); }
            }); return foundParticiples;
        };
    }), (function (module, exports, __webpack_require__) {
        "use strict"; var getType = __webpack_require__(189).getType; var isSameType = __webpack_require__(189).isSameType; var defaults = __webpack_require__(110); var forEach = __webpack_require__(1); var defaultAttributes = { auxiliaries: [], type: "" }; var validateAttributes = function validateAttributes(attributes) { forEach(attributes, function (attributeValue, attributeName) { var expectedType = getType(defaultAttributes[attributeName]); if (isSameType(attributeValue, expectedType) === false) { throw Error("Attribute " + attributeName + " has invalid type. Expected " + expectedType + ", got " + getType(attributeValue) + "."); } }); }; var Participle = function Participle(participle, sentencePart, attributes) { this.setParticiple(participle); this.setSentencePart(sentencePart); this._determinesSentencePartIsPassive = false; attributes = attributes || {}; defaults(attributes, defaultAttributes); validateAttributes(attributes); this._attributes = attributes; }; Participle.prototype.setParticiple = function (participle) {
            if (participle === "") { throw Error("The participle should not be empty."); }
            this._participle = participle;
        }; Participle.prototype.getParticiple = function () { return this._participle; }; Participle.prototype.setSentencePart = function (sentencePart) {
            if (sentencePart === "") { throw Error("The sentence part should not be empty."); }
            this._sentencePart = sentencePart;
        }; Participle.prototype.getSentencePart = function () { return this._sentencePart; }; Participle.prototype.getType = function () { return this._attributes.type; }; Participle.prototype.getAuxiliaries = function () { return this._attributes.auxiliaries; }; Participle.prototype.determinesSentencePartIsPassive = function () { return this._determinesSentencePartIsPassive; }; Participle.prototype.setSentencePartPassiveness = function (passive) {
            if (!isSameType(passive, "boolean")) { throw Error("Passiveness had invalid type. Expected boolean, got " + getType(passive) + "."); }
            this._determinesSentencePartIsPassive = passive;
        }; module.exports = Participle;
    }), (function (module, exports, __webpack_require__) {
        "use strict"; var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; var getType = function getType(subject) {
            if (Array.isArray(subject)) { return "array"; }
            return typeof subject === "undefined" ? "undefined" : _typeof(subject);
        }; var isSameType = function isSameType(subject, expectedType) { var passedType = getType(subject); return passedType === expectedType; }; module.exports = { getType: getType, isSameType: isSameType };
    }), (function (module, exports, __webpack_require__) { var arrayMap = __webpack_require__(24), baseIntersection = __webpack_require__(398), baseRest = __webpack_require__(39), castArrayLikeObject = __webpack_require__(399); var intersection = baseRest(function (arrays) { var mapped = arrayMap(arrays, castArrayLikeObject); return (mapped.length && mapped[0] === arrays[0]) ? baseIntersection(mapped) : []; }); module.exports = intersection; }), (function (module, exports, __webpack_require__) { "use strict"; var forEach = __webpack_require__(1); module.exports = function (participles) { var passive = false; forEach(participles, function (participle) { if (participle.determinesSentencePartIsPassive()) { passive = true; return; } }); return passive; }; }), (function (module, exports, __webpack_require__) {
        "use strict"; var getWords = __webpack_require__(27); var regexFunction = __webpack_require__(405)(); var verbsBeginningWithErVerEntBeZerHerUber = regexFunction.verbsBeginningWithErVerEntBeZerHerUber; var verbsBeginningWithGe = regexFunction.verbsBeginningWithGe; var verbsWithGeInMiddle = regexFunction.verbsWithGeInMiddle; var verbsWithErVerEntBeZerHerUberInMiddle = regexFunction.verbsWithErVerEntBeZerHerUberInMiddle; var verbsEndingWithIert = regexFunction.verbsEndingWithIert; var irregularParticiples = __webpack_require__(406)(); var GermanParticiple = __webpack_require__(407); var forEach = __webpack_require__(1); var includes = __webpack_require__(29); module.exports = function (sentencePartText, auxiliaries) {
            var words = getWords(sentencePartText); var foundParticiples = []; forEach(words, function (word) {
                if (verbsBeginningWithGe(word).length !== 0) { foundParticiples.push(new GermanParticiple(word, sentencePartText, { auxiliaries: auxiliaries, type: "ge at beginning" })); return; }
                if (verbsWithGeInMiddle(word).length !== 0) { foundParticiples.push(new GermanParticiple(word, sentencePartText, { auxiliaries: auxiliaries, type: "ge in the middle" })); return; }
                if (verbsBeginningWithErVerEntBeZerHerUber(word).length !== 0) { foundParticiples.push(new GermanParticiple(word, sentencePartText, { auxiliaries: auxiliaries, type: "er/ver/ent/be/zer/her at beginning" })); return; }
                if (verbsWithErVerEntBeZerHerUberInMiddle(word).length !== 0) { foundParticiples.push(new GermanParticiple(word, sentencePartText, { auxiliaries: auxiliaries, type: "er/ver/ent/be/zer/her in the middle" })); return; }
                if (verbsEndingWithIert(word).length !== 0) { foundParticiples.push(new GermanParticiple(word, sentencePartText, { auxiliaries: auxiliaries, type: "iert at the end" })); }
                if (includes(irregularParticiples, word)) { foundParticiples.push(new GermanParticiple(word, sentencePartText, { auxiliaries: auxiliaries, type: "irregular" })); }
            }); return foundParticiples;
        };
    }), (function (module, exports, __webpack_require__) {
        var baseHas = __webpack_require__(421), hasPath = __webpack_require__(143); function has(object, path) { return object != null && hasPath(object, path, baseHas); }
        module.exports = has;
    }), (function (module, exports, __webpack_require__) {
        "use strict"; var AssessmentResult = __webpack_require__(0); var calculateFirstParagraphResult = function calculateFirstParagraphResult(firstParagraphMatches, i18n) {
            if (firstParagraphMatches > 0) { return { score: 9, text: i18n.dgettext("js-text-analysis", "The focus keyword appears in the first paragraph of the copy.") }; }
            return { score: 3, text: i18n.dgettext("js-text-analysis", "The focus keyword doesn\'t appear in the first paragraph of the copy. " + "Make sure the topic is clear immediately.") };
        }; var introductionHasKeywordAssessment = function introductionHasKeywordAssessment(paper, researcher, i18n) { var firstParagraphMatches = researcher.getResearch("firstParagraph"); var firstParagraphResult = calculateFirstParagraphResult(firstParagraphMatches, i18n); var assessmentResult = new AssessmentResult(); assessmentResult.setScore(firstParagraphResult.score); assessmentResult.setText(firstParagraphResult.text); return assessmentResult; }; module.exports = { identifier: "introductionKeyword", getResult: introductionHasKeywordAssessment, isApplicable: function isApplicable(paper) { return paper.hasKeyword(); } };
    }), (function (module, exports, __webpack_require__) {
        "use strict"; var AssessmentResult = __webpack_require__(0); function keyphraseAssessment(paper, researcher, i18n) {
            var keyphraseLength = researcher.getResearch("keyphraseLength"); var assessmentResult = new AssessmentResult(); if (!paper.hasKeyword()) { assessmentResult.setScore(-999); assessmentResult.setText(i18n.dgettext("js-text-analysis", "No focus keyword was set for this page. " + "If you do not set a focus keyword, no score can be calculated.")); } else if (keyphraseLength > 10) { assessmentResult.setScore(0); assessmentResult.setText(i18n.dgettext("js-text-analysis", "The keyphrase is over 10 words, a keyphrase should be shorter.")); }
            return assessmentResult;
        }
        module.exports = { identifier: "keyphraseLength", getResult: keyphraseAssessment };
    }), (function (module, exports, __webpack_require__) {
        "use strict"; var AssessmentResult = __webpack_require__(0); var matchWords = __webpack_require__(28); var countWords = __webpack_require__(23); var formatNumber = __webpack_require__(52); var inRange = __webpack_require__(30); var inRangeEndInclusive = inRange.inRangeEndInclusive; var inRangeStartInclusive = inRange.inRangeStartInclusive; var inRangeStartEndInclusive = inRange.inRangeStartEndInclusive; var calculateKeywordDensityResult = function calculateKeywordDensityResult(keywordDensity, i18n, keywordCount) {
            var score, text, max; var roundedKeywordDensity = formatNumber(keywordDensity); var keywordDensityPercentage = roundedKeywordDensity + "%"; if (roundedKeywordDensity > 3.5) { score = -50; text = i18n.dgettext("js-text-analysis", "The keyword density is %1$s," + " which is way over the advised %3$s maximum;" + " the focus keyword was found %2$d times."); max = "2.5%"; text = i18n.sprintf(text, keywordDensityPercentage, keywordCount, max); }
            if (inRangeEndInclusive(roundedKeywordDensity, 2.5, 3.5)) { score = -10; text = i18n.dgettext("js-text-analysis", "The keyword density is %1$s," + " which is over the advised %3$s maximum;" + " the focus keyword was found %2$d times."); max = "2.5%"; text = i18n.sprintf(text, keywordDensityPercentage, keywordCount, max); }
            if (inRangeStartEndInclusive(roundedKeywordDensity, 0.5, 2.5)) { score = 9; text = i18n.dgettext("js-text-analysis", "The keyword density is %1$s, which is great;" + " the focus keyword was found %2$d times."); text = i18n.sprintf(text, keywordDensityPercentage, keywordCount); }
            if (inRangeStartInclusive(roundedKeywordDensity, 0, 0.5)) { score = 4; text = i18n.dgettext("js-text-analysis", "The keyword density is %1$s, which is too low;" + " the focus keyword was found %2$d times."); text = i18n.sprintf(text, keywordDensityPercentage, keywordCount); }
            return { score: score, text: text };
        }; var keywordDensityAssessment = function keywordDensityAssessment(paper, researcher, i18n) { var keywordDensity = researcher.getResearch("getKeywordDensity"); var keywordCount = matchWords(paper.getText(), paper.getKeyword(), paper.getLocale()); var keywordDensityResult = calculateKeywordDensityResult(keywordDensity, i18n, keywordCount); var assessmentResult = new AssessmentResult(); assessmentResult.setScore(keywordDensityResult.score); assessmentResult.setText(keywordDensityResult.text); return assessmentResult; }; module.exports = { identifier: "keywordDensity", getResult: keywordDensityAssessment, isApplicable: function isApplicable(paper) { return paper.hasText() && paper.hasKeyword() && countWords(paper.getText()) >= 100; } };
    }), (function (module, exports, __webpack_require__) {
        "use strict"; var AssessmentResult = __webpack_require__(0); var getLanguageAvailability = __webpack_require__(40); var availableLanguages = ["en"]; var calculateStopWordsCountResult = function calculateStopWordsCountResult(stopWordCount, i18n) {
            if (stopWordCount > 0) { return { score: 0, text: i18n.dngettext("js-text-analysis", "The focus keyword contains a stop word. This may or may not be wise depending on the circumstances. " + "%1$sLearn more about the stop words%2$s.", "The focus keyword contains %3$d stop words. This may or may not be wise depending on the circumstances. " + "%1$sLearn more about the stop words%2$s.", stopWordCount) }; }
            return {};
        }; var keywordHasStopWordsAssessment = function keywordHasStopWordsAssessment(paper, researcher, i18n) { var stopWords = researcher.getResearch("stopWordsInKeyword"); var stopWordsResult = calculateStopWordsCountResult(stopWords.length, i18n); var assessmentResult = new AssessmentResult(); assessmentResult.setScore(stopWordsResult.score); assessmentResult.setText(i18n.sprintf(stopWordsResult.text, "<a href='https://yoa.st/stopwords/' target='_blank'>", "</a>", stopWords.length)); return assessmentResult; }; module.exports = { identifier: "keywordStopWords", getResult: keywordHasStopWordsAssessment, isApplicable: function isApplicable(paper) { var isLanguageAvailable = getLanguageAvailability(paper.getLocale(), availableLanguages); return paper.hasKeyword() && isLanguageAvailable; } };
    }), (function (module, exports, __webpack_require__) {
        "use strict"; var AssessmentResult = __webpack_require__(0); var calculateKeywordMatchesResult = function calculateKeywordMatchesResult(keywordMatches, i18n) {
            if (keywordMatches > 0) { return { score: 9, text: i18n.dgettext("js-text-analysis", "The meta description contains the focus keyword.") }; }
            if (keywordMatches === 0) { return { score: 3, text: i18n.dgettext("js-text-analysis", "A meta description has been specified, but it does not contain the focus keyword.") }; }
            return {};
        }; var metaDescriptionHasKeywordAssessment = function metaDescriptionHasKeywordAssessment(paper, researcher, i18n) { var keywordMatches = researcher.getResearch("metaDescriptionKeyword"); var descriptionLengthResult = calculateKeywordMatchesResult(keywordMatches, i18n); var assessmentResult = new AssessmentResult(); assessmentResult.setScore(descriptionLengthResult.score); assessmentResult.setText(descriptionLengthResult.text); return assessmentResult; }; module.exports = { identifier: "metaDescriptionKeyword", getResult: metaDescriptionHasKeywordAssessment, isApplicable: function isApplicable(paper) { return paper.hasKeyword(); } };
    }), (function (module, exports, __webpack_require__) {
        "use strict"; var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
        function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
        function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
        var AssessmentResult = __webpack_require__(0); var Assessment = __webpack_require__(15); var merge = __webpack_require__(11); var MetaDescriptionLengthAssessment = function (_Assessment) {
            _inherits(MetaDescriptionLengthAssessment, _Assessment); function MetaDescriptionLengthAssessment() { var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {}; _classCallCheck(this, MetaDescriptionLengthAssessment); var _this = _possibleConstructorReturn(this, (MetaDescriptionLengthAssessment.__proto__ || Object.getPrototypeOf(MetaDescriptionLengthAssessment)).call(this)); var defaultConfig = { recommendedMaximumLength: 120, maximumLength: 320, scores: { noMetaDescription: 1, tooLong: 6, tooShort: 6, correctLength: 9 } }; _this.identifier = "metaDescriptionLength"; _this._config = merge(defaultConfig, config); return _this; }
            _createClass(MetaDescriptionLengthAssessment, [{ key: "getResult", value: function getResult(paper, researcher, i18n) { var descriptionLength = researcher.getResearch("metaDescriptionLength"); var assessmentResult = new AssessmentResult(); assessmentResult.setScore(this.calculateScore(descriptionLength)); assessmentResult.setText(this.translateScore(descriptionLength, i18n)); return assessmentResult; } }, {
                key: "calculateScore", value: function calculateScore(descriptionLength) {
                    if (descriptionLength === 0) { return this._config.scores.noMetaDescription; }
                    if (descriptionLength <= this._config.recommendedMaximumLength) { return this._config.scores.tooShort; }
                    if (descriptionLength > this._config.maximumLength) { return this._config.scores.tooLong; }
                    if (descriptionLength >= this._config.recommendedMaximumLength && descriptionLength <= this._config.maximumLength) { return this._config.scores.correctLength; }
                    return 0;
                }
            }, {
                key: "translateScore", value: function translateScore(descriptionLength, i18n) {
                    if (descriptionLength === 0) { return i18n.dgettext("js-text-analysis", "No meta description has been specified. " + "Search engines will display copy from the page instead."); }
                    if (descriptionLength <= this._config.recommendedMaximumLength) { return i18n.sprintf(i18n.dgettext("js-text-analysis", "The meta description is under %1$d characters long. " + "However, up to %2$d characters are available."), this._config.recommendedMaximumLength, this._config.maximumLength); }
                    if (descriptionLength > this._config.maximumLength) { return i18n.sprintf(i18n.dgettext("js-text-analysis", "The meta description is over %1$d characters. " + "Reducing the length will ensure the entire description will be visible."), this._config.maximumLength); }
                    if (descriptionLength >= this._config.recommendedMaximumLength && descriptionLength <= this._config.maximumLength) { return i18n.dgettext("js-text-analysis", "The meta description has a nice length."); }
                }
            }]); return MetaDescriptionLengthAssessment;
        }(Assessment); module.exports = MetaDescriptionLengthAssessment;
    }), (function (module, exports, __webpack_require__) {
        "use strict"; var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
        function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
        function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
        var AssessmentResult = __webpack_require__(0); var Assessment = __webpack_require__(15); var merge = __webpack_require__(11); var SubHeadingsKeywordAssessment = function (_Assessment) {
            _inherits(SubHeadingsKeywordAssessment, _Assessment); function SubHeadingsKeywordAssessment() { var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {}; _classCallCheck(this, SubHeadingsKeywordAssessment); var _this = _possibleConstructorReturn(this, (SubHeadingsKeywordAssessment.__proto__ || Object.getPrototypeOf(SubHeadingsKeywordAssessment)).call(this)); var defaultConfig = { scores: { noMatches: 6, oneMatch: 9, multipleMatches: 9 } }; _this.identifier = "subheadingsKeyword"; _this._config = merge(defaultConfig, config); return _this; }
            _createClass(SubHeadingsKeywordAssessment, [{ key: "getResult", value: function getResult(paper, researcher, i18n) { var subHeadings = researcher.getResearch("matchKeywordInSubheadings"); var assessmentResult = new AssessmentResult(); var score = this.calculateScore(subHeadings); assessmentResult.setScore(score); assessmentResult.setText(this.translateScore(score, subHeadings, i18n)); return assessmentResult; } }, { key: "isApplicable", value: function isApplicable(paper) { return paper.hasText() && paper.hasKeyword(); } }, {
                key: "calculateScore", value: function calculateScore(subHeadings) {
                    if (subHeadings.matches === 0) { return this._config.scores.noMatches; }
                    if (subHeadings.matches === 1) { return this._config.scores.oneMatch; }
                    if (subHeadings.matches > 1) { return this._config.scores.multipleMatches; }
                    return null;
                }
            }, {
                key: "translateScore", value: function translateScore(score, subHeadings, i18n) {
                    if (score === this._config.scores.multipleMatches || score === this._config.scores.oneMatch) { return i18n.sprintf(i18n.dgettext("js-text-analysis", "The focus keyword appears only in %2$d (out of %1$d) subheadings in your copy. " + "Try to use it in at least one more subheading."), subHeadings.count, subHeadings.matches); }
                    if (score === this._config.scores.noMatches) { return i18n.dgettext("js-text-analysis", "You have not used the focus keyword in any subheading (such as an H2) in your copy."); }
                    return "";
                }
            }]); return SubHeadingsKeywordAssessment;
        }(Assessment); module.exports = SubHeadingsKeywordAssessment;
    }), (function (module, exports, __webpack_require__) {
        "use strict"; var AssessmentResult = __webpack_require__(0); var Mark = __webpack_require__(31); var addMark = __webpack_require__(32); var map = __webpack_require__(2); var calculateLinkCountResult = function calculateLinkCountResult(linkStatistics, i18n) {
            if (linkStatistics.keyword.totalKeyword > 0) { return { score: 2, hasMarks: true, text: i18n.dgettext("js-text-analysis", "You\'re linking to another page with the focus keyword you want this page to rank for. " + "Consider changing that if you truly want this page to rank.") }; }
            return {};
        }; var textHasCompetingLinksAssessment = function textHasCompetingLinksAssessment(paper, researcher, i18n) { var linkCount = researcher.getResearch("getLinkStatistics"); var linkCountResult = calculateLinkCountResult(linkCount, i18n); var assessmentResult = new AssessmentResult(); assessmentResult.setScore(linkCountResult.score); assessmentResult.setText(linkCountResult.text); assessmentResult.setHasMarks(linkCountResult.hasMarks); return assessmentResult; }; var competingLinkMarker = function competingLinkMarker(paper, researcher) { var competingLinks = researcher.getResearch("getLinkStatistics"); return map(competingLinks.keyword.matchedAnchors, function (matchedAnchor) { return new Mark({ original: matchedAnchor, marked: addMark(matchedAnchor) }); }); }; module.exports = { identifier: "textCompetingLinks", getResult: textHasCompetingLinksAssessment, isApplicable: function isApplicable(paper) { return paper.hasText() && paper.hasKeyword(); }, getMarks: competingLinkMarker };
    }), (function (module, exports, __webpack_require__) {
        "use strict"; var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
        function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
        function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
        var AssessmentResult = __webpack_require__(0); var Assessment = __webpack_require__(15); var merge = __webpack_require__(11); var TextImagesAssessment = function (_Assessment) {
            _inherits(TextImagesAssessment, _Assessment); function TextImagesAssessment() { var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {}; _classCallCheck(this, TextImagesAssessment); var _this = _possibleConstructorReturn(this, (TextImagesAssessment.__proto__ || Object.getPrototypeOf(TextImagesAssessment)).call(this)); var defaultConfig = { scores: { noImages: 3, withAltKeyword: 9, withAltNonKeyword: 6, withAlt: 6, noAlt: 6 } }; _this.identifier = "textImages"; _this._config = merge(defaultConfig, config); return _this; }
            _createClass(TextImagesAssessment, [{ key: "getResult", value: function getResult(paper, researcher, i18n) { var assessmentResult = new AssessmentResult(); var imageCount = researcher.getResearch("imageCount"); var altProperties = researcher.getResearch("altTagCount"); assessmentResult.setScore(this.calculateScore(imageCount, altProperties)); assessmentResult.setText(this.translateScore(imageCount, altProperties, i18n)); return assessmentResult; } }, { key: "isApplicable", value: function isApplicable(paper) { return paper.hasText(); } }, {
                key: "calculateScore", value: function calculateScore(imageCount, altProperties) {
                    if (imageCount === 0) { return this._config.scores.noImages; }
                    if (altProperties.withAltKeyword > 0) { return this._config.scores.withAltKeyword; }
                    if (altProperties.withAltNonKeyword > 0) { return this._config.scores.withAltNonKeyword; }
                    if (altProperties.withAlt > 0) { return this._config.scores.withAlt; }
                    if (altProperties.noAlt > 0) { return this._config.scores.noAlt; }
                    return null;
                }
            }, {
                key: "translateScore", value: function translateScore(imageCount, altProperties, i18n) {
                    if (imageCount === 0) { return i18n.dgettext("js-text-analysis", "No images appear in this page, consider adding some as appropriate."); }
                    if (altProperties.withAltKeyword > 0) { return i18n.dgettext("js-text-analysis", "The images on this page contain alt attributes with the focus keyword."); }
                    if (altProperties.withAltNonKeyword > 0) { return i18n.dgettext("js-text-analysis", "The images on this page do not have alt attributes containing the focus keyword."); }
                    if (altProperties.withAlt > 0) { return i18n.dgettext("js-text-analysis", "The images on this page contain alt attributes."); }
                    if (altProperties.noAlt > 0) { return i18n.dgettext("js-text-analysis", "The images on this page are missing alt attributes."); }
                    return "";
                }
            }]); return TextImagesAssessment;
        }(Assessment); module.exports = TextImagesAssessment;
    }), (function (module, exports, __webpack_require__) {
        "use strict"; var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
        function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
        function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
        var AssessmentResult = __webpack_require__(0); var Assessment = __webpack_require__(15); var inRange = __webpack_require__(204); var merge = __webpack_require__(11); var TextLengthAssessment = function (_Assessment) {
            _inherits(TextLengthAssessment, _Assessment); function TextLengthAssessment() { var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {}; _classCallCheck(this, TextLengthAssessment); var _this = _possibleConstructorReturn(this, (TextLengthAssessment.__proto__ || Object.getPrototypeOf(TextLengthAssessment)).call(this)); var defaultConfig = { recommendedMinimum: 300, slightlyBelowMinimum: 250, belowMinimum: 200, veryFarBelowMinimum: 100, scores: { recommendedMinimum: 9, slightlyBelowMinimum: 6, belowMinimum: 3, farBelowMinimum: -10, veryFarBelowMinimum: -20 } }; _this.identifier = "textLength"; _this._config = merge(defaultConfig, config); return _this; }
            _createClass(TextLengthAssessment, [{ key: "getResult", value: function getResult(paper, researcher, i18n) { var wordCount = researcher.getResearch("wordCountInText"); var assessmentResult = new AssessmentResult(); assessmentResult.setScore(this.calculateScore(wordCount)); assessmentResult.setText(i18n.sprintf(this.translateScore(assessmentResult.getScore(), wordCount, i18n), wordCount, this._config.recommendedMinimum)); return assessmentResult; } }, {
                key: "calculateScore", value: function calculateScore(wordCount) {
                    if (wordCount >= this._config.recommendedMinimum) { return this._config.scores.recommendedMinimum; }
                    if (inRange(wordCount, this._config.slightlyBelowMinimum, this._config.recommendedMinimum)) { return this._config.scores.slightlyBelowMinimum; }
                    if (inRange(wordCount, this._config.belowMinimum, this._config.slightlyBelowMinimum)) { return this._config.scores.belowMinimum; }
                    if (inRange(wordCount, this._config.veryFarBelowMinimum, this._config.belowMinimum)) { return this._config.scores.farBelowMinimum; }
                    if (inRange(wordCount, 0, this._config.veryFarBelowMinimum)) { return this._config.scores.veryFarBelowMinimum; }
                    return null;
                }
            }, {
                key: "translateScore", value: function translateScore(score, wordCount, i18n) {
                    if (score === this._config.scores.recommendedMinimum) { return i18n.dngettext("js-text-analysis", "The text contains %1$d word.", "The text contains %1$d words.", wordCount) + " " + i18n.dngettext("js-text-analysis", "This is more than or equal to the recommended minimum of %2$d word.", "This is more than or equal to the recommended minimum of %2$d words.", this._config.recommendedMinimum); }
                    if (score === this._config.scores.slightlyBelowMinimum) { return i18n.dngettext("js-text-analysis", "The text contains %1$d word.", "The text contains %1$d words.", wordCount) + " " + i18n.dngettext("js-text-analysis", "This is slightly below the recommended minimum of %2$d word. Add a bit more copy.", "This is slightly below the recommended minimum of %2$d words. Add a bit more copy.", this._config.recommendedMinimum); }
                    if (score === this._config.scores.belowMinimum) { return i18n.dngettext("js-text-analysis", "The text contains %1$d word.", "The text contains %1$d words.", wordCount) + " " + i18n.dngettext("js-text-analysis", "This is below the recommended minimum of %2$d word. Add more content that is relevant for the topic.", "This is below the recommended minimum of %2$d words. Add more content that is relevant for the topic.", this._config.recommendedMinimum); }
                    if (score === this._config.scores.farBelowMinimum || score === this._config.scores.veryFarBelowMinimum) { return i18n.dngettext("js-text-analysis", "The text contains %1$d word.", "The text contains %1$d words.", wordCount) + " " + i18n.dngettext("js-text-analysis", "This is far below the recommended minimum of %2$d word. Add more content that is relevant for the topic.", "This is far below the recommended minimum of %2$d words. Add more content that is relevant for the topic.", this._config.recommendedMinimum); }
                    return "";
                }
            }]); return TextLengthAssessment;
        }(Assessment); module.exports = TextLengthAssessment;
    }), (function (module, exports, __webpack_require__) {
        var baseInRange = __webpack_require__(436), toFinite = __webpack_require__(173), toNumber = __webpack_require__(104); function inRange(number, start, end) {
            start = toFinite(start); if (end === undefined) { end = start; start = 0; } else { end = toFinite(end); }
            number = toNumber(number); return baseInRange(number, start, end);
        }
        module.exports = inRange;
    }), (function (module, exports, __webpack_require__) {
        "use strict"; var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
        function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
        function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
        var AssessmentResult = __webpack_require__(0); var Assessment = __webpack_require__(15); var isEmpty = __webpack_require__(10); var merge = __webpack_require__(11); var OutboundLinksAssessment = function (_Assessment) {
            _inherits(OutboundLinksAssessment, _Assessment); function OutboundLinksAssessment() { var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {}; _classCallCheck(this, OutboundLinksAssessment); var _this = _possibleConstructorReturn(this, (OutboundLinksAssessment.__proto__ || Object.getPrototypeOf(OutboundLinksAssessment)).call(this)); var defaultConfig = { scores: { noLinks: 6, allNofollowed: 7, moreNoFollowed: 8, allFollowed: 9 } }; _this.identifier = "externalLinks"; _this._config = merge(defaultConfig, config); return _this; }
            _createClass(OutboundLinksAssessment, [{
                key: "getResult", value: function getResult(paper, researcher, i18n) {
                    var linkStatistics = researcher.getResearch("getLinkStatistics"); var assessmentResult = new AssessmentResult(); if (!isEmpty(linkStatistics)) { assessmentResult.setScore(this.calculateScore(linkStatistics)); assessmentResult.setText(this.translateScore(linkStatistics, i18n)); }
                    return assessmentResult;
                }
            }, { key: "isApplicable", value: function isApplicable(paper) { return paper.hasText(); } }, {
                key: "calculateScore", value: function calculateScore(linkStatistics) {
                    if (linkStatistics.externalTotal === 0) { return this._config.scores.noLinks; }
                    if (linkStatistics.externalNofollow === linkStatistics.total) { return this._config.scores.allNofollowed; }
                    if (linkStatistics.externalNofollow < linkStatistics.externalTotal) { return this._config.scores.moreNoFollowed; }
                    if (linkStatistics.externalDofollow === linkStatistics.total) { return this._config.scores.allFollowed; }
                    return null;
                }
            }, {
                key: "translateScore", value: function translateScore(linkStatistics, i18n) {
                    if (linkStatistics.externalTotal === 0) { return i18n.dgettext("js-text-analysis", "No outbound links appear in this page, consider adding some as appropriate."); }
                    if (linkStatistics.externalNofollow === linkStatistics.total) { return i18n.sprintf(i18n.dgettext("js-text-analysis", "This page has %1$s outbound link(s), all nofollowed."), linkStatistics.externalNofollow); }
                    if (linkStatistics.externalNofollow < linkStatistics.externalTotal) { return i18n.sprintf(i18n.dgettext("js-text-analysis", "This page has %1$s nofollowed outbound link(s) and %2$s normal outbound link(s)."), linkStatistics.externalNofollow, linkStatistics.externalDofollow); }
                    if (linkStatistics.externalDofollow === linkStatistics.total) { return i18n.sprintf(i18n.dgettext("js-text-analysis", "This page has %1$s outbound link(s)."), linkStatistics.externalTotal); }
                    return "";
                }
            }]); return OutboundLinksAssessment;
        }(Assessment); module.exports = OutboundLinksAssessment;
    }), (function (module, exports, __webpack_require__) {
        "use strict"; var AssessmentResult = __webpack_require__(0); var isEmpty = __webpack_require__(10); var calculateLinkStatisticsResult = function calculateLinkStatisticsResult(linkStatistics, i18n) {
            if (linkStatistics.internalTotal === 0) { return { score: 3, text: i18n.dgettext("js-text-analysis", "No internal links appear in this page, consider adding some as appropriate.") }; }
            if (linkStatistics.internalNofollow === linkStatistics.total) { return { score: 7, text: i18n.sprintf(i18n.dgettext("js-text-analysis", "This page has %1$s internal link(s), all nofollowed."), linkStatistics.internalNofollow) }; }
            if (linkStatistics.internalNofollow < linkStatistics.internalTotal) { return { score: 8, text: i18n.sprintf(i18n.dgettext("js-text-analysis", "This page has %1$s nofollowed internal link(s) and %2$s normal internal link(s)."), linkStatistics.internalNofollow, linkStatistics.internalDofollow) }; }
            if (linkStatistics.internalDofollow === linkStatistics.total) { return { score: 9, text: i18n.sprintf(i18n.dgettext("js-text-analysis", "This page has %1$s internal link(s)."), linkStatistics.internalTotal) }; }
            return {};
        }; var textHasInternalLinksAssessment = function textHasInternalLinksAssessment(paper, researcher, i18n) {
            var linkStatistics = researcher.getResearch("getLinkStatistics"); var assessmentResult = new AssessmentResult(); if (!isEmpty(linkStatistics)) { var linkStatisticsResult = calculateLinkStatisticsResult(linkStatistics, i18n); assessmentResult.setScore(linkStatisticsResult.score); assessmentResult.setText(linkStatisticsResult.text); }
            return assessmentResult;
        }; module.exports = { identifier: "internalLinks", getResult: textHasInternalLinksAssessment, isApplicable: function isApplicable(paper) { return paper.hasText(); } };
    }), (function (module, exports, __webpack_require__) {
        "use strict"; var AssessmentResult = __webpack_require__(0); var escape = __webpack_require__(437); var titleHasKeywordAssessment = function titleHasKeywordAssessment(paper, researcher, i18n) {
            var keywordMatches = researcher.getResearch("findKeywordInPageTitle"); var score, text; if (keywordMatches.matches === 0) { score = 2; text = i18n.sprintf(i18n.dgettext("js-text-analysis", "The focus keyword '%1$s' does " + "not appear in the SEO title."), escape(paper.getKeyword())); }
            if (keywordMatches.matches > 0 && keywordMatches.position === 0) { score = 9; text = i18n.dgettext("js-text-analysis", "The SEO title contains the focus keyword, at the beginning which is considered " + "to improve rankings."); }
            if (keywordMatches.matches > 0 && keywordMatches.position > 0) { score = 6; text = i18n.dgettext("js-text-analysis", "The SEO title contains the focus keyword, but it does not appear at the beginning;" + " try and move it to the beginning."); }
            var assessmentResult = new AssessmentResult(); assessmentResult.setScore(score); assessmentResult.setText(text); return assessmentResult;
        }; module.exports = { identifier: "titleKeyword", getResult: titleHasKeywordAssessment, isApplicable: function isApplicable(paper) { return paper.hasKeyword(); } };
    }), (function (module, exports, __webpack_require__) {
        "use strict"; var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
        function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
        function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
        var AssessmentResult = __webpack_require__(0); var Assessment = __webpack_require__(15); var inRange = __webpack_require__(30).inRangeEndInclusive; var merge = __webpack_require__(11); var PageTitleWidthAssesment = function (_Assessment) {
            _inherits(PageTitleWidthAssesment, _Assessment); function PageTitleWidthAssesment() { var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {}; _classCallCheck(this, PageTitleWidthAssesment); var _this = _possibleConstructorReturn(this, (PageTitleWidthAssesment.__proto__ || Object.getPrototypeOf(PageTitleWidthAssesment)).call(this)); var defaultConfig = { minLength: 400, maxLength: 600, scores: { noTitle: 1, widthTooShort: 6, widthTooLong: 6, widthCorrect: 9 } }; _this.identifier = "titleWidth"; _this._config = merge(defaultConfig, config); return _this; }
            _createClass(PageTitleWidthAssesment, [{ key: "getResult", value: function getResult(paper, researcher, i18n) { var pageTitleWidth = researcher.getResearch("pageTitleWidth"); var assessmentResult = new AssessmentResult(); assessmentResult.setScore(this.calculateScore(pageTitleWidth)); assessmentResult.setText(this.translateScore(pageTitleWidth, i18n)); return assessmentResult; } }, {
                key: "calculateScore", value: function calculateScore(pageTitleWidth) {
                    if (inRange(pageTitleWidth, 1, 400)) { return this._config.scores.widthTooShort; }
                    if (inRange(pageTitleWidth, this._config.minLength, this._config.maxLength)) { return this._config.scores.widthCorrect; }
                    if (pageTitleWidth > this._config.maxLength) { return this._config.scores.widthTooLong; }
                    return this._config.scores.noTitle;
                }
            }, {
                key: "translateScore", value: function translateScore(pageTitleWidth, i18n) {
                    if (inRange(pageTitleWidth, 1, 400)) { return i18n.dgettext("js-text-analysis", "The SEO title is too short. Use the space to add keyword variations or create compelling call-to-action copy."); }
                    if (inRange(pageTitleWidth, this._config.minLength, this._config.maxLength)) { return i18n.dgettext("js-text-analysis", "The SEO title has a nice length."); }
                    if (pageTitleWidth > this._config.maxLength) { return i18n.dgettext("js-text-analysis", "The SEO title is wider than the viewable limit."); }
                    return i18n.dgettext("js-text-analysis", "Please create an SEO title.");
                }
            }]); return PageTitleWidthAssesment;
        }(Assessment); module.exports = PageTitleWidthAssesment;
    }), (function (module, exports, __webpack_require__) {
        "use strict"; var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
        function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
        function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
        var AssessmentResult = __webpack_require__(0); var Assessment = __webpack_require__(15); var merge = __webpack_require__(11); var UrlKeywordAssessment = function (_Assessment) {
            _inherits(UrlKeywordAssessment, _Assessment); function UrlKeywordAssessment() { var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {}; _classCallCheck(this, UrlKeywordAssessment); var _this = _possibleConstructorReturn(this, (UrlKeywordAssessment.__proto__ || Object.getPrototypeOf(UrlKeywordAssessment)).call(this)); var defaultConfig = { scores: { noKeywordInUrl: 6 } }; _this.identifier = "urlKeyword"; _this._config = merge(defaultConfig, config); return _this; }
            _createClass(UrlKeywordAssessment, [{ key: "getResult", value: function getResult(paper, researcher, i18n) { var totalKeywords = researcher.getResearch("keywordCountInUrl"); var assessmentResult = new AssessmentResult(); assessmentResult.setScore(this.calculateScore(totalKeywords)); assessmentResult.setText(this.translateScore(totalKeywords, i18n)); return assessmentResult; } }, { key: "isApplicable", value: function isApplicable(paper) { return paper.hasKeyword() && paper.hasUrl(); } }, {
                key: "calculateScore", value: function calculateScore(totalKeywords) {
                    if (totalKeywords === 0) { return this._config.scores.noKeywordInUrl; }
                    return 9;
                }
            }, {
                key: "translateScore", value: function translateScore(totalKeywords, i18n) {
                    if (totalKeywords === 0) { return i18n.dgettext("js-text-analysis", "The focus keyword does not appear in the URL for this page. " + "If you decide to rename the URL be sure to check the old URL 301 redirects to the new one!"); }
                    return i18n.dgettext("js-text-analysis", "The focus keyword appears in the URL for this page.");
                }
            }]); return UrlKeywordAssessment;
        }(Assessment); module.exports = UrlKeywordAssessment;
    }), (function (module, exports, __webpack_require__) {
        "use strict"; var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
        function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
        function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
        var AssessmentResult = __webpack_require__(0); var Assessment = __webpack_require__(15); var merge = __webpack_require__(11); var UrlLengthAssessment = function (_Assessment) {
            _inherits(UrlLengthAssessment, _Assessment); function UrlLengthAssessment() { var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {}; _classCallCheck(this, UrlLengthAssessment); var _this = _possibleConstructorReturn(this, (UrlLengthAssessment.__proto__ || Object.getPrototypeOf(UrlLengthAssessment)).call(this)); var defaultConfig = { scores: { tooLong: 6 } }; _this.identifier = "urlLength"; _this._config = merge(defaultConfig, config); return _this; }
            _createClass(UrlLengthAssessment, [{ key: "getResult", value: function getResult(paper, researcher, i18n) { var urlIsTooLong = researcher.getResearch("urlLength"); var assessmentResult = new AssessmentResult(); assessmentResult.setScore(this.calculateScore(urlIsTooLong)); assessmentResult.setText(this.translateScore(urlIsTooLong, i18n)); return assessmentResult; } }, { key: "isApplicable", value: function isApplicable(paper) { return paper.hasUrl(); } }, {
                key: "calculateScore", value: function calculateScore(urlIsTooLong) {
                    if (urlIsTooLong) { return this._config.scores.tooLong; }
                    return null;
                }
            }, {
                key: "translateScore", value: function translateScore(urlIsTooLong, i18n) {
                    if (urlIsTooLong) { return i18n.dgettext("js-text-analysis", "The slug for this page is a bit long, consider shortening it."); }
                    return "";
                }
            }]); return UrlLengthAssessment;
        }(Assessment); module.exports = UrlLengthAssessment;
    }), (function (module, exports, __webpack_require__) {
        "use strict"; var AssessmentResult = __webpack_require__(0); var getLanguageAvailability = __webpack_require__(40); var availableLanguages = ["en"]; var calculateUrlStopWordsCountResult = function calculateUrlStopWordsCountResult(stopWordCount, i18n) {
            if (stopWordCount > 0) { return { score: 5, text: i18n.dngettext("js-text-analysis", "The slug for this page contains a %1$sstop word%2$s, consider removing it.", "The slug for this page contains %1$sstop words%2$s, consider removing them.", stopWordCount) }; }
            return {};
        }; var urlHasStopWordsAssessment = function urlHasStopWordsAssessment(paper, researcher, i18n) { var stopWords = researcher.getResearch("stopWordsInUrl"); var stopWordsResult = calculateUrlStopWordsCountResult(stopWords.length, i18n); var assessmentResult = new AssessmentResult(); assessmentResult.setScore(stopWordsResult.score); assessmentResult.setText(i18n.sprintf(stopWordsResult.text, "<a href='" + i18n.dgettext("js-text-analysis", "http://en.wikipedia.org/wiki/Stop_words") + "' target='_blank'>", "</a>")); return assessmentResult; }; module.exports = { identifier: "urlStopWords", isApplicable: function isApplicable(paper) { return getLanguageAvailability(paper.getLocale(), availableLanguages); }, getResult: urlHasStopWordsAssessment };
    }), (function (module, exports, __webpack_require__) {
        "use strict"; var AssessmentResult = __webpack_require__(0); var inRange = __webpack_require__(204); var getLanguageAvailability = __webpack_require__(40); var availableLanguages = ["en", "nl", "de", "it"]; var calculateFleschReadingResult = function calculateFleschReadingResult(fleschReadingScore, i18n) {
            if (fleschReadingScore > 90) { return { score: 9, resultText: i18n.dgettext("js-text-analysis", "very easy"), note: "" }; }
            if (inRange(fleschReadingScore, 80, 90)) { return { score: 9, resultText: i18n.dgettext("js-text-analysis", "easy"), note: "" }; }
            if (inRange(fleschReadingScore, 70, 80)) { return { score: 9, resultText: i18n.dgettext("js-text-analysis", "fairly easy"), note: "" }; }
            if (inRange(fleschReadingScore, 60, 70)) { return { score: 9, resultText: i18n.dgettext("js-text-analysis", "ok"), note: "" }; }
            if (inRange(fleschReadingScore, 50, 60)) { return { score: 6, resultText: i18n.dgettext("js-text-analysis", "fairly difficult"), note: i18n.dgettext("js-text-analysis", "Try to make shorter sentences to improve readability.") }; }
            if (inRange(fleschReadingScore, 30, 50)) { return { score: 3, resultText: i18n.dgettext("js-text-analysis", "difficult"), note: i18n.dgettext("js-text-analysis", "Try to make shorter sentences, using less difficult words to improve readability.") }; }
            if (fleschReadingScore < 30) { return { score: 3, resultText: i18n.dgettext("js-text-analysis", "very difficult"), note: i18n.dgettext("js-text-analysis", "Try to make shorter sentences, using less difficult words to improve readability.") }; }
        }; var fleschReadingEaseAssessment = function fleschReadingEaseAssessment(paper, researcher, i18n) {
            var fleschReadingScore = researcher.getResearch("calculateFleschReading"); var text = i18n.dgettext("js-text-analysis", "The copy scores %1$s in the %2$s test, which is considered %3$s to read. %4$s"); var url = "<a href='https://yoa.st/flesch-reading' target='_blank'>Flesch Reading Ease</a>"; if (fleschReadingScore < 0) { fleschReadingScore = 0; }
            if (fleschReadingScore > 100) { fleschReadingScore = 100; }
            var fleschReadingResult = calculateFleschReadingResult(fleschReadingScore, i18n); text = i18n.sprintf(text, fleschReadingScore, url, fleschReadingResult.resultText, fleschReadingResult.note); var assessmentResult = new AssessmentResult(); assessmentResult.setScore(fleschReadingResult.score); assessmentResult.setText(text); return assessmentResult;
        }; module.exports = { identifier: "fleschReadingEase", getResult: fleschReadingEaseAssessment, isApplicable: function isApplicable(paper) { var isLanguageAvailable = getLanguageAvailability(paper.getLocale(), availableLanguages); return isLanguageAvailable && paper.hasText(); } };
    }), (function (module, exports, __webpack_require__) {
        "use strict"; var AssessmentResult = __webpack_require__(0); var stripHTMLTags = __webpack_require__(7).stripBlockTagsAtStartEnd; var isParagraphTooLong = __webpack_require__(116); var Mark = __webpack_require__(31); var marker = __webpack_require__(32); var inRange = __webpack_require__(30).inRangeEndInclusive; var filter = __webpack_require__(6); var map = __webpack_require__(2); var recommendedValue = 150; var getTooLongParagraphs = function getTooLongParagraphs(paragraphsLength) { return filter(paragraphsLength, function (paragraph) { return isParagraphTooLong(recommendedValue, paragraph.wordCount); }); }; var calculateParagraphLengthResult = function calculateParagraphLengthResult(paragraphsLength, tooLongParagraphs, i18n) {
            var score; if (paragraphsLength.length === 0) { return {}; }
            var longestParagraphLength = paragraphsLength[0].wordCount; if (longestParagraphLength <= 150) { score = 9; }
            if (inRange(longestParagraphLength, 150, 200)) { score = 6; }
            if (longestParagraphLength > 200) { score = 3; }
            if (score >= 7) { return { score: score, hasMarks: false, text: i18n.dgettext("js-text-analysis", "None of the paragraphs are too long, which is great.") }; }
            return { score: score, hasMarks: true, text: i18n.sprintf(i18n.dngettext("js-text-analysis", "%1$d of the paragraphs contains more than the recommended maximum " + "of %2$d words. Are you sure all information is about the same topic, and therefore belongs in one single paragraph?", "%1$d of the paragraphs contain more than the recommended maximum of %2$d words. Are you sure all information within each of" + " these paragraphs is about the same topic, and therefore belongs in a single paragraph?", tooLongParagraphs.length), tooLongParagraphs.length, recommendedValue) };
        }; var sortParagraphs = function sortParagraphs(paragraphs) { return paragraphs.sort(function (a, b) { return b.wordCount - a.wordCount; }); }; var paragraphLengthMarker = function paragraphLengthMarker(paper, researcher) { var paragraphsLength = researcher.getResearch("getParagraphLength"); var tooLongParagraphs = getTooLongParagraphs(paragraphsLength); return map(tooLongParagraphs, function (paragraph) { var paragraphText = stripHTMLTags(paragraph.text); var marked = marker(paragraphText); return new Mark({ original: paragraphText, marked: marked }); }); }; var paragraphLengthAssessment = function paragraphLengthAssessment(paper, researcher, i18n) { var paragraphsLength = researcher.getResearch("getParagraphLength"); paragraphsLength = sortParagraphs(paragraphsLength); var tooLongParagraphs = getTooLongParagraphs(paragraphsLength); var paragraphLengthResult = calculateParagraphLengthResult(paragraphsLength, tooLongParagraphs, i18n); var assessmentResult = new AssessmentResult(); assessmentResult.setScore(paragraphLengthResult.score); assessmentResult.setText(paragraphLengthResult.text); assessmentResult.setHasMarks(paragraphLengthResult.hasMarks); return assessmentResult; }; module.exports = { identifier: "textParagraphTooLong", getResult: paragraphLengthAssessment, isApplicable: function isApplicable(paper) { return paper.hasText(); }, getMarks: paragraphLengthMarker };
    }), (function (module, exports, __webpack_require__) {
        "use strict"; var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
        function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
        function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
        var AssessmentResult = __webpack_require__(0); var Assessment = __webpack_require__(15); var countTooLongSentences = __webpack_require__(440); var formatNumber = __webpack_require__(52); var inRange = __webpack_require__(30).inRangeEndInclusive; var stripTags = __webpack_require__(7).stripIncompleteTags; var Mark = __webpack_require__(31); var addMark = __webpack_require__(32); var map = __webpack_require__(2); var merge = __webpack_require__(11); var SentenceLengthInTextAssessment = function (_Assessment) {
            _inherits(SentenceLengthInTextAssessment, _Assessment); function SentenceLengthInTextAssessment() { var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {}; _classCallCheck(this, SentenceLengthInTextAssessment); var _this = _possibleConstructorReturn(this, (SentenceLengthInTextAssessment.__proto__ || Object.getPrototypeOf(SentenceLengthInTextAssessment)).call(this)); var defaultConfig = { recommendedWordCount: 20, slightlyTooMany: 25, farTooMany: 30 }; _this.identifier = "textSentenceLength"; _this._config = merge(defaultConfig, config); return _this; }
            _createClass(SentenceLengthInTextAssessment, [{ key: "getResult", value: function getResult(paper, researcher, i18n) { var sentences = researcher.getResearch("countSentencesFromText"); var percentage = this.calculatePercentage(sentences); var score = this.calculateScore(percentage); var assessmentResult = new AssessmentResult(); assessmentResult.setScore(score); assessmentResult.setText(this.translateScore(score, percentage, i18n)); assessmentResult.setHasMarks(percentage > 0); return assessmentResult; } }, { key: "isApplicable", value: function isApplicable(paper) { return paper.hasText(); } }, { key: "getMarks", value: function getMarks(paper, researcher) { var sentenceCount = researcher.getResearch("countSentencesFromText"); var sentenceObjects = this.getTooLongSentences(sentenceCount); return map(sentenceObjects, function (sentenceObject) { var sentence = stripTags(sentenceObject.sentence); return new Mark({ original: sentence, marked: addMark(sentence) }); }); } }, {
                key: "translateScore", value: function translateScore(score, percentage, i18n) {
                    var sentenceLengthURL = "<a href='https://yoa.st/short-sentences' target='_blank'>"; if (score >= 7) { return i18n.sprintf(i18n.dgettext("js-text-analysis", "%1$s of the sentences contain %2$smore than %3$s words%4$s, which is less than or equal to the recommended maximum of %5$s."), percentage + "%", sentenceLengthURL, this._config.recommendedWordCount, "</a>", this._config.slightlyTooMany + "%"); }
                    return i18n.sprintf(i18n.dgettext("js-text-analysis", "%1$s of the sentences contain %2$smore than %3$s words%4$s, which is more than the recommended maximum of %5$s. " + "Try to shorten the sentences."), percentage + "%", sentenceLengthURL, this._config.recommendedWordCount, "</a>", this._config.slightlyTooMany + "%");
                }
            }, {
                key: "calculatePercentage", value: function calculatePercentage(sentences) {
                    var percentage = 0; if (sentences.length !== 0) { var tooLongTotal = this.countTooLongSentences(sentences); percentage = formatNumber(tooLongTotal / sentences.length * 100); }
                    return percentage;
                }
            }, {
                key: "calculateScore", value: function calculateScore(percentage) {
                    var score = void 0; if (percentage <= this._config.slightlyTooMany) { score = 9; }
                    if (inRange(percentage, this._config.slightlyTooMany, this._config.farTooMany)) { score = 6; }
                    if (percentage > this._config.farTooMany) { score = 3; }
                    return score;
                }
            }, { key: "getTooLongSentences", value: function getTooLongSentences(sentences) { return countTooLongSentences(sentences, this._config.recommendedWordCount); } }, { key: "countTooLongSentences", value: function countTooLongSentences(sentences) { return this.getTooLongSentences(sentences).length; } }]); return SentenceLengthInTextAssessment;
        }(Assessment); module.exports = SentenceLengthInTextAssessment;
    }), (function (module, exports, __webpack_require__) {
        "use strict"; var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
        function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
        function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
        var AssessmentResult = __webpack_require__(0); var Assessment = __webpack_require__(15); var isTextTooLong = __webpack_require__(116); var filter = __webpack_require__(6); var map = __webpack_require__(2); var merge = __webpack_require__(11); var Mark = __webpack_require__(31); var marker = __webpack_require__(32); var inRange = __webpack_require__(30).inRangeEndInclusive; var SubheadingsDistributionTooLong = function (_Assessment) {
            _inherits(SubheadingsDistributionTooLong, _Assessment); function SubheadingsDistributionTooLong() { var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {}; _classCallCheck(this, SubheadingsDistributionTooLong); var _this = _possibleConstructorReturn(this, (SubheadingsDistributionTooLong.__proto__ || Object.getPrototypeOf(SubheadingsDistributionTooLong)).call(this)); var defaultConfig = { recommendedMaximumWordCount: 300, slightlyTooMany: 300, farTooMany: 350 }; _this.identifier = "subheadingsTooLong"; _this._config = merge(defaultConfig, config); return _this; }
            _createClass(SubheadingsDistributionTooLong, [{ key: "getResult", value: function getResult(paper, researcher, i18n) { var subheadingTextsLength = researcher.getResearch("getSubheadingTextLengths"); subheadingTextsLength = subheadingTextsLength.sort(function (a, b) { return b.wordCount - a.wordCount; }); var tooLongTexts = this.getTooLongSubheadingTexts(subheadingTextsLength).length; var score = this.calculateScore(subheadingTextsLength); var assessmentResult = new AssessmentResult(); assessmentResult.setScore(score); assessmentResult.setText(this.translateScore(score, tooLongTexts, i18n)); assessmentResult.setHasMarks(score > 2 && score < 7); return assessmentResult; } }, { key: "isApplicable", value: function isApplicable(paper) { return paper.hasText(); } }, { key: "getMarks", value: function getMarks(paper, researcher) { var subheadingTextsLength = researcher.getResearch("getSubheadingTextLengths"); var tooLongTexts = this.getTooLongSubheadingTexts(subheadingTextsLength); return map(tooLongTexts, function (tooLongText) { var marked = marker(tooLongText.text); return new Mark({ original: tooLongText.text, marked: marked }); }); } }, { key: "getTooLongSubheadingTexts", value: function getTooLongSubheadingTexts(subheadingTextsLength) { return filter(subheadingTextsLength, function (subheading) { return isTextTooLong(this._config.recommendedMaximumWordCount, subheading.wordCount); }.bind(this)); } }, {
                key: "calculateScore", value: function calculateScore(subheadingTextsLength) {
                    var score = void 0; if (subheadingTextsLength.length === 0) { return 2; }
                    var longestSubheadingTextLength = subheadingTextsLength[0].wordCount; if (longestSubheadingTextLength <= this._config.slightlyTooMany) { score = 9; }
                    if (inRange(longestSubheadingTextLength, this._config.slightlyTooMany, this._config.farTooMany)) { score = 6; }
                    if (longestSubheadingTextLength > this._config.farTooMany) { score = 3; }
                    return score;
                }
            }, {
                key: "translateScore", value: function translateScore(score, tooLongTexts, i18n) {
                    if (score === 2) { return i18n.sprintf(i18n.dgettext("js-text-analysis", "The text does not contain any %1$ssubheadings%2$s. Add at least one subheading."), "<a href='https://yoa.st/headings' target='_blank'>", "</a>"); }
                    if (score >= 7) { return i18n.sprintf(i18n.dgettext("js-text-analysis", "The amount of words following each of the subheadings doesn't exceed the recommended maximum of %1$d words, which is great."), this._config.recommendedMaximumWordCount); }
                    return i18n.sprintf(i18n.dngettext("js-text-analysis", "%1$d subheading is followed by more than the recommended maximum of %2$d words. Try to insert another subheading.", "%1$d of the subheadings are followed by more than the recommended maximum of %2$d words. Try to insert additional subheadings.", tooLongTexts), tooLongTexts, this._config.recommendedMaximumWordCount);
                }
            }]); return SubheadingsDistributionTooLong;
        }(Assessment); module.exports = SubheadingsDistributionTooLong;
    }), (function (module, exports, __webpack_require__) {
        "use strict"; var AssessmentResult = __webpack_require__(0); var formatNumber = __webpack_require__(52); var map = __webpack_require__(2); var inRange = __webpack_require__(30).inRangeStartInclusive; var stripTags = __webpack_require__(7).stripIncompleteTags; var Mark = __webpack_require__(31); var marker = __webpack_require__(32); var getLanguageAvailability = __webpack_require__(40); var availableLanguages = ["en", "de", "es", "fr", "nl", "it"]; var calculateTransitionWordPercentage = function calculateTransitionWordPercentage(sentences) {
            if (sentences.transitionWordSentences === 0 || sentences.totalSentences === 0) { return 0; }
            return formatNumber(sentences.transitionWordSentences / sentences.totalSentences * 100);
        }; var calculateTransitionWordResult = function calculateTransitionWordResult(transitionWordSentences, i18n) {
            var score = void 0; var percentage = calculateTransitionWordPercentage(transitionWordSentences); var hasMarks = percentage > 0; var transitionWordsURL = "<a href='https://yoa.st/transition-words' target='_blank'>"; if (percentage < 20) { score = 3; }
            if (inRange(percentage, 20, 30)) { score = 6; }
            if (percentage >= 30) { score = 9; }
            if (score < 7) { var recommendedMinimum = 30; return { score: formatNumber(score), hasMarks: hasMarks, text: i18n.sprintf(i18n.dgettext("js-text-analysis", "%1$s of the sentences contain a %2$stransition word%3$s or phrase, " + "which is less than the recommended minimum of %4$s."), percentage + "%", transitionWordsURL, "</a>", recommendedMinimum + "%") }; }
            return { score: formatNumber(score), hasMarks: hasMarks, text: i18n.sprintf(i18n.dgettext("js-text-analysis", "%1$s of the sentences contain a %2$stransition word%3$s or phrase, " + "which is great."), percentage + "%", transitionWordsURL, "</a>") };
        }; var transitionWordsAssessment = function transitionWordsAssessment(paper, researcher, i18n) { var transitionWordSentences = researcher.getResearch("findTransitionWords"); var transitionWordResult = calculateTransitionWordResult(transitionWordSentences, i18n); var assessmentResult = new AssessmentResult(); assessmentResult.setScore(transitionWordResult.score); assessmentResult.setText(transitionWordResult.text); assessmentResult.setHasMarks(transitionWordResult.hasMarks); return assessmentResult; }; var transitionWordsMarker = function transitionWordsMarker(paper, researcher) { var transitionWordSentences = researcher.getResearch("findTransitionWords"); return map(transitionWordSentences.sentenceResults, function (sentenceResult) { var sentence = sentenceResult.sentence; sentence = stripTags(sentence); return new Mark({ original: sentence, marked: marker(sentence) }); }); }; module.exports = { identifier: "textTransitionWords", getResult: transitionWordsAssessment, isApplicable: function isApplicable(paper) { var isLanguageAvailable = getLanguageAvailability(paper.getLocale(), availableLanguages); return isLanguageAvailable && paper.hasText(); }, getMarks: transitionWordsMarker };
    }), (function (module, exports, __webpack_require__) {
        "use strict"; var AssessmentResult = __webpack_require__(0); var formatNumber = __webpack_require__(52); var inRange = __webpack_require__(30).inRangeEndInclusive; var stripTags = __webpack_require__(7).stripIncompleteTags; var Mark = __webpack_require__(31); var marker = __webpack_require__(32); var map = __webpack_require__(2); var getLanguageAvailability = __webpack_require__(40); var availableLanguages = ["en", "de"]; var calculatePassiveVoiceResult = function calculatePassiveVoiceResult(passiveVoice, i18n) {
            var score; var percentage = passiveVoice.passives.length / passiveVoice.total * 100; percentage = formatNumber(percentage); var recommendedValue = 10; var passiveVoiceURL = "<a href='https://yoa.st/passive-voice' target='_blank'>"; var hasMarks = percentage > 0; if (percentage <= 10) { score = 9; }
            if (inRange(percentage, 10, 15)) { score = 6; }
            if (percentage > 15) { score = 3; }
            if (score >= 7) { return { score: score, hasMarks: hasMarks, text: i18n.sprintf(i18n.dgettext("js-text-analysis", "%1$s of the sentences contain %2$spassive voice%3$s, " + "which is less than or equal to the recommended maximum of %4$s."), percentage + "%", passiveVoiceURL, "</a>", recommendedValue + "%") }; }
            return { score: score, hasMarks: hasMarks, text: i18n.sprintf(i18n.dgettext("js-text-analysis", "%1$s of the sentences contain %2$spassive voice%3$s, " + "which is more than the recommended maximum of %4$s. Try to use their active counterparts."), percentage + "%", passiveVoiceURL, "</a>", recommendedValue + "%") };
        }; var passiveVoiceMarker = function passiveVoiceMarker(paper, researcher) { var passiveVoice = researcher.getResearch("passiveVoice"); return map(passiveVoice.passives, function (sentence) { sentence = stripTags(sentence); var marked = marker(sentence); return new Mark({ original: sentence, marked: marked }); }); }; var passiveVoiceAssessment = function passiveVoiceAssessment(paper, researcher, i18n) { var passiveVoice = researcher.getResearch("passiveVoice"); var passiveVoiceResult = calculatePassiveVoiceResult(passiveVoice, i18n); var assessmentResult = new AssessmentResult(); assessmentResult.setScore(passiveVoiceResult.score); assessmentResult.setText(passiveVoiceResult.text); assessmentResult.setHasMarks(passiveVoiceResult.hasMarks); return assessmentResult; }; module.exports = { identifier: "passiveVoice", getResult: passiveVoiceAssessment, isApplicable: function isApplicable(paper) { var isLanguageAvailable = getLanguageAvailability(paper.getLocale(), availableLanguages); return isLanguageAvailable && paper.hasText(); }, getMarks: passiveVoiceMarker };
    }), (function (module, exports, __webpack_require__) {
        "use strict"; var AssessmentResult = __webpack_require__(0); var stripTags = __webpack_require__(7).stripIncompleteTags; var partition = __webpack_require__(441); var sortBy = __webpack_require__(445); var map = __webpack_require__(2); var filter = __webpack_require__(6); var flatten = __webpack_require__(175); var Mark = __webpack_require__(31); var marker = __webpack_require__(32); var maximumConsecutiveDuplicates = 2; var getLanguageAvailability = __webpack_require__(40); var availableLanguages = ["en", "de", "es", "fr", "nl", "it"]; var groupSentenceBeginnings = function groupSentenceBeginnings(sentenceBeginnings) {
            var tooOften = partition(sentenceBeginnings, function (word) { return word.count > maximumConsecutiveDuplicates; }); if (tooOften[0].length === 0) { return { total: 0 }; }
            var sortedCounts = sortBy(tooOften[0], function (word) { return word.count; }); return { total: tooOften[0].length, lowestCount: sortedCounts[0].count };
        }; var calculateSentenceBeginningsResult = function calculateSentenceBeginningsResult(groupedSentenceBeginnings, i18n) {
            if (groupedSentenceBeginnings.total > 0) { return { score: 3, hasMarks: true, text: i18n.sprintf(i18n.dngettext("js-text-analysis", "The text contains %2$d consecutive sentences starting with the same word. Try to mix things up!", "The text contains %1$d instances where %2$d or more consecutive sentences start with the same word. " + "Try to mix things up!", groupedSentenceBeginnings.total), groupedSentenceBeginnings.total, groupedSentenceBeginnings.lowestCount) }; }
            return {};
        }; var sentenceBeginningMarker = function sentenceBeginningMarker(paper, researcher) { var sentenceBeginnings = researcher.getResearch("getSentenceBeginnings"); sentenceBeginnings = filter(sentenceBeginnings, function (sentenceBeginning) { return sentenceBeginning.count > maximumConsecutiveDuplicates; }); var sentences = map(sentenceBeginnings, function (begin) { return begin.sentences; }); return map(flatten(sentences), function (sentence) { sentence = stripTags(sentence); var marked = marker(sentence); return new Mark({ original: sentence, marked: marked }); }); }; var sentenceBeginningsAssessment = function sentenceBeginningsAssessment(paper, researcher, i18n) { var sentenceBeginnings = researcher.getResearch("getSentenceBeginnings"); var groupedSentenceBeginnings = groupSentenceBeginnings(sentenceBeginnings); var sentenceBeginningsResult = calculateSentenceBeginningsResult(groupedSentenceBeginnings, i18n); var assessmentResult = new AssessmentResult(); assessmentResult.setScore(sentenceBeginningsResult.score); assessmentResult.setText(sentenceBeginningsResult.text); assessmentResult.setHasMarks(sentenceBeginningsResult.hasMarks); return assessmentResult; }; module.exports = { identifier: "sentenceBeginnings", getResult: sentenceBeginningsAssessment, isApplicable: function isApplicable(paper) { var isLanguageAvailable = getLanguageAvailability(paper.getLocale(), availableLanguages); return isLanguageAvailable && paper.hasText(); }, getMarks: sentenceBeginningMarker };
    }), (function (module, exports, __webpack_require__) {
        "use strict"; var stripHTMLTags = __webpack_require__(7).stripFullTags; var AssessmentResult = __webpack_require__(0); function textPresenceAssessment(paper, researcher, i18n) {
            var text = stripHTMLTags(paper.getText()); if (text.length < 50) { var result = new AssessmentResult(); result.setText(i18n.dgettext("js-text-analysis", "You have far too little content, please add some content to enable a good analysis.")); result.setScore(3); return result; }
            return new AssessmentResult();
        }
        module.exports = { identifier: "textPresence", getResult: textPresenceAssessment };
    }), (function (module, exports, __webpack_require__) {
        "use strict"; var defaultsDeep = __webpack_require__(117); var getLanguage = __webpack_require__(20); var defaultConfig = __webpack_require__(452); var it = __webpack_require__(453); var configurations = { it: it }; module.exports = function (locale) {
            var language = getLanguage(locale); if (configurations.hasOwnProperty(language)) { return defaultsDeep(configurations[language], defaultConfig); }
            return defaultConfig;
        };
    }), (function (module, exports, __webpack_require__) {
        "use strict";
        var isEmpty = __webpack_require__(10);
        var isElement = __webpack_require__(456);
        var isUndefined = __webpack_require__(3);
        var clone = __webpack_require__(457);
        var defaultsDeep = __webpack_require__(117);
        var forEach = __webpack_require__(1);
        var debounce = __webpack_require__(119);
        var createWordRegex = __webpack_require__(167);
        var stripHTMLTags = __webpack_require__(7).stripFullTags;
        var stripSpaces = __webpack_require__(8);
        var replaceDiacritics = __webpack_require__(168);
        var transliterate = __webpack_require__(163);
        var templates = __webpack_require__(223);
        var snippetEditorTemplate = templates.snippetEditor;
        var hiddenElement = templates.hiddenSpan;
        var SnippetPreviewToggler = __webpack_require__(474);
        var domManipulation = __webpack_require__(224);
        var defaults = {
            data: {
                title: "",
                metaDesc: "",
                urlPath: "",
                titleWidth: 0,
                metaHeight: 0
            },
            placeholder: {
                title: "This is an example title - edit by clicking here",
                metaDesc: "Modify your meta description by editing it right here",
                urlPath: "example-post/"
            },
            defaultValue: {
                title: "",
                metaDesc: ""
            },
            baseURL: "http://example.com/",
            callbacks: {
                saveSnippetData: function saveSnippetData() { }
            },
            addTrailingSlash: true,
            metaDescriptionDate: "",
            previewMode: "desktop"
        };
        var titleMaxLength = 600;
        var metadescriptionMaxLength = 320;
        var inputPreviewBindings = [
            {
                preview: "title_container",
                inputField: "title"
            },
            {
                preview: "url_container",
                inputField: "urlPath"
            }, {
                preview: "meta_container",
                inputField: "metaDesc"
            }
        ];
        var getBaseURL = function getBaseURL() {
            var baseURL = this.opts.baseURL;
            if (this.hasApp() && !isEmpty(this.refObj.rawData.baseUrl) && this.opts.baseURL === defaults.baseURL) {
                baseURL = this.refObj.rawData.baseUrl;
            }
            return baseURL;
        }; function retrieveUnformattedText(key) { return this.data[key]; }
        function updateUnformattedText(key, value) { this.element.input[key].value = value; this.data[key] = value; }
        function hasTrailingSlash(url) { return url.indexOf("/") === url.length - 1; }
        function hasProgressSupport() { var progressElement = document.createElement("progress"); return !isUndefined(progressElement.max); }
        function rateTitleLength(titleLength) {
            var rating; switch (true) { case titleLength > 0 && titleLength <= 399: case titleLength > 600: rating = "ok"; break; case titleLength >= 400 && titleLength <= 600: rating = "good"; break; default: rating = "bad"; break; }
            return rating;
        }
        function rateMetaDescLength(metaDescLength) {
            var rating; switch (true) { case metaDescLength > 0 && metaDescLength < 120: case metaDescLength > 320: rating = "ok"; break; case metaDescLength >= 120 && metaDescLength <= 320: rating = "good"; break; default: rating = "bad"; break; }
            return rating;
        }
        function updateProgressBar(element, value, maximum, rating) {
            var barElement, progress, allClasses = ["snippet-editor__progress--bad", "snippet-editor__progress--ok", "snippet-editor__progress--good"];
            element.value = value;
            domManipulation.removeClasses(element, allClasses);
            domManipulation.addClass(element, "snippet-editor__progress--" + rating);
            if (!this.hasProgressSupport) {
                barElement = element.getElementsByClassName("snippet-editor__progress-bar")[0]; progress = value / maximum * 100; barElement.style.width = progress + "%";
            }
        }
        var SnippetPreview = function SnippetPreview(opts) {
            defaultsDeep(opts, defaults);
            this.data = opts.data;
            if (!isUndefined(opts.analyzerApp)) {
                this.refObj = opts.analyzerApp;
                this.i18n = this.refObj.i18n;
                this.data = {
                    title: this.refObj.rawData.snippetTitle || "",
                    urlPath: this.refObj.rawData.snippetCite || "",
                    metaDesc: this.refObj.rawData.snippetMeta || ""
                };
                if (!isEmpty(this.refObj.rawData.metaTitle)) { opts.placeholder.title = this.refObj.rawData.metaTitle; }
            }
            if (!isUndefined(opts.i18n)) { this.i18n = opts.i18n; }
            if (!isElement(opts.targetElement)) { throw new Error("The snippet preview requires a valid target element"); }
            this.opts = opts; this._currentFocus = null;
            this._currentHover = null;
            this.unformattedText = {};
            Object.defineProperty(this.unformattedText, "snippet_cite", {
                get: retrieveUnformattedText.bind(this, "urlPath"),
                set: updateUnformattedText.bind(this, "urlPath")
            });
            Object.defineProperty(this.unformattedText, "snippet_meta", {
                get: retrieveUnformattedText.bind(this, "metaDesc"),
                set: updateUnformattedText.bind(this, "metaDesc")
            });
            Object.defineProperty(this.unformattedText, "snippet_title", {
                get: retrieveUnformattedText.bind(this, "title"),
                set: updateUnformattedText.bind(this, "title")
            });
        };
        SnippetPreview.prototype.renderTemplate = function () {
            var targetElement = this.opts.targetElement;
            targetElement.innerHTML = snippetEditorTemplate({
                raw: {
                    title: this.data.title,
                    snippetCite: this.data.urlPath,
                    meta: this.data.metaDesc
                },
                rendered: {
                    title: this.formatTitle(),
                    baseUrl: this.formatUrl(),
                    snippetCite: this.formatCite(),
                    meta: this.formatMeta()
                },
                metaDescriptionDate: this.opts.metaDescriptionDate,
                placeholder: this.opts.placeholder,
                i18n: {
                    edit: this.i18n.dgettext("js-text-analysis", "Edit snippet"),
                    title: this.i18n.dgettext("js-text-analysis", "SEO title"),
                    slug: this.i18n.dgettext("js-text-analysis", "Slug"),
                    metaDescription: this.i18n.dgettext("js-text-analysis", "Meta description"),
                    save: this.i18n.dgettext("js-text-analysis", "Close snippet editor"),
                    snippetPreview: this.i18n.dgettext("js-text-analysis", "Snippet preview"),
                    titleLabel: this.i18n.dgettext("js-text-analysis", "SEO title preview:"),
                    slugLabel: this.i18n.dgettext("js-text-analysis", "Slug preview:"),
                    metaDescriptionLabel: this.i18n.dgettext("js-text-analysis", "Meta description preview:"),
                    snippetPreviewDescription: this.i18n.dgettext("js-text-analysis", "You can click on each element in the preview to jump to the Snippet Editor."),
                    desktopPreviewMode: this.i18n.dgettext("js-text-analysis", "Desktop preview"),
                    mobilePreviewMode: this.i18n.dgettext("js-text-analysis", "Mobile preview"),
                    isScrollableHint: this.i18n.dgettext("js-text-analysis", "Scroll to see the preview content.")
                }
            });
            this.element = {
                measurers: { metaHeight: null },
                rendered: {
                    title: document.getElementById("snippet_title"),
                    urlBase: document.getElementById("snippet_citeBase"),
                    urlPath: document.getElementById("snippet_cite"),
                    metaDesc: document.getElementById("snippet_meta")
                },
                input: {
                    title: targetElement.getElementsByClassName("js-snippet-editor-title")[0],
                    urlPath: targetElement.getElementsByClassName("js-snippet-editor-slug")[0],
                    metaDesc: targetElement.getElementsByClassName("js-snippet-editor-meta-description")[0]
                },
                progress: {
                    title: targetElement.getElementsByClassName("snippet-editor__progress-title")[0],
                    metaDesc: targetElement.getElementsByClassName("snippet-editor__progress-meta-description")[0]
                },
                container: document.getElementById("snippet_preview"),
                formContainer: targetElement.getElementsByClassName("snippet-editor__form")[0],
                editToggle: targetElement.getElementsByClassName("snippet-editor__edit-button")[0],
                closeEditor: targetElement.getElementsByClassName("snippet-editor__submit")[0],
                formFields: targetElement.getElementsByClassName("snippet-editor__form-field")
            };
            this.element.label = {
                title: this.element.input.title.parentNode,
                urlPath: this.element.input.urlPath.parentNode,
                metaDesc: this.element.input.metaDesc.parentNode
            };
            this.element.preview = {
                title: this.element.rendered.title.parentNode,
                urlPath: this.element.rendered.urlPath.parentNode,
                metaDesc: this.element.rendered.metaDesc.parentNode
            };
            this.hasProgressSupport = hasProgressSupport();
            if (this.hasProgressSupport) {
                this.element.progress.title.max = titleMaxLength;
                this.element.progress.metaDesc.max = metadescriptionMaxLength;
            } else {
                forEach(this.element.progress, function (progressElement) {
                    domManipulation.addClass(progressElement, "snippet-editor__progress--fallback");
                });
            }
            this.initPreviewToggler();
            this.setInitialView();
            this.opened = false;
            this.createMeasurementElements();
            this.updateProgressBars();
        };
        SnippetPreview.prototype.initPreviewToggler = function () {
            this.snippetPreviewToggle = new SnippetPreviewToggler(this.opts.previewMode, this.opts.targetElement.getElementsByClassName("snippet-editor__view-icon"));
            this.snippetPreviewToggle.initialize();
            this.snippetPreviewToggle.bindEvents();
        };
        SnippetPreview.prototype.refresh = function () {
            this.output = this.htmlOutput();
            this.renderOutput();
            this.renderSnippetStyle();
            this.measureTitle();
            this.measureMetaDescription();
            this.updateProgressBars();
        };
        function getAnalyzerTitle() {
            var title = this.data.title; if (isEmpty(title)) { title = this.opts.defaultValue.title; }
            if (this.hasPluggable()) { title = this.refObj.pluggable._applyModifications("data_page_title", title); }
            return stripSpaces(title);
        }
        var getAnalyzerMetaDesc = function getAnalyzerMetaDesc() {
            var metaDesc = this.data.metaDesc; if (isEmpty(metaDesc)) { metaDesc = this.opts.defaultValue.metaDesc; }
            if (this.hasPluggable()) { metaDesc = this.refObj.pluggable._applyModifications("data_meta_desc", metaDesc); }
            if (!isEmpty(this.opts.metaDescriptionDate) && !isEmpty(metaDesc)) { metaDesc = this.opts.metaDescriptionDate + " - " + this.data.metaDesc; }
            return stripSpaces(metaDesc);
        };
        SnippetPreview.prototype.getAnalyzerData = function () {
            return {
                title: getAnalyzerTitle.call(this),
                url: this.data.urlPath,
                metaDesc: getAnalyzerMetaDesc.call(this)
            };
        };
        SnippetPreview.prototype.callRegisteredEventBinder = function () {
            if (this.hasApp()) { this.refObj.callbacks.bindElementEvents(this.refObj); }
        };
        SnippetPreview.prototype.init = function () {
            if (this.hasApp() && this.refObj.rawData.metaTitle !== null && this.refObj.rawData.cite !== null) { this.refresh(); }
        };
        SnippetPreview.prototype.htmlOutput = function () {
            var html = {};
            html.title = this.formatTitle();
            html.cite = this.formatCite();
            html.meta = this.formatMeta();
            html.url = this.formatUrl();
            return html;
        };
        SnippetPreview.prototype.formatTitle = function () {
            var title = this.data.title; if (isEmpty(title)) { title = this.opts.defaultValue.title; }
            if (isEmpty(title)) { title = this.opts.placeholder.title; }
            if (this.hasPluggable() && this.refObj.pluggable.loaded) { title = this.refObj.pluggable._applyModifications("data_page_title", title); }
            title = stripHTMLTags(title); if (isEmpty(title)) { title = this.i18n.dgettext("js-text-analysis", "Please provide an SEO title by editing the snippet below."); }
            return title;
        };
        SnippetPreview.prototype.formatUrl = function () {
            var url = getBaseURL.call(this);
            return url.replace(/http:\/\//ig, "");
        };
        SnippetPreview.prototype.formatCite = function () {
            var cite = this.data.urlPath;
            cite = replaceDiacritics(stripHTMLTags(cite));
            if (isEmpty(cite)) {
                cite = this.opts.placeholder.urlPath;
            }
            if (this.hasApp() && !isEmpty(this.refObj.rawData.keyword)) { cite = this.formatKeywordUrl(cite); }
            if (this.opts.addTrailingSlash && !hasTrailingSlash(cite)) { cite = cite + "/"; }
            cite = cite.replace(/\s/g, "-");
            return cite;
        };
        SnippetPreview.prototype.formatMeta = function () {
            var meta = this.data.metaDesc;
            if (isEmpty(meta)) { meta = this.getMetaText(); }
            if (this.hasPluggable() && this.refObj.pluggable.loaded) {
                meta = this.refObj.pluggable._applyModifications("data_meta_desc", meta);
            }
            meta = stripHTMLTags(meta);
            meta = meta.substring(0, metadescriptionMaxLength);
            if (this.hasApp() && !isEmpty(this.refObj.rawData.keyword)) {
                meta = this.formatKeyword(meta);
            }
            if (isEmpty(meta)) {
                meta = this.i18n.dgettext("js-text-analysis", "Please provide a meta description by editing the snippet below.");
            }
            return meta;
        };
        SnippetPreview.prototype.getMetaText = function () {
            var metaText = this.opts.defaultValue.metaDesc;
            if (this.hasApp() && !isUndefined(this.refObj.rawData.excerpt) && isEmpty(metaText)) {
                metaText = this.refObj.rawData.excerpt;
            }
            if (this.hasApp() && !isUndefined(this.refObj.rawData.text) && isEmpty(metaText)) {
                metaText = this.refObj.rawData.text;
                if (this.hasPluggable() && this.refObj.pluggable.loaded) {
                    metaText = this.refObj.pluggable._applyModifications("content", metaText);
                }
            }
            metaText = stripHTMLTags(metaText);
            return metaText.substring(0, metadescriptionMaxLength);
        };
        SnippetPreview.prototype.getIndexMatches = function () {
            var indexMatches = [];
            var i = 0;
            var match = this.refObj.rawData.text.indexOf(this.refObj.rawData.keyword, i);
            while (match > -1) {
                indexMatches.push(match);
                i = match + this.refObj.rawData.keyword.length;
                match = this.refObj.rawData.text.indexOf(this.refObj.rawData.keyword, i);
            }
            return indexMatches;
        };
        SnippetPreview.prototype.getPeriodMatches = function () {
            var periodMatches = [0];
            var match; var i = 0; while ((match = this.refObj.rawData.text.indexOf(".", i)) > -1) { periodMatches.push(match); i = match + 1; }
            return periodMatches;
        };
        SnippetPreview.prototype.formatKeyword = function (textString) {
            var keyword = this.refObj.rawData.keyword;
            var keywordRegex = createWordRegex(keyword, "", false);
            textString = textString.replace(keywordRegex, function (str) {
                return "<strong>" + str + "</strong>";
            });
            var transliterateKeyword = transliterate(keyword, this.refObj.rawData.locale);
            if (transliterateKeyword !== keyword) {
                keywordRegex = createWordRegex(transliterateKeyword, "", false);
                textString = textString.replace(keywordRegex, function (str) { return "<strong>" + str + "</strong>"; });
            }
            return textString;
        };
        SnippetPreview.prototype.formatKeywordUrl = function (textString) {
            var keyword = this.refObj.rawData.keyword;
            keyword = transliterate(keyword, this.refObj.rawData.locale);
            keyword = keyword.replace(/'/, "");
            var dashedKeyword = keyword.replace(/\s/g, "-");
            var keywordRegex = createWordRegex(dashedKeyword, "\\-");
            return textString.replace(keywordRegex, function (str) { return "<strong>" + str + "</strong>"; });
        };
        SnippetPreview.prototype.renderOutput = function () {
            this.element.rendered.title.innerHTML = this.output.title;
            this.element.rendered.urlPath.innerHTML = this.output.cite;
            this.element.rendered.urlBase.innerHTML = this.output.url;
            this.element.rendered.metaDesc.innerHTML = this.output.meta;
        };
        SnippetPreview.prototype.renderSnippetStyle = function () {
            var metaDescElement = this.element.rendered.metaDesc;
            var metaDesc = getAnalyzerMetaDesc.call(this);
            if (isEmpty(metaDesc)) {
                domManipulation.addClass(metaDescElement, "desc-render");
                domManipulation.removeClass(metaDescElement, "desc-default");
            } else {
                domManipulation.addClass(metaDescElement, "desc-default");
                domManipulation.removeClass(metaDescElement, "desc-render");
            }
        };
        SnippetPreview.prototype.reRender = function () {
            this.init();
        };
        SnippetPreview.prototype.checkTextLength = function (event) {
            var text = event.currentTarget.textContent;
            switch (event.currentTarget.id) {
                case "snippet_meta":
                    event.currentTarget.className = "desc";
                    if (text.length > metadescriptionMaxLength) {
                        YoastSEO.app.snippetPreview.unformattedText.snippet_meta = event.currentTarget.textContent;
                        event.currentTarget.textContent = text.substring(0, metadescriptionMaxLength);
                    }
                    break;
                case "snippet_title": event.currentTarget.className = "title";
                    if (text.length > titleMaxLength) {
                        YoastSEO.app.snippetPreview.unformattedText.snippet_title = event.currentTarget.textContent;
                        event.currentTarget.textContent = text.substring(0, titleMaxLength);
                    }
                    break;
                default:
                    break;
            }
        };
        SnippetPreview.prototype.getUnformattedText = function (event) {
            var currentElement = event.currentTarget.id;
            if (typeof this.unformattedText[currentElement] !== "undefined") {
                event.currentTarget.textContent = this.unformattedText[currentElement];
            }
        };
        SnippetPreview.prototype.setUnformattedText = function (event) {
            var elem = event.currentTarget.id;
            this.unformattedText[elem] = document.getElementById(elem).textContent;
        };
        SnippetPreview.prototype.validateFields = function () {
            var metaDescription = getAnalyzerMetaDesc.call(this);
            var title = getAnalyzerTitle.call(this);
            if (metaDescription.length > metadescriptionMaxLength) {
                domManipulation.addClass(this.element.input.metaDesc, "snippet-editor__field--invalid");
            } else {
                domManipulation.removeClass(this.element.input.metaDesc, "snippet-editor__field--invalid");
            }
            if (title.length > titleMaxLength) {
                domManipulation.addClass(this.element.input.title, "snippet-editor__field--invalid");
            }
            else {
                domManipulation.removeClass(this.element.input.title, "snippet-editor__field--invalid");
            }
        };
        SnippetPreview.prototype.updateProgressBars = function () {
            var metaDescriptionRating, titleRating, metaDescription; metaDescription = getAnalyzerMetaDesc.call(this);
            titleRating = rateTitleLength(this.data.titleWidth);
            metaDescriptionRating = rateMetaDescLength(metaDescription.length);
            updateProgressBar.call(this, this.element.progress.title, this.data.titleWidth, titleMaxLength, titleRating);
            updateProgressBar.call(this, this.element.progress.metaDesc, metaDescription.length, metadescriptionMaxLength, metaDescriptionRating);
        };
        SnippetPreview.prototype.setInitialView = function () {
            var previewWidth = document.getElementById("snippet_preview").getBoundingClientRect().width;
            this.snippetPreviewToggle.setVisibility(previewWidth);
        };
        SnippetPreview.prototype.handleWindowResizing = debounce(function () {
            var previewWidth = document.getElementById("snippet_preview").getBoundingClientRect().width;
            this.snippetPreviewToggle.setScrollHintVisibility(previewWidth);
        }, 25);
        SnippetPreview.prototype.bindEvents = function () {
            var targetElement, elems = ["title", "slug", "meta-description"];
            forEach(elems, function (elem) {
                targetElement = document.getElementsByClassName("js-snippet-editor-" + elem)[0];
                targetElement.addEventListener("keydown", this.changedInput.bind(this));
                targetElement.addEventListener("keyup", this.changedInput.bind(this));
                targetElement.addEventListener("input", this.changedInput.bind(this));
                targetElement.addEventListener("focus", this.changedInput.bind(this));
                targetElement.addEventListener("blur", this.changedInput.bind(this));
            }.bind(this));
            this.element.editToggle.addEventListener("click", this.toggleEditor.bind(this));
            this.element.closeEditor.addEventListener("click", this.closeEditor.bind(this));
            window.addEventListener("resize", this.handleWindowResizing.bind(this));
            forEach(inputPreviewBindings, function (binding) {
                var previewElement = document.getElementById(binding.preview);
                var inputElement = this.element.input[binding.inputField];
                previewElement.addEventListener("click", function () {
                    this.openEditor();
                    inputElement.focus();
                }.bind(this));
                inputElement.addEventListener("focus", function () {
                    this._currentFocus = binding.inputField;
                    this._updateFocusCarets();
                }.bind(this));
                inputElement.addEventListener("blur", function () {
                    this._currentFocus = null;
                    this._updateFocusCarets();
                }.bind(this));
                previewElement.addEventListener("mouseover", function () {
                    this._currentHover = binding.inputField; this._updateHoverCarets();
                }.bind(this));
                previewElement.addEventListener("mouseout", function () {
                    this._currentHover = null; this._updateHoverCarets();
                }.bind(this));
            }.bind(this));
        };
        SnippetPreview.prototype.changedInput = debounce(function () {
            this.updateDataFromDOM();
            this.validateFields();
            this.updateProgressBars();
            this.refresh();
            if (this.hasApp()) {
                this.refObj.refresh();
            }
        }, 25);
        SnippetPreview.prototype.updateDataFromDOM = function () {
            this.data.title = this.element.input.title.value;
            this.data.urlPath = this.element.input.urlPath.value;
            this.data.metaDesc = this.element.input.metaDesc.value;
            this.opts.callbacks.saveSnippetData(clone(this.data));
        };
        SnippetPreview.prototype.openEditor = function () {
            this.element.editToggle.setAttribute("aria-expanded", "true");
            domManipulation.removeClass(this.element.formContainer, "snippet-editor--hidden");
            this.opened = true;
        };
        SnippetPreview.prototype.closeEditor = function () {
            domManipulation.addClass(this.element.formContainer, "snippet-editor--hidden");
            this.element.editToggle.setAttribute("aria-expanded", "false");
            this.element.editToggle.focus(); this.opened = false;
        };
        SnippetPreview.prototype.toggleEditor = function () {
            if (this.opened) { this.closeEditor(); } else { this.openEditor(); }
        };
        SnippetPreview.prototype._updateFocusCarets = function () {
            var focusedLabel, focusedPreview;
            forEach(this.element.label, function (element) {
                domManipulation.removeClass(element, "snippet-editor__label--focus");
            });
            forEach(this.element.preview, function (element) {
                domManipulation.removeClass(element, "snippet-editor__container--focus");
            });
            if (null !== this._currentFocus) {
                focusedLabel = this.element.label[this._currentFocus];
                focusedPreview = this.element.preview[this._currentFocus];
                domManipulation.addClass(focusedLabel, "snippet-editor__label--focus");
                domManipulation.addClass(focusedPreview, "snippet-editor__container--focus");
            }
        };
        SnippetPreview.prototype._updateHoverCarets = function () {
            var hoveredLabel;
            forEach(this.element.label, function (element) {
                domManipulation.removeClass(element, "snippet-editor__label--hover");
            });
            if (null !== this._currentHover) {
                hoveredLabel = this.element.label[this._currentHover];
                domManipulation.addClass(hoveredLabel, "snippet-editor__label--hover");
            }
        };
        SnippetPreview.prototype.setTitle = function (title) {
            this.element.input.title.value = title;
            this.changedInput();
        };
        SnippetPreview.prototype.setUrlPath = function (urlPath) {
            this.element.input.urlPath.value = urlPath; this.changedInput();
        };
        SnippetPreview.prototype.setMetaDescription = function (metaDesc) { this.element.input.metaDesc.value = metaDesc; this.changedInput(); };
        SnippetPreview.prototype.createMeasurementElements = function () { var metaDescriptionElement, spanHolder; metaDescriptionElement = hiddenElement({ width: document.getElementById("meta_container").offsetWidth + "px", whiteSpace: "" }); spanHolder = document.createElement("div"); spanHolder.className = "yoast-measurement-elements-holder"; spanHolder.innerHTML = metaDescriptionElement; document.body.appendChild(spanHolder); this.element.measurers.metaHeight = spanHolder.childNodes[0]; };
        SnippetPreview.prototype.measureTitle = function () { 
            if (this.element.rendered.title.offsetWidth !== 0 || this.element.rendered.title.textContent === "") { 
                this.data.titleWidth = this.element.rendered.title.offsetWidth; 
            } 
        }; 
        SnippetPreview.prototype.measureMetaDescription = function () { 
            var metaHeightElement = this.element.measurers.metaHeight; 
            metaHeightElement.innerHTML = this.element.rendered.metaDesc.innerHTML; 
            this.data.metaHeight = metaHeightElement.offsetHeight; 
        }; 
        SnippetPreview.prototype.getTitleWidth = function () { return this.data.titleWidth; }; 
        SnippetPreview.prototype.hasApp = function () {
            return !isUndefined(this.refObj); 
        }; 
        SnippetPreview.prototype.hasPluggable = function () { 
            return !isUndefined(this.refObj) && !isUndefined(this.refObj.pluggable); 
        }; 
        SnippetPreview.prototype.disableEnter = function (ev) { }; 
        SnippetPreview.prototype.textFeedback = function (ev) { }; 
        SnippetPreview.prototype.showEditIcon = function (ev) { }; 
        SnippetPreview.prototype.hideEditIcon = function () { }; 
        SnippetPreview.prototype.setFocus = function (ev) { }; 
        module.exports = SnippetPreview;

    }), (function (module, exports, __webpack_require__) {
        var arrayPush = __webpack_require__(84), getPrototype = __webpack_require__(96), getSymbols = __webpack_require__(85), stubArray = __webpack_require__(135); var nativeGetSymbols = Object.getOwnPropertySymbols; var getSymbolsIn = !nativeGetSymbols ? stubArray : function (object) {
            var result = []; while (object) { arrayPush(result, getSymbols(object)); object = getPrototype(object); }
            return result;
        }; module.exports = getSymbolsIn;
    }), (function (module, exports, __webpack_require__) {
        "use strict"; (function (global, module) {
            var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };; (function () {
                var undefined; var freeGlobal = (typeof global === 'undefined' ? 'undefined' : _typeof(global)) == 'object' && global && global.Object === Object && global; var freeSelf = (typeof self === 'undefined' ? 'undefined' : _typeof(self)) == 'object' && self && self.Object === Object && self; var root = freeGlobal || freeSelf || Function('return this')(); var freeExports = (false ? 'undefined' : _typeof(exports)) == 'object' && exports && !exports.nodeType && exports; var freeModule = freeExports && (false ? 'undefined' : _typeof(module)) == 'object' && module && !module.nodeType && module; var undefined; var VERSION = '4.17.4'; var INFINITY = 1 / 0; var nullTag = '[object Null]', symbolTag = '[object Symbol]', undefinedTag = '[object Undefined]'; var reUnescapedHtml = /[&<>"']/g, reHasUnescapedHtml = RegExp(reUnescapedHtml.source); var htmlEscapes = { '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', "'": '&#39;' }; var freeGlobal = (typeof global === 'undefined' ? 'undefined' : _typeof(global)) == 'object' && global && global.Object === Object && global; var freeSelf = (typeof self === 'undefined' ? 'undefined' : _typeof(self)) == 'object' && self && self.Object === Object && self; var root = freeGlobal || freeSelf || Function('return this')(); function arrayMap(array, iteratee) {
                    var index = -1, length = array == null ? 0 : array.length, result = Array(length); while (++index < length) { result[index] = iteratee(array[index], index, array); }
                    return result;
                }
                function basePropertyOf(object) { return function (key) { return object == null ? undefined : object[key]; }; }
                var escapeHtmlChar = basePropertyOf(htmlEscapes); var objectProto = Object.prototype; var hasOwnProperty = objectProto.hasOwnProperty; var nativeObjectToString = objectProto.toString; var _Symbol = root.Symbol, symToStringTag = _Symbol ? _Symbol.toStringTag : undefined; var realNames = {}; var symbolProto = _Symbol ? _Symbol.prototype : undefined, symbolToString = symbolProto ? symbolProto.toString : undefined; function baseGetTag(value) {
                    if (value == null) { return value === undefined ? undefinedTag : nullTag; }
                    return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
                }
                function baseToString(value) {
                    if (typeof value == 'string') { return value; }
                    if (isArray(value)) { return arrayMap(value, baseToString) + ''; }
                    if (isSymbol(value)) { return symbolToString ? symbolToString.call(value) : ''; }
                    var result = value + ''; return result == '0' && 1 / value == -INFINITY ? '-0' : result;
                }
                function getRawTag(value) {
                    var isOwn = hasOwnProperty.call(value, symToStringTag), tag = value[symToStringTag]; try { value[symToStringTag] = undefined; var unmasked = true; } catch (e) { }
                    var result = nativeObjectToString.call(value); if (unmasked) { if (isOwn) { value[symToStringTag] = tag; } else { delete value[symToStringTag]; } }
                    return result;
                }
                function objectToString(value) { return nativeObjectToString.call(value); }
                var isArray = Array.isArray; function isObjectLike(value) { return value != null && (typeof value === 'undefined' ? 'undefined' : _typeof(value)) == 'object'; }
                function isSymbol(value) { return (typeof value === 'undefined' ? 'undefined' : _typeof(value)) == 'symbol' || isObjectLike(value) && baseGetTag(value) == symbolTag; }
                function toString(value) { return value == null ? '' : baseToString(value); }
                function escape(string) { string = toString(string); return string && reHasUnescapedHtml.test(string) ? string.replace(reUnescapedHtml, escapeHtmlChar) : string; }
                var _ = { 'escape': escape }; var templates = { 'assessmentPresenterResult': {}, 'hiddenSpan': {}, 'relevantWords': {}, 'snippetEditor': {} }; templates['assessmentPresenterResult'] = function (obj) {
                    obj || (obj = {}); var _obj = obj, scores = _obj.scores, markerButtonsDisabled = _obj.markerButtonsDisabled, i18n = _obj.i18n, activeMarker = _obj.activeMarker; var __t, __p = '', __e = _.escape, __j = Array.prototype.join; function print() { __p += __j.call(arguments, ''); }
                    __p += '<ul class="wpseoanalysis assessment-results">\n    '; for (var i in scores) {
                        __p += '\n        <li class="score">\n            <span class="assessment-results__mark-container">\n                '; if (scores[i].marker) {
                            __p += '\n                    <button type="button" '; if (markerButtonsDisabled) { __p += ' disabled="disabled" '; }
                            __p += '\n                        aria-label="'; if (markerButtonsDisabled) { __p += (__t = i18n.disabledMarkText) == null ? '' : __t; } else if (scores[i].identifier === activeMarker) { __p += (__t = i18n.removeMarksInText) == null ? '' : __t; } else { __p += (__t = i18n.markInText) == null ? '' : __t; }
                            __p += '"\n                        class="assessment-results__mark '; if (markerButtonsDisabled) { __p += ' icon-eye-disabled '; } else if (scores[i].identifier === activeMarker) { __p += '\n                            icon-eye-active\n                        '; } else { __p += '\n                            icon-eye-inactive\n                        '; }
                            __p += '\n                        js-assessment-results__mark-' + ((__t = scores[i].identifier) == null ? '' : __t) + ' yoast-tooltip yoast-tooltip-s">\n                        <span class="screen-reader-text">'; if (markerButtonsDisabled) { __p += (__t = i18n.disabledMarkText) == null ? '' : __t; } else if (scores[i].identifier === activeMarker) { __p += (__t = i18n.removeMarksInText) == null ? '' : __t; } else { __p += (__t = i18n.markInText) == null ? '' : __t; }
                            __p += '\n                        </span></button>\n                ';
                        }
                        __p += '\n            </span>\n            <span class="wpseo-score-icon ' + __e(scores[i].className) + '"></span>\n            <span class="screen-reader-text">' + ((__t = scores[i].screenReaderText) == null ? '' : __t) + '</span>\n            <span class="wpseo-score-text">' + ((__t = scores[i].text) == null ? '' : __t) + '</span>\n        </li>\n    ';
                    }
                    __p += '\n</ul>\n'; return __p;
                }; templates['hiddenSpan'] = function (obj) {
                    obj || (obj = {}); var _obj2 = obj, whiteSpace = _obj2.whiteSpace, width = _obj2.width; var __t, __p = '', __e = _.escape, __j = Array.prototype.join; function print() { __p += __j.call(arguments, ''); }
                    __p += '<span aria-hidden="true" style="width: ' + __e(width) + '; height: auto; position: absolute; visibility: hidden; '; if ("" !== whiteSpace) { __p += 'white-space: ' + __e(whiteSpace); }
                    __p += '">\n\n</span>\n'; return __p;
                }; templates['relevantWords'] = function (obj) {
                    obj || (obj = {}); var _obj3 = obj, words = _obj3.words; var __t, __p = '', __j = Array.prototype.join; function print() { __p += __j.call(arguments, ''); }
                    __p += '<table>\n    <tr>\n        <th>Word</th>\n        <th>Density</th>\n        <th>Occurrences</th>\n        <th>Length</th>\n        <th>Relevant word percentage</th>\n        <th>Length bonus</th>\n        <th>Multiplier</th>\n        <th>Relevance</th>\n    </tr>\n    '; for (var i in words) { __p += '\n        <tr>\n            <td>' + ((__t = words[i].word) == null ? '' : __t) + '</td>\n            <td>' + ((__t = words[i].density) == null ? '' : __t) + '</td>\n            <td>' + ((__t = words[i].occurrences) == null ? '' : __t) + '</td>\n            <td>' + ((__t = words[i].length) == null ? '' : __t) + '</td>\n            <td>' + ((__t = words[i].relevantWordPercentage) == null ? '' : __t) + '</td>\n            <td>' + ((__t = words[i].lengthBonus) == null ? '' : __t) + '</td>\n            <td>' + ((__t = words[i].multiplier) == null ? '' : __t) + '</td>\n            <td>' + ((__t = words[i].relevance) == null ? '' : __t) + '</td>\n        </tr>\n    '; }
                    __p += '\n</table>\n'; return __p;
                }; templates['snippetEditor'] = function (obj) {
                    obj || (obj = {}); var _obj4 = obj, i18n = _obj4.i18n, rendered = _obj4.rendered, metaDescriptionDate = _obj4.metaDescriptionDate, raw = _obj4.raw, placeholder = _obj4.placeholder; var __t, __p = '', __e = _.escape, __j = Array.prototype.join; function print() { __p += __j.call(arguments, ''); }
                    __p += '<div id="snippet_preview" class="yoast-section">\n	<section class="snippet-editor__preview">\n		<h3 class="snippet-editor__heading snippet-editor__heading-icon snippet-editor__heading-icon-eye">' + __e(i18n.snippetPreview) + '</h3>\n	<p class="screen-reader-text">' + __e(i18n.snippetPreviewDescription) + '</p>\n\n		<div id="snippet-preview-view" class="snippet-editor__view">\n			<div class="snippet_container snippet_container__title snippet-editor__container" id="title_container">\n				<span class="screen-reader-text">' + __e(i18n.titleLabel) + '</span>\n				<span class="title" id="render_title_container">\n					<span id="snippet_title">\n						' + __e(rendered.title) + '\n					</span>\n				</span>\n				<span class="title" id="snippet_sitename"></span>\n			</div>\n			<div class="snippet_container snippet_container__url snippet-editor__container" id="url_container">\n				<span class="screen-reader-text">' + __e(i18n.slugLabel) + '</span>\n				<span class="urlFull">\n					<cite class="url urlBase" id="snippet_citeBase">\n						' + __e(rendered.baseUrl) + '\n					</cite><cite class="url" id="snippet_cite">\n						' + __e(rendered.snippetCite) + '\n					</cite>\n				</span><span class="down_arrow"></span>\n			</div>\n			<div class="snippet_container snippet_container__meta snippet-editor__container" id="meta_container">\n				<span class="screen-reader-text">' + __e(i18n.metaDescriptionLabel) + '</span>\n				'; if ("" !== metaDescriptionDate) { __p += '\n					<span class="snippet-editor__date">\n						' + __e(metaDescriptionDate) + ' -\n					</span>\n				'; }
                    __p += '\n				<span class="desc" id="snippet_meta">\n					' + __e(rendered.meta) + '\n				</span>\n			</div>\n		</div>\n\n		<div class="snippet-editor__is-scrollable-hintwrapper">\n			<span class=\'snippet-editor__is-scrollable-hint\' aria-hidden=\'true\'>' + __e(i18n.isScrollableHint) + '</span>\n		</div>\n\n		<div class="snippet-editor__view-toggle">\n			<button class="snippet-editor__view-icon snippet-editor__view-icon-mobile yoast-tooltip yoast-tooltip-se" type="button" data-type="mobile" aria-label="' + __e(i18n.mobilePreviewMode) + '" />\n			<button class="snippet-editor__view-icon snippet-editor__view-icon-desktop yoast-tooltip yoast-tooltip-se" type="button" data-type="desktop" aria-label="' + __e(i18n.desktopPreviewMode) + '" />\n		</div>\n		<button class="snippet-editor__button snippet-editor__edit-button" type="button" aria-expanded="false">\n			' + __e(i18n.edit) + '\n		</button>\n	</section>\n\n	<div class="snippet-editor__form snippet-editor--hidden">\n		<label for="snippet-editor-title" class="snippet-editor__label">\n			' + __e(i18n.title) + '\n			<input type="text" class="snippet-editor__input snippet-editor__title js-snippet-editor-title" id="snippet-editor-title" value="' + __e(raw.title) + '" placeholder="' + __e(placeholder.title) + '" />\n		</label>\n		<progress value="0.0" class="snippet-editor__progress snippet-editor__progress-title" aria-hidden="true">\n			<div class="snippet-editor__progress-bar"></div>\n		</progress>\n		<label for="snippet-editor-slug" class="snippet-editor__label">\n			' + __e(i18n.slug) + '\n			<input type="text" class="snippet-editor__input snippet-editor__slug js-snippet-editor-slug" id="snippet-editor-slug" value="' + __e(raw.snippetCite) + '" placeholder="' + __e(placeholder.urlPath) + '" />\n		</label>\n		<label for="snippet-editor-meta-description" class="snippet-editor__label">\n			' + __e(i18n.metaDescription) + '\n			<textarea class="snippet-editor__input snippet-editor__meta-description js-snippet-editor-meta-description" id="snippet-editor-meta-description" placeholder="' + __e(placeholder.metaDesc) + '">' + __e(raw.meta) + '</textarea>\n		</label>\n		<progress value="0.0" class="snippet-editor__progress snippet-editor__progress-meta-description" aria-hidden="true">\n			<div class="snippet-editor__progress-bar"></div>\n		</progress>\n\n		<button class="snippet-editor__submit snippet-editor__button" type="button">' + __e(i18n.save) + '</button>\n	</div>\n</div>\n'; return __p;
                }; if (freeModule) { (freeModule.exports = templates).templates = templates; freeExports.templates = templates; } else { root.templates = templates; }
            }).call(undefined);
        }.call(exports, __webpack_require__(17), __webpack_require__(45)(module)))
    }), (function (module, exports, __webpack_require__) {
        "use strict"; var forEach = __webpack_require__(1); var addClass = function addClass(element, className) {
            var classes = element.className.split(" "); if (-1 === classes.indexOf(className)) { classes.push(className); }
            element.className = classes.join(" ");
        }; var removeClass = function removeClass(element, className) {
            var classes = element.className.split(" "); var foundClass = classes.indexOf(className); if (-1 !== foundClass) { classes.splice(foundClass, 1); }
            element.className = classes.join(" ");
        }; var removeClasses = function removeClasses(element, classes) { forEach(classes, this.removeClass.bind(null, element)); }; var hasClass = function hasClass(element, className) { return element.className.indexOf(className) > -1; }; module.exports = { hasClass: hasClass, addClass: addClass, removeClass: removeClass, removeClasses: removeClasses };
    }), (function (module, exports, __webpack_require__) {
        "use strict"; var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; var isUndefined = __webpack_require__(3); var forEach = __webpack_require__(1); var reduce = __webpack_require__(483); var isString = __webpack_require__(107); var isObject = __webpack_require__(5); var InvalidTypeError = __webpack_require__(161); var Pluggable = function Pluggable(app) { this.app = app; this.loaded = false; this.preloadThreshold = 3000; this.plugins = {}; this.modifications = {}; this.customTests = []; setTimeout(this._pollLoadingPlugins.bind(this), 1500); }; Pluggable.prototype._registerPlugin = function (pluginName, options) {
            if (typeof pluginName !== "string") { console.error("Failed to register plugin. Expected parameter `pluginName` to be a string."); return false; }
            if (!isUndefined(options) && (typeof options === "undefined" ? "undefined" : _typeof(options)) !== "object") { console.error("Failed to register plugin " + pluginName + ". Expected parameters `options` to be a object."); return false; }
            if (this._validateUniqueness(pluginName) === false) { console.error("Failed to register plugin. Plugin with name " + pluginName + " already exists"); return false; }
            this.plugins[pluginName] = options; return true;
        }; Pluggable.prototype._ready = function (pluginName) {
            if (typeof pluginName !== "string") { console.error("Failed to modify status for plugin " + pluginName + ". Expected parameter `pluginName` to be a string."); return false; }
            if (isUndefined(this.plugins[pluginName])) { console.error("Failed to modify status for plugin " + pluginName + ". The plugin was not properly registered."); return false; }
            this.plugins[pluginName].status = "ready"; return true;
        }; Pluggable.prototype._reloaded = function (pluginName) {
            if (typeof pluginName !== "string") { console.error("Failed to reload Content Analysis for " + pluginName + ". Expected parameter `pluginName` to be a string."); return false; }
            if (isUndefined(this.plugins[pluginName])) { console.error("Failed to reload Content Analysis for plugin " + pluginName + ". The plugin was not properly registered."); return false; }
            this.app.refresh(); return true;
        }; Pluggable.prototype._registerModification = function (modification, callable, pluginName, priority) {
            if (typeof modification !== "string") { console.error("Failed to register modification for plugin " + pluginName + ". Expected parameter `modification` to be a string."); return false; }
            if (typeof callable !== "function") { console.error("Failed to register modification for plugin " + pluginName + ". Expected parameter `callable` to be a function."); return false; }
            if (typeof pluginName !== "string") { console.error("Failed to register modification for plugin " + pluginName + ". Expected parameter `pluginName` to be a string."); return false; }
            if (this._validateOrigin(pluginName) === false) { console.error("Failed to register modification for plugin " + pluginName + ". The integration has not finished loading yet."); return false; }
            var prio = typeof priority === "number" ? priority : 10; var callableObject = { callable: callable, origin: pluginName, priority: prio }; if (isUndefined(this.modifications[modification])) { this.modifications[modification] = []; }
            this.modifications[modification].push(callableObject); return true;
        }; Pluggable.prototype._registerTest = function () { console.error("This function is deprecated, please use _registerAssessment"); }; Pluggable.prototype._registerAssessment = function (assessor, name, assessment, pluginName) {
            if (!isString(name)) { throw new InvalidTypeError("Failed to register test for plugin " + pluginName + ". Expected parameter `name` to be a string."); }
            if (!isObject(assessment)) { throw new InvalidTypeError("Failed to register assessment for plugin " + pluginName + ". Expected parameter `assessment` to be a function."); }
            if (!isString(pluginName)) { throw new InvalidTypeError("Failed to register assessment for plugin " + pluginName + ". Expected parameter `pluginName` to be a string."); }
            name = pluginName + "-" + name; assessor.addAssessment(name, assessment); return true;
        }; Pluggable.prototype._pollLoadingPlugins = function (pollTime) { pollTime = isUndefined(pollTime) ? 0 : pollTime; if (this._allReady() === true) { this.loaded = true; this.app.pluginsLoaded(); } else if (pollTime >= this.preloadThreshold) { this._pollTimeExceeded(); } else { pollTime += 50; setTimeout(this._pollLoadingPlugins.bind(this, pollTime), 50); } }; Pluggable.prototype._allReady = function () { return reduce(this.plugins, function (allReady, plugin) { return allReady && plugin.status === "ready"; }, true); }; Pluggable.prototype._pollTimeExceeded = function () { forEach(this.plugins, function (plugin, pluginName) { if (!isUndefined(plugin.options) && plugin.options.status !== "ready") { console.error("Error: Plugin " + pluginName + ". did not finish loading in time."); delete this.plugins[pluginName]; } }); this.loaded = true; this.app.pluginsLoaded(); }; Pluggable.prototype._applyModifications = function (modification, data, context) {
            var callChain = this.modifications[modification]; if (callChain instanceof Array && callChain.length > 0) { callChain = this._stripIllegalModifications(callChain); callChain.sort(function (a, b) { return a.priority - b.priority; }); forEach(callChain, function (callableObject) { var callable = callableObject.callable; var newData = callable(data, context); if ((typeof newData === "undefined" ? "undefined" : _typeof(newData)) === (typeof data === "undefined" ? "undefined" : _typeof(data))) { data = newData; } else { console.error("Modification with name " + modification + " performed by plugin with name " + callableObject.origin + " was ignored because the data that was returned by it was of a different type than the data we had passed it."); } }); }
            return data;
        }; Pluggable.prototype._addPluginTests = function (analyzer) { this.customTests.map(function (customTest) { this._addPluginTest(analyzer, customTest); }, this); }; Pluggable.prototype._addPluginTest = function (analyzer, pluginTest) { analyzer.addAnalysis({ name: pluginTest.name, callable: pluginTest.analysis }); analyzer.analyzeScorer.addScoring({ name: pluginTest.name, scoring: pluginTest.scoring }); }; Pluggable.prototype._stripIllegalModifications = function (callChain) { forEach(callChain, function (callableObject, index) { if (this._validateOrigin(callableObject.origin) === false) { delete callChain[index]; } }.bind(this)); return callChain; }; Pluggable.prototype._validateOrigin = function (pluginName) {
            if (this.plugins[pluginName].status !== "ready") { return false; }
            return true;
        }; Pluggable.prototype._validateUniqueness = function (pluginName) {
            if (!isUndefined(this.plugins[pluginName])) { return false; }
            return true;
        }; module.exports = Pluggable;
    }), (function (module, exports, __webpack_require__) {
        "use strict"; var defaults = __webpack_require__(110); var defaultAttributes = { keyword: "", description: "", title: "", titleWidth: 0, url: "", locale: "en_US", permalink: "" }; var Paper = function Paper(text, attributes) {
            this._text = text || ""; attributes = attributes || {}; defaults(attributes, defaultAttributes); if (attributes.locale === "") { attributes.locale = defaultAttributes.locale; }
            this._attributes = attributes;
        }; Paper.prototype.hasKeyword = function () { return this._attributes.keyword !== ""; }; Paper.prototype.getKeyword = function () { return this._attributes.keyword; }; Paper.prototype.hasText = function () { return this._text !== ""; }; Paper.prototype.getText = function () { return this._text; }; Paper.prototype.hasDescription = function () { return this._attributes.description !== ""; }; Paper.prototype.getDescription = function () { return this._attributes.description; }; Paper.prototype.hasTitle = function () { return this._attributes.title !== ""; }; Paper.prototype.getTitle = function () { return this._attributes.title; }; Paper.prototype.hasTitleWidth = function () { return this._attributes.titleWidth !== 0; }; Paper.prototype.getTitleWidth = function () { return this._attributes.titleWidth; }; Paper.prototype.hasUrl = function () { return this._attributes.url !== ""; }; Paper.prototype.getUrl = function () { return this._attributes.url; }; Paper.prototype.hasLocale = function () { return this._attributes.locale !== ""; }; Paper.prototype.getLocale = function () { return this._attributes.locale; }; Paper.prototype.hasPermalink = function () { return this._attributes.permalink !== ""; }; Paper.prototype.getPermalink = function () { return this._attributes.permalink; }; module.exports = Paper;
    }), (function (module, exports, __webpack_require__) {
        var Tokenizer = __webpack_require__(228); var formTags = { input: true, option: true, optgroup: true, select: true, button: true, datalist: true, textarea: true }; var openImpliesClose = { tr: { tr: true, th: true, td: true }, th: { th: true }, td: { thead: true, th: true, td: true }, body: { head: true, link: true, script: true }, li: { li: true }, p: { p: true }, h1: { p: true }, h2: { p: true }, h3: { p: true }, h4: { p: true }, h5: { p: true }, h6: { p: true }, select: formTags, input: formTags, output: formTags, button: formTags, datalist: formTags, textarea: formTags, option: { option: true }, optgroup: { optgroup: true } }; var voidElements = { __proto__: null, area: true, base: true, basefont: true, br: true, col: true, command: true, embed: true, frame: true, hr: true, img: true, input: true, isindex: true, keygen: true, link: true, meta: true, param: true, source: true, track: true, wbr: true, path: true, circle: true, ellipse: true, line: true, rect: true, use: true, stop: true, polyline: true, polygon: true }; var re_nameEnd = /\s|\//; function Parser(cbs, options) {
            this._options = options || {}; this._cbs = cbs || {}; this._tagname = ""; this._attribname = ""; this._attribvalue = ""; this._attribs = null; this._stack = []; this.startIndex = 0; this.endIndex = null; this._lowerCaseTagNames = "lowerCaseTags" in this._options ? !!this._options.lowerCaseTags : !this._options.xmlMode; this._lowerCaseAttributeNames = "lowerCaseAttributeNames" in this._options ? !!this._options.lowerCaseAttributeNames : !this._options.xmlMode; if (this._options.Tokenizer) { Tokenizer = this._options.Tokenizer; }
            this._tokenizer = new Tokenizer(this._options, this); if (this._cbs.onparserinit) this._cbs.onparserinit(this);
        }
        __webpack_require__(16)(Parser, __webpack_require__(76).EventEmitter); Parser.prototype._updatePosition = function (initialOffset) {
            if (this.endIndex === null) { if (this._tokenizer._sectionStart <= initialOffset) { this.startIndex = 0; } else { this.startIndex = this._tokenizer._sectionStart - initialOffset; } }
            else this.startIndex = this.endIndex + 1; this.endIndex = this._tokenizer.getAbsoluteIndex();
        }; Parser.prototype.ontext = function (data) { this._updatePosition(1); this.endIndex--; if (this._cbs.ontext) this._cbs.ontext(data); }; Parser.prototype.onopentagname = function (name) {
            if (this._lowerCaseTagNames) { name = name.toLowerCase(); }
            this._tagname = name; if (!this._options.xmlMode && name in openImpliesClose) { for (var el; (el = this._stack[this._stack.length - 1]) in openImpliesClose[name]; this.onclosetag(el)); }
            if (this._options.xmlMode || !(name in voidElements)) { this._stack.push(name); }
            if (this._cbs.onopentagname) this._cbs.onopentagname(name); if (this._cbs.onopentag) this._attribs = {};
        }; Parser.prototype.onopentagend = function () {
            this._updatePosition(1); if (this._attribs) { if (this._cbs.onopentag) this._cbs.onopentag(this._tagname, this._attribs); this._attribs = null; }
            if (!this._options.xmlMode && this._cbs.onclosetag && this._tagname in voidElements) { this._cbs.onclosetag(this._tagname); }
            this._tagname = "";
        }; Parser.prototype.onclosetag = function (name) {
            this._updatePosition(1); if (this._lowerCaseTagNames) { name = name.toLowerCase(); }
            if (this._stack.length && (!(name in voidElements) || this._options.xmlMode)) {
                var pos = this._stack.lastIndexOf(name); if (pos !== -1) {
                    if (this._cbs.onclosetag) { pos = this._stack.length - pos; while (pos--) this._cbs.onclosetag(this._stack.pop()); }
                    else this._stack.length = pos;
                } else if (name === "p" && !this._options.xmlMode) { this.onopentagname(name); this._closeCurrentTag(); }
            } else if (!this._options.xmlMode && (name === "br" || name === "p")) { this.onopentagname(name); this._closeCurrentTag(); }
        }; Parser.prototype.onselfclosingtag = function () { if (this._options.xmlMode || this._options.recognizeSelfClosing) { this._closeCurrentTag(); } else { this.onopentagend(); } }; Parser.prototype._closeCurrentTag = function () {
            var name = this._tagname; this.onopentagend(); if (this._stack[this._stack.length - 1] === name) {
                if (this._cbs.onclosetag) { this._cbs.onclosetag(name); }
                this._stack.pop();
            }
        }; Parser.prototype.onattribname = function (name) {
            if (this._lowerCaseAttributeNames) { name = name.toLowerCase(); }
            this._attribname = name;
        }; Parser.prototype.onattribdata = function (value) { this._attribvalue += value; }; Parser.prototype.onattribend = function () {
            if (this._cbs.onattribute) this._cbs.onattribute(this._attribname, this._attribvalue); if (this._attribs && !Object.prototype.hasOwnProperty.call(this._attribs, this._attribname)) { this._attribs[this._attribname] = this._attribvalue; }
            this._attribname = ""; this._attribvalue = "";
        }; Parser.prototype._getInstructionName = function (value) {
            var idx = value.search(re_nameEnd), name = idx < 0 ? value : value.substr(0, idx); if (this._lowerCaseTagNames) { name = name.toLowerCase(); }
            return name;
        }; Parser.prototype.ondeclaration = function (value) { if (this._cbs.onprocessinginstruction) { var name = this._getInstructionName(value); this._cbs.onprocessinginstruction("!" + name, "!" + value); } }; Parser.prototype.onprocessinginstruction = function (value) { if (this._cbs.onprocessinginstruction) { var name = this._getInstructionName(value); this._cbs.onprocessinginstruction("?" + name, "?" + value); } }; Parser.prototype.oncomment = function (value) { this._updatePosition(4); if (this._cbs.oncomment) this._cbs.oncomment(value); if (this._cbs.oncommentend) this._cbs.oncommentend(); }; Parser.prototype.oncdata = function (value) { this._updatePosition(1); if (this._options.xmlMode || this._options.recognizeCDATA) { if (this._cbs.oncdatastart) this._cbs.oncdatastart(); if (this._cbs.ontext) this._cbs.ontext(value); if (this._cbs.oncdataend) this._cbs.oncdataend(); } else { this.oncomment("[CDATA[" + value + "]]"); } }; Parser.prototype.onerror = function (err) { if (this._cbs.onerror) this._cbs.onerror(err); }; Parser.prototype.onend = function () {
            if (this._cbs.onclosetag) { for (var i = this._stack.length; i > 0; this._cbs.onclosetag(this._stack[--i])); }
            if (this._cbs.onend) this._cbs.onend();
        }; Parser.prototype.reset = function () { if (this._cbs.onreset) this._cbs.onreset(); this._tokenizer.reset(); this._tagname = ""; this._attribname = ""; this._attribs = null; this._stack = []; if (this._cbs.onparserinit) this._cbs.onparserinit(this); }; Parser.prototype.parseComplete = function (data) { this.reset(); this.end(data); }; Parser.prototype.write = function (chunk) { this._tokenizer.write(chunk); }; Parser.prototype.end = function (chunk) { this._tokenizer.end(chunk); }; Parser.prototype.pause = function () { this._tokenizer.pause(); }; Parser.prototype.resume = function () { this._tokenizer.resume(); }; Parser.prototype.parseChunk = Parser.prototype.write; Parser.prototype.done = Parser.prototype.end; module.exports = Parser;
    }), (function (module, exports, __webpack_require__) {
        module.exports = Tokenizer; var decodeCodePoint = __webpack_require__(229), entityMap = __webpack_require__(120), legacyMap = __webpack_require__(230), xmlMap = __webpack_require__(121), i = 0, TEXT = i++, BEFORE_TAG_NAME = i++, IN_TAG_NAME = i++, IN_SELF_CLOSING_TAG = i++, BEFORE_CLOSING_TAG_NAME = i++, IN_CLOSING_TAG_NAME = i++, AFTER_CLOSING_TAG_NAME = i++, BEFORE_ATTRIBUTE_NAME = i++, IN_ATTRIBUTE_NAME = i++, AFTER_ATTRIBUTE_NAME = i++, BEFORE_ATTRIBUTE_VALUE = i++, IN_ATTRIBUTE_VALUE_DQ = i++, IN_ATTRIBUTE_VALUE_SQ = i++, IN_ATTRIBUTE_VALUE_NQ = i++, BEFORE_DECLARATION = i++, IN_DECLARATION = i++, IN_PROCESSING_INSTRUCTION = i++, BEFORE_COMMENT = i++, IN_COMMENT = i++, AFTER_COMMENT_1 = i++, AFTER_COMMENT_2 = i++, BEFORE_CDATA_1 = i++, BEFORE_CDATA_2 = i++, BEFORE_CDATA_3 = i++, BEFORE_CDATA_4 = i++, BEFORE_CDATA_5 = i++, BEFORE_CDATA_6 = i++, IN_CDATA = i++, AFTER_CDATA_1 = i++, AFTER_CDATA_2 = i++, BEFORE_SPECIAL = i++, BEFORE_SPECIAL_END = i++, BEFORE_SCRIPT_1 = i++, BEFORE_SCRIPT_2 = i++, BEFORE_SCRIPT_3 = i++, BEFORE_SCRIPT_4 = i++, BEFORE_SCRIPT_5 = i++, AFTER_SCRIPT_1 = i++, AFTER_SCRIPT_2 = i++, AFTER_SCRIPT_3 = i++, AFTER_SCRIPT_4 = i++, AFTER_SCRIPT_5 = i++, BEFORE_STYLE_1 = i++, BEFORE_STYLE_2 = i++, BEFORE_STYLE_3 = i++, BEFORE_STYLE_4 = i++, AFTER_STYLE_1 = i++, AFTER_STYLE_2 = i++, AFTER_STYLE_3 = i++, AFTER_STYLE_4 = i++, BEFORE_ENTITY = i++, BEFORE_NUMERIC_ENTITY = i++, IN_NAMED_ENTITY = i++, IN_NUMERIC_ENTITY = i++, IN_HEX_ENTITY = i++, j = 0, SPECIAL_NONE = j++, SPECIAL_SCRIPT = j++, SPECIAL_STYLE = j++; function whitespace(c) { return c === " " || c === "\n" || c === "\t" || c === "\f" || c === "\r"; }
        function characterState(char, SUCCESS) { return function (c) { if (c === char) this._state = SUCCESS; }; }
        function ifElseState(upper, SUCCESS, FAILURE) { var lower = upper.toLowerCase(); if (upper === lower) { return function (c) { if (c === lower) { this._state = SUCCESS; } else { this._state = FAILURE; this._index--; } }; } else { return function (c) { if (c === lower || c === upper) { this._state = SUCCESS; } else { this._state = FAILURE; this._index--; } }; } }
        function consumeSpecialNameChar(upper, NEXT_STATE) { var lower = upper.toLowerCase(); return function (c) { if (c === lower || c === upper) { this._state = NEXT_STATE; } else { this._state = IN_TAG_NAME; this._index--; } }; }
        function Tokenizer(options, cbs) { this._state = TEXT; this._buffer = ""; this._sectionStart = 0; this._index = 0; this._bufferOffset = 0; this._baseState = TEXT; this._special = SPECIAL_NONE; this._cbs = cbs; this._running = true; this._ended = false; this._xmlMode = !!(options && options.xmlMode); this._decodeEntities = !!(options && options.decodeEntities); }
        Tokenizer.prototype._stateText = function (c) {
            if (c === "<") {
                if (this._index > this._sectionStart) { this._cbs.ontext(this._getSection()); }
                this._state = BEFORE_TAG_NAME; this._sectionStart = this._index;
            } else if (this._decodeEntities && this._special === SPECIAL_NONE && c === "&") {
                if (this._index > this._sectionStart) { this._cbs.ontext(this._getSection()); }
                this._baseState = TEXT; this._state = BEFORE_ENTITY; this._sectionStart = this._index;
            }
        }; Tokenizer.prototype._stateBeforeTagName = function (c) { if (c === "/") { this._state = BEFORE_CLOSING_TAG_NAME; } else if (c === "<") { this._cbs.ontext(this._getSection()); this._sectionStart = this._index; } else if (c === ">" || this._special !== SPECIAL_NONE || whitespace(c)) { this._state = TEXT; } else if (c === "!") { this._state = BEFORE_DECLARATION; this._sectionStart = this._index + 1; } else if (c === "?") { this._state = IN_PROCESSING_INSTRUCTION; this._sectionStart = this._index + 1; } else { this._state = (!this._xmlMode && (c === "s" || c === "S")) ? BEFORE_SPECIAL : IN_TAG_NAME; this._sectionStart = this._index; } }; Tokenizer.prototype._stateInTagName = function (c) { if (c === "/" || c === ">" || whitespace(c)) { this._emitToken("onopentagname"); this._state = BEFORE_ATTRIBUTE_NAME; this._index--; } }; Tokenizer.prototype._stateBeforeCloseingTagName = function (c) { if (whitespace(c)); else if (c === ">") { this._state = TEXT; } else if (this._special !== SPECIAL_NONE) { if (c === "s" || c === "S") { this._state = BEFORE_SPECIAL_END; } else { this._state = TEXT; this._index--; } } else { this._state = IN_CLOSING_TAG_NAME; this._sectionStart = this._index; } }; Tokenizer.prototype._stateInCloseingTagName = function (c) { if (c === ">" || whitespace(c)) { this._emitToken("onclosetag"); this._state = AFTER_CLOSING_TAG_NAME; this._index--; } }; Tokenizer.prototype._stateAfterCloseingTagName = function (c) { if (c === ">") { this._state = TEXT; this._sectionStart = this._index + 1; } }; Tokenizer.prototype._stateBeforeAttributeName = function (c) { if (c === ">") { this._cbs.onopentagend(); this._state = TEXT; this._sectionStart = this._index + 1; } else if (c === "/") { this._state = IN_SELF_CLOSING_TAG; } else if (!whitespace(c)) { this._state = IN_ATTRIBUTE_NAME; this._sectionStart = this._index; } }; Tokenizer.prototype._stateInSelfClosingTag = function (c) { if (c === ">") { this._cbs.onselfclosingtag(); this._state = TEXT; this._sectionStart = this._index + 1; } else if (!whitespace(c)) { this._state = BEFORE_ATTRIBUTE_NAME; this._index--; } }; Tokenizer.prototype._stateInAttributeName = function (c) { if (c === "=" || c === "/" || c === ">" || whitespace(c)) { this._cbs.onattribname(this._getSection()); this._sectionStart = -1; this._state = AFTER_ATTRIBUTE_NAME; this._index--; } }; Tokenizer.prototype._stateAfterAttributeName = function (c) { if (c === "=") { this._state = BEFORE_ATTRIBUTE_VALUE; } else if (c === "/" || c === ">") { this._cbs.onattribend(); this._state = BEFORE_ATTRIBUTE_NAME; this._index--; } else if (!whitespace(c)) { this._cbs.onattribend(); this._state = IN_ATTRIBUTE_NAME; this._sectionStart = this._index; } }; Tokenizer.prototype._stateBeforeAttributeValue = function (c) { if (c === "\"") { this._state = IN_ATTRIBUTE_VALUE_DQ; this._sectionStart = this._index + 1; } else if (c === "'") { this._state = IN_ATTRIBUTE_VALUE_SQ; this._sectionStart = this._index + 1; } else if (!whitespace(c)) { this._state = IN_ATTRIBUTE_VALUE_NQ; this._sectionStart = this._index; this._index--; } }; Tokenizer.prototype._stateInAttributeValueDoubleQuotes = function (c) { if (c === "\"") { this._emitToken("onattribdata"); this._cbs.onattribend(); this._state = BEFORE_ATTRIBUTE_NAME; } else if (this._decodeEntities && c === "&") { this._emitToken("onattribdata"); this._baseState = this._state; this._state = BEFORE_ENTITY; this._sectionStart = this._index; } }; Tokenizer.prototype._stateInAttributeValueSingleQuotes = function (c) { if (c === "'") { this._emitToken("onattribdata"); this._cbs.onattribend(); this._state = BEFORE_ATTRIBUTE_NAME; } else if (this._decodeEntities && c === "&") { this._emitToken("onattribdata"); this._baseState = this._state; this._state = BEFORE_ENTITY; this._sectionStart = this._index; } }; Tokenizer.prototype._stateInAttributeValueNoQuotes = function (c) { if (whitespace(c) || c === ">") { this._emitToken("onattribdata"); this._cbs.onattribend(); this._state = BEFORE_ATTRIBUTE_NAME; this._index--; } else if (this._decodeEntities && c === "&") { this._emitToken("onattribdata"); this._baseState = this._state; this._state = BEFORE_ENTITY; this._sectionStart = this._index; } }; Tokenizer.prototype._stateBeforeDeclaration = function (c) { this._state = c === "[" ? BEFORE_CDATA_1 : c === "-" ? BEFORE_COMMENT : IN_DECLARATION; }; Tokenizer.prototype._stateInDeclaration = function (c) { if (c === ">") { this._cbs.ondeclaration(this._getSection()); this._state = TEXT; this._sectionStart = this._index + 1; } }; Tokenizer.prototype._stateInProcessingInstruction = function (c) { if (c === ">") { this._cbs.onprocessinginstruction(this._getSection()); this._state = TEXT; this._sectionStart = this._index + 1; } }; Tokenizer.prototype._stateBeforeComment = function (c) { if (c === "-") { this._state = IN_COMMENT; this._sectionStart = this._index + 1; } else { this._state = IN_DECLARATION; } }; Tokenizer.prototype._stateInComment = function (c) { if (c === "-") this._state = AFTER_COMMENT_1; }; Tokenizer.prototype._stateAfterComment1 = function (c) { if (c === "-") { this._state = AFTER_COMMENT_2; } else { this._state = IN_COMMENT; } }; Tokenizer.prototype._stateAfterComment2 = function (c) { if (c === ">") { this._cbs.oncomment(this._buffer.substring(this._sectionStart, this._index - 2)); this._state = TEXT; this._sectionStart = this._index + 1; } else if (c !== "-") { this._state = IN_COMMENT; } }; Tokenizer.prototype._stateBeforeCdata1 = ifElseState("C", BEFORE_CDATA_2, IN_DECLARATION); Tokenizer.prototype._stateBeforeCdata2 = ifElseState("D", BEFORE_CDATA_3, IN_DECLARATION); Tokenizer.prototype._stateBeforeCdata3 = ifElseState("A", BEFORE_CDATA_4, IN_DECLARATION); Tokenizer.prototype._stateBeforeCdata4 = ifElseState("T", BEFORE_CDATA_5, IN_DECLARATION); Tokenizer.prototype._stateBeforeCdata5 = ifElseState("A", BEFORE_CDATA_6, IN_DECLARATION); Tokenizer.prototype._stateBeforeCdata6 = function (c) { if (c === "[") { this._state = IN_CDATA; this._sectionStart = this._index + 1; } else { this._state = IN_DECLARATION; this._index--; } }; Tokenizer.prototype._stateInCdata = function (c) { if (c === "]") this._state = AFTER_CDATA_1; }; Tokenizer.prototype._stateAfterCdata1 = characterState("]", AFTER_CDATA_2); Tokenizer.prototype._stateAfterCdata2 = function (c) { if (c === ">") { this._cbs.oncdata(this._buffer.substring(this._sectionStart, this._index - 2)); this._state = TEXT; this._sectionStart = this._index + 1; } else if (c !== "]") { this._state = IN_CDATA; } }; Tokenizer.prototype._stateBeforeSpecial = function (c) { if (c === "c" || c === "C") { this._state = BEFORE_SCRIPT_1; } else if (c === "t" || c === "T") { this._state = BEFORE_STYLE_1; } else { this._state = IN_TAG_NAME; this._index--; } }; Tokenizer.prototype._stateBeforeSpecialEnd = function (c) {
            if (this._special === SPECIAL_SCRIPT && (c === "c" || c === "C")) { this._state = AFTER_SCRIPT_1; } else if (this._special === SPECIAL_STYLE && (c === "t" || c === "T")) { this._state = AFTER_STYLE_1; }
            else this._state = TEXT;
        }; Tokenizer.prototype._stateBeforeScript1 = consumeSpecialNameChar("R", BEFORE_SCRIPT_2); Tokenizer.prototype._stateBeforeScript2 = consumeSpecialNameChar("I", BEFORE_SCRIPT_3); Tokenizer.prototype._stateBeforeScript3 = consumeSpecialNameChar("P", BEFORE_SCRIPT_4); Tokenizer.prototype._stateBeforeScript4 = consumeSpecialNameChar("T", BEFORE_SCRIPT_5); Tokenizer.prototype._stateBeforeScript5 = function (c) {
            if (c === "/" || c === ">" || whitespace(c)) { this._special = SPECIAL_SCRIPT; }
            this._state = IN_TAG_NAME; this._index--;
        }; Tokenizer.prototype._stateAfterScript1 = ifElseState("R", AFTER_SCRIPT_2, TEXT); Tokenizer.prototype._stateAfterScript2 = ifElseState("I", AFTER_SCRIPT_3, TEXT); Tokenizer.prototype._stateAfterScript3 = ifElseState("P", AFTER_SCRIPT_4, TEXT); Tokenizer.prototype._stateAfterScript4 = ifElseState("T", AFTER_SCRIPT_5, TEXT); Tokenizer.prototype._stateAfterScript5 = function (c) {
            if (c === ">" || whitespace(c)) { this._special = SPECIAL_NONE; this._state = IN_CLOSING_TAG_NAME; this._sectionStart = this._index - 6; this._index--; }
            else this._state = TEXT;
        }; Tokenizer.prototype._stateBeforeStyle1 = consumeSpecialNameChar("Y", BEFORE_STYLE_2); Tokenizer.prototype._stateBeforeStyle2 = consumeSpecialNameChar("L", BEFORE_STYLE_3); Tokenizer.prototype._stateBeforeStyle3 = consumeSpecialNameChar("E", BEFORE_STYLE_4); Tokenizer.prototype._stateBeforeStyle4 = function (c) {
            if (c === "/" || c === ">" || whitespace(c)) { this._special = SPECIAL_STYLE; }
            this._state = IN_TAG_NAME; this._index--;
        }; Tokenizer.prototype._stateAfterStyle1 = ifElseState("Y", AFTER_STYLE_2, TEXT); Tokenizer.prototype._stateAfterStyle2 = ifElseState("L", AFTER_STYLE_3, TEXT); Tokenizer.prototype._stateAfterStyle3 = ifElseState("E", AFTER_STYLE_4, TEXT); Tokenizer.prototype._stateAfterStyle4 = function (c) {
            if (c === ">" || whitespace(c)) { this._special = SPECIAL_NONE; this._state = IN_CLOSING_TAG_NAME; this._sectionStart = this._index - 5; this._index--; }
            else this._state = TEXT;
        }; Tokenizer.prototype._stateBeforeEntity = ifElseState("#", BEFORE_NUMERIC_ENTITY, IN_NAMED_ENTITY); Tokenizer.prototype._stateBeforeNumericEntity = ifElseState("X", IN_HEX_ENTITY, IN_NUMERIC_ENTITY); Tokenizer.prototype._parseNamedEntityStrict = function () { if (this._sectionStart + 1 < this._index) { var entity = this._buffer.substring(this._sectionStart + 1, this._index), map = this._xmlMode ? xmlMap : entityMap; if (map.hasOwnProperty(entity)) { this._emitPartial(map[entity]); this._sectionStart = this._index + 1; } } }; Tokenizer.prototype._parseLegacyEntity = function () { var start = this._sectionStart + 1, limit = this._index - start; if (limit > 6) limit = 6; while (limit >= 2) { var entity = this._buffer.substr(start, limit); if (legacyMap.hasOwnProperty(entity)) { this._emitPartial(legacyMap[entity]); this._sectionStart += limit + 1; return; } else { limit--; } } }; Tokenizer.prototype._stateInNamedEntity = function (c) {
            if (c === ";") {
                this._parseNamedEntityStrict(); if (this._sectionStart + 1 < this._index && !this._xmlMode) { this._parseLegacyEntity(); }
                this._state = this._baseState;
            } else if ((c < "a" || c > "z") && (c < "A" || c > "Z") && (c < "0" || c > "9")) {
                if (this._xmlMode); else if (this._sectionStart + 1 === this._index); else if (this._baseState !== TEXT) { if (c !== "=") { this._parseNamedEntityStrict(); } } else { this._parseLegacyEntity(); }
                this._state = this._baseState; this._index--;
            }
        }; Tokenizer.prototype._decodeNumericEntity = function (offset, base) {
            var sectionStart = this._sectionStart + offset; if (sectionStart !== this._index) { var entity = this._buffer.substring(sectionStart, this._index); var parsed = parseInt(entity, base); this._emitPartial(decodeCodePoint(parsed)); this._sectionStart = this._index; } else { this._sectionStart--; }
            this._state = this._baseState;
        }; Tokenizer.prototype._stateInNumericEntity = function (c) {
            if (c === ";") { this._decodeNumericEntity(2, 10); this._sectionStart++; } else if (c < "0" || c > "9") {
                if (!this._xmlMode) { this._decodeNumericEntity(2, 10); } else { this._state = this._baseState; }
                this._index--;
            }
        }; Tokenizer.prototype._stateInHexEntity = function (c) {
            if (c === ";") { this._decodeNumericEntity(3, 16); this._sectionStart++; } else if ((c < "a" || c > "f") && (c < "A" || c > "F") && (c < "0" || c > "9")) {
                if (!this._xmlMode) { this._decodeNumericEntity(3, 16); } else { this._state = this._baseState; }
                this._index--;
            }
        }; Tokenizer.prototype._cleanup = function () {
            if (this._sectionStart < 0) { this._buffer = ""; this._bufferOffset += this._index; this._index = 0; } else if (this._running) {
                if (this._state === TEXT) {
                    if (this._sectionStart !== this._index) { this._cbs.ontext(this._buffer.substr(this._sectionStart)); }
                    this._buffer = ""; this._bufferOffset += this._index; this._index = 0;
                } else if (this._sectionStart === this._index) { this._buffer = ""; this._bufferOffset += this._index; this._index = 0; } else { this._buffer = this._buffer.substr(this._sectionStart); this._index -= this._sectionStart; this._bufferOffset += this._sectionStart; }
                this._sectionStart = 0;
            }
        }; Tokenizer.prototype.write = function (chunk) { if (this._ended) this._cbs.onerror(Error(".write() after done!")); this._buffer += chunk; this._parse(); }; Tokenizer.prototype._parse = function () {
            while (this._index < this._buffer.length && this._running) {
                var c = this._buffer.charAt(this._index); if (this._state === TEXT) { this._stateText(c); } else if (this._state === BEFORE_TAG_NAME) { this._stateBeforeTagName(c); } else if (this._state === IN_TAG_NAME) { this._stateInTagName(c); } else if (this._state === BEFORE_CLOSING_TAG_NAME) { this._stateBeforeCloseingTagName(c); } else if (this._state === IN_CLOSING_TAG_NAME) { this._stateInCloseingTagName(c); } else if (this._state === AFTER_CLOSING_TAG_NAME) { this._stateAfterCloseingTagName(c); } else if (this._state === IN_SELF_CLOSING_TAG) { this._stateInSelfClosingTag(c); }
                else if (this._state === BEFORE_ATTRIBUTE_NAME) { this._stateBeforeAttributeName(c); } else if (this._state === IN_ATTRIBUTE_NAME) { this._stateInAttributeName(c); } else if (this._state === AFTER_ATTRIBUTE_NAME) { this._stateAfterAttributeName(c); } else if (this._state === BEFORE_ATTRIBUTE_VALUE) { this._stateBeforeAttributeValue(c); } else if (this._state === IN_ATTRIBUTE_VALUE_DQ) { this._stateInAttributeValueDoubleQuotes(c); } else if (this._state === IN_ATTRIBUTE_VALUE_SQ) { this._stateInAttributeValueSingleQuotes(c); } else if (this._state === IN_ATTRIBUTE_VALUE_NQ) { this._stateInAttributeValueNoQuotes(c); }
                else if (this._state === BEFORE_DECLARATION) { this._stateBeforeDeclaration(c); } else if (this._state === IN_DECLARATION) { this._stateInDeclaration(c); }
                else if (this._state === IN_PROCESSING_INSTRUCTION) { this._stateInProcessingInstruction(c); }
                else if (this._state === BEFORE_COMMENT) { this._stateBeforeComment(c); } else if (this._state === IN_COMMENT) { this._stateInComment(c); } else if (this._state === AFTER_COMMENT_1) { this._stateAfterComment1(c); } else if (this._state === AFTER_COMMENT_2) { this._stateAfterComment2(c); }
                else if (this._state === BEFORE_CDATA_1) { this._stateBeforeCdata1(c); } else if (this._state === BEFORE_CDATA_2) { this._stateBeforeCdata2(c); } else if (this._state === BEFORE_CDATA_3) { this._stateBeforeCdata3(c); } else if (this._state === BEFORE_CDATA_4) { this._stateBeforeCdata4(c); } else if (this._state === BEFORE_CDATA_5) { this._stateBeforeCdata5(c); } else if (this._state === BEFORE_CDATA_6) { this._stateBeforeCdata6(c); } else if (this._state === IN_CDATA) { this._stateInCdata(c); } else if (this._state === AFTER_CDATA_1) { this._stateAfterCdata1(c); } else if (this._state === AFTER_CDATA_2) { this._stateAfterCdata2(c); }
                else if (this._state === BEFORE_SPECIAL) { this._stateBeforeSpecial(c); } else if (this._state === BEFORE_SPECIAL_END) { this._stateBeforeSpecialEnd(c); }
                else if (this._state === BEFORE_SCRIPT_1) { this._stateBeforeScript1(c); } else if (this._state === BEFORE_SCRIPT_2) { this._stateBeforeScript2(c); } else if (this._state === BEFORE_SCRIPT_3) { this._stateBeforeScript3(c); } else if (this._state === BEFORE_SCRIPT_4) { this._stateBeforeScript4(c); } else if (this._state === BEFORE_SCRIPT_5) { this._stateBeforeScript5(c); }
                else if (this._state === AFTER_SCRIPT_1) { this._stateAfterScript1(c); } else if (this._state === AFTER_SCRIPT_2) { this._stateAfterScript2(c); } else if (this._state === AFTER_SCRIPT_3) { this._stateAfterScript3(c); } else if (this._state === AFTER_SCRIPT_4) { this._stateAfterScript4(c); } else if (this._state === AFTER_SCRIPT_5) { this._stateAfterScript5(c); }
                else if (this._state === BEFORE_STYLE_1) { this._stateBeforeStyle1(c); } else if (this._state === BEFORE_STYLE_2) { this._stateBeforeStyle2(c); } else if (this._state === BEFORE_STYLE_3) { this._stateBeforeStyle3(c); } else if (this._state === BEFORE_STYLE_4) { this._stateBeforeStyle4(c); }
                else if (this._state === AFTER_STYLE_1) { this._stateAfterStyle1(c); } else if (this._state === AFTER_STYLE_2) { this._stateAfterStyle2(c); } else if (this._state === AFTER_STYLE_3) { this._stateAfterStyle3(c); } else if (this._state === AFTER_STYLE_4) { this._stateAfterStyle4(c); }
                else if (this._state === BEFORE_ENTITY) { this._stateBeforeEntity(c); } else if (this._state === BEFORE_NUMERIC_ENTITY) { this._stateBeforeNumericEntity(c); } else if (this._state === IN_NAMED_ENTITY) { this._stateInNamedEntity(c); } else if (this._state === IN_NUMERIC_ENTITY) { this._stateInNumericEntity(c); } else if (this._state === IN_HEX_ENTITY) { this._stateInHexEntity(c); }
                else { this._cbs.onerror(Error("unknown _state"), this._state); }
                this._index++;
            }
            this._cleanup();
        }; Tokenizer.prototype.pause = function () { this._running = false; }; Tokenizer.prototype.resume = function () {
            this._running = true; if (this._index < this._buffer.length) { this._parse(); }
            if (this._ended) { this._finish(); }
        }; Tokenizer.prototype.end = function (chunk) { if (this._ended) this._cbs.onerror(Error(".end() after done!")); if (chunk) this.write(chunk); this._ended = true; if (this._running) this._finish(); }; Tokenizer.prototype._finish = function () {
            if (this._sectionStart < this._index) { this._handleTrailingData(); }
            this._cbs.onend();
        }; Tokenizer.prototype._handleTrailingData = function () { var data = this._buffer.substr(this._sectionStart); if (this._state === IN_CDATA || this._state === AFTER_CDATA_1 || this._state === AFTER_CDATA_2) { this._cbs.oncdata(data); } else if (this._state === IN_COMMENT || this._state === AFTER_COMMENT_1 || this._state === AFTER_COMMENT_2) { this._cbs.oncomment(data); } else if (this._state === IN_NAMED_ENTITY && !this._xmlMode) { this._parseLegacyEntity(); if (this._sectionStart < this._index) { this._state = this._baseState; this._handleTrailingData(); } } else if (this._state === IN_NUMERIC_ENTITY && !this._xmlMode) { this._decodeNumericEntity(2, 10); if (this._sectionStart < this._index) { this._state = this._baseState; this._handleTrailingData(); } } else if (this._state === IN_HEX_ENTITY && !this._xmlMode) { this._decodeNumericEntity(3, 16); if (this._sectionStart < this._index) { this._state = this._baseState; this._handleTrailingData(); } } else if (this._state !== IN_TAG_NAME && this._state !== BEFORE_ATTRIBUTE_NAME && this._state !== BEFORE_ATTRIBUTE_VALUE && this._state !== AFTER_ATTRIBUTE_NAME && this._state !== IN_ATTRIBUTE_NAME && this._state !== IN_ATTRIBUTE_VALUE_SQ && this._state !== IN_ATTRIBUTE_VALUE_DQ && this._state !== IN_ATTRIBUTE_VALUE_NQ && this._state !== IN_CLOSING_TAG_NAME) { this._cbs.ontext(data); } }; Tokenizer.prototype.reset = function () { Tokenizer.call(this, { xmlMode: this._xmlMode, decodeEntities: this._decodeEntities }, this._cbs); }; Tokenizer.prototype.getAbsoluteIndex = function () { return this._bufferOffset + this._index; }; Tokenizer.prototype._getSection = function () { return this._buffer.substring(this._sectionStart, this._index); }; Tokenizer.prototype._emitToken = function (name) { this._cbs[name](this._getSection()); this._sectionStart = -1; }; Tokenizer.prototype._emitPartial = function (value) { if (this._baseState !== TEXT) { this._cbs.onattribdata(value); } else { this._cbs.ontext(value); } };
    }), (function (module, exports, __webpack_require__) {
        var decodeMap = __webpack_require__(486); module.exports = decodeCodePoint; function decodeCodePoint(codePoint) {
            if ((codePoint >= 0xD800 && codePoint <= 0xDFFF) || codePoint > 0x10FFFF) { return "\uFFFD"; }
            if (codePoint in decodeMap) { codePoint = decodeMap[codePoint]; }
            var output = ""; if (codePoint > 0xFFFF) { codePoint -= 0x10000; output += String.fromCharCode(codePoint >>> 10 & 0x3FF | 0xD800); codePoint = 0xDC00 | codePoint & 0x3FF; }
            output += String.fromCharCode(codePoint); return output;
        }
    }), (function (module, exports) { module.exports = { "Aacute": "Á", "aacute": "á", "Acirc": "Â", "acirc": "â", "acute": "´", "AElig": "Æ", "aelig": "æ", "Agrave": "À", "agrave": "à", "amp": "&", "AMP": "&", "Aring": "Å", "aring": "å", "Atilde": "Ã", "atilde": "ã", "Auml": "Ä", "auml": "ä", "brvbar": "¦", "Ccedil": "Ç", "ccedil": "ç", "cedil": "¸", "cent": "¢", "copy": "©", "COPY": "©", "curren": "¤", "deg": "°", "divide": "÷", "Eacute": "É", "eacute": "é", "Ecirc": "Ê", "ecirc": "ê", "Egrave": "È", "egrave": "è", "ETH": "Ð", "eth": "ð", "Euml": "Ë", "euml": "ë", "frac12": "½", "frac14": "¼", "frac34": "¾", "gt": ">", "GT": ">", "Iacute": "Í", "iacute": "í", "Icirc": "Î", "icirc": "î", "iexcl": "¡", "Igrave": "Ì", "igrave": "ì", "iquest": "¿", "Iuml": "Ï", "iuml": "ï", "laquo": "«", "lt": "<", "LT": "<", "macr": "¯", "micro": "µ", "middot": "·", "nbsp": " ", "not": "¬", "Ntilde": "Ñ", "ntilde": "ñ", "Oacute": "Ó", "oacute": "ó", "Ocirc": "Ô", "ocirc": "ô", "Ograve": "Ò", "ograve": "ò", "ordf": "ª", "ordm": "º", "Oslash": "Ø", "oslash": "ø", "Otilde": "Õ", "otilde": "õ", "Ouml": "Ö", "ouml": "ö", "para": "¶", "plusmn": "±", "pound": "£", "quot": "\"", "QUOT": "\"", "raquo": "»", "reg": "®", "REG": "®", "sect": "§", "shy": "­", "sup1": "¹", "sup2": "²", "sup3": "³", "szlig": "ß", "THORN": "Þ", "thorn": "þ", "times": "×", "Uacute": "Ú", "uacute": "ú", "Ucirc": "Û", "ucirc": "û", "Ugrave": "Ù", "ugrave": "ù", "uml": "¨", "Uuml": "Ü", "uuml": "ü", "Yacute": "Ý", "yacute": "ý", "yen": "¥", "yuml": "ÿ" } }), (function (module, exports) { var NodePrototype = module.exports = { get firstChild() { var children = this.children; return children && children[0] || null; }, get lastChild() { var children = this.children; return children && children[children.length - 1] || null; }, get nodeType() { return nodeTypes[this.type] || nodeTypes.element; } }; var domLvl1 = { tagName: "name", childNodes: "children", parentNode: "parent", previousSibling: "prev", nextSibling: "next", nodeValue: "data" }; var nodeTypes = { element: 1, text: 3, cdata: 4, comment: 8 }; Object.keys(domLvl1).forEach(function (key) { var shorthand = domLvl1[key]; Object.defineProperty(NodePrototype, key, { get: function () { return this[shorthand] || null; }, set: function (val) { this[shorthand] = val; return val; } }); }); }), (function (module, exports, __webpack_require__) {
        module.exports = Stream; var Parser = __webpack_require__(227), WritableStream = __webpack_require__(491).Writable || __webpack_require__(504).Writable, StringDecoder = __webpack_require__(125).StringDecoder, Buffer = __webpack_require__(123).Buffer; function Stream(cbs, options) { var parser = this._parser = new Parser(cbs, options); var decoder = this._decoder = new StringDecoder(); WritableStream.call(this, { decodeStrings: false }); this.once("finish", function () { parser.end(decoder.end()); }); }
        __webpack_require__(16)(Stream, WritableStream); WritableStream.prototype._write = function (chunk, encoding, cb) { if (chunk instanceof Buffer) chunk = this._decoder.write(chunk); this._parser.write(chunk); cb(); };
    }), (function (module, exports, __webpack_require__) {
        "use strict"; (function (global, process) {
            var processNextTick = __webpack_require__(77); module.exports = Readable; var isArray = __webpack_require__(234); var Duplex; Readable.ReadableState = ReadableState; var EE = __webpack_require__(76).EventEmitter; var EElistenerCount = function (emitter, type) { return emitter.listeners(type).length; }; var Stream = __webpack_require__(235); var Buffer = __webpack_require__(78).Buffer; var OurUint8Array = global.Uint8Array || function () { }; function _uint8ArrayToBuffer(chunk) { return Buffer.from(chunk); }
            function _isUint8Array(obj) { return Buffer.isBuffer(obj) || obj instanceof OurUint8Array; }
            var util = __webpack_require__(56); util.inherits = __webpack_require__(16); var debugUtil = __webpack_require__(494); var debug = void 0; if (debugUtil && debugUtil.debuglog) { debug = debugUtil.debuglog('stream'); } else { debug = function () { }; }
            var BufferList = __webpack_require__(495); var destroyImpl = __webpack_require__(236); var StringDecoder; util.inherits(Readable, Stream); var kProxyEvents = ['error', 'close', 'destroy', 'pause', 'resume']; function prependListener(emitter, event, fn) { if (typeof emitter.prependListener === 'function') { return emitter.prependListener(event, fn); } else { if (!emitter._events || !emitter._events[event]) emitter.on(event, fn); else if (isArray(emitter._events[event])) emitter._events[event].unshift(fn); else emitter._events[event] = [fn, emitter._events[event]]; } }
            function ReadableState(options, stream) { Duplex = Duplex || __webpack_require__(33); options = options || {}; this.objectMode = !!options.objectMode; if (stream instanceof Duplex) this.objectMode = this.objectMode || !!options.readableObjectMode; var hwm = options.highWaterMark; var defaultHwm = this.objectMode ? 16 : 16 * 1024; this.highWaterMark = hwm || hwm === 0 ? hwm : defaultHwm; this.highWaterMark = Math.floor(this.highWaterMark); this.buffer = new BufferList(); this.length = 0; this.pipes = null; this.pipesCount = 0; this.flowing = null; this.ended = false; this.endEmitted = false; this.reading = false; this.sync = true; this.needReadable = false; this.emittedReadable = false; this.readableListening = false; this.resumeScheduled = false; this.destroyed = false; this.defaultEncoding = options.defaultEncoding || 'utf8'; this.awaitDrain = 0; this.readingMore = false; this.decoder = null; this.encoding = null; if (options.encoding) { if (!StringDecoder) StringDecoder = __webpack_require__(125).StringDecoder; this.decoder = new StringDecoder(options.encoding); this.encoding = options.encoding; } }
            function Readable(options) {
                Duplex = Duplex || __webpack_require__(33); if (!(this instanceof Readable)) return new Readable(options); this._readableState = new ReadableState(options, this); this.readable = true; if (options) { if (typeof options.read === 'function') this._read = options.read; if (typeof options.destroy === 'function') this._destroy = options.destroy; }
                Stream.call(this);
            }
            Object.defineProperty(Readable.prototype, 'destroyed', {
                get: function () {
                    if (this._readableState === undefined) { return false; }
                    return this._readableState.destroyed;
                }, set: function (value) {
                    if (!this._readableState) { return; }
                    this._readableState.destroyed = value;
                }
            }); Readable.prototype.destroy = destroyImpl.destroy; Readable.prototype._undestroy = destroyImpl.undestroy; Readable.prototype._destroy = function (err, cb) { this.push(null); cb(err); }; Readable.prototype.push = function (chunk, encoding) {
                var state = this._readableState; var skipChunkCheck; if (!state.objectMode) {
                    if (typeof chunk === 'string') {
                        encoding = encoding || state.defaultEncoding; if (encoding !== state.encoding) { chunk = Buffer.from(chunk, encoding); encoding = ''; }
                        skipChunkCheck = true;
                    }
                } else { skipChunkCheck = true; }
                return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
            }; Readable.prototype.unshift = function (chunk) { return readableAddChunk(this, chunk, null, true, false); }; function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
                var state = stream._readableState; if (chunk === null) { state.reading = false; onEofChunk(stream, state); } else {
                    var er; if (!skipChunkCheck) er = chunkInvalid(state, chunk); if (er) { stream.emit('error', er); } else if (state.objectMode || chunk && chunk.length > 0) {
                        if (typeof chunk !== 'string' && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer.prototype) { chunk = _uint8ArrayToBuffer(chunk); }
                        if (addToFront) { if (state.endEmitted) stream.emit('error', new Error('stream.unshift() after end event')); else addChunk(stream, state, chunk, true); } else if (state.ended) { stream.emit('error', new Error('stream.push() after EOF')); } else { state.reading = false; if (state.decoder && !encoding) { chunk = state.decoder.write(chunk); if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false); else maybeReadMore(stream, state); } else { addChunk(stream, state, chunk, false); } }
                    } else if (!addToFront) { state.reading = false; }
                }
                return needMoreData(state);
            }
            function addChunk(stream, state, chunk, addToFront) {
                if (state.flowing && state.length === 0 && !state.sync) { stream.emit('data', chunk); stream.read(0); } else { state.length += state.objectMode ? 1 : chunk.length; if (addToFront) state.buffer.unshift(chunk); else state.buffer.push(chunk); if (state.needReadable) emitReadable(stream); }
                maybeReadMore(stream, state);
            }
            function chunkInvalid(state, chunk) {
                var er; if (!_isUint8Array(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) { er = new TypeError('Invalid non-string/buffer chunk'); }
                return er;
            }
            function needMoreData(state) { return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0); }
            Readable.prototype.isPaused = function () { return this._readableState.flowing === false; }; Readable.prototype.setEncoding = function (enc) { if (!StringDecoder) StringDecoder = __webpack_require__(125).StringDecoder; this._readableState.decoder = new StringDecoder(enc); this._readableState.encoding = enc; return this; }; var MAX_HWM = 0x800000; function computeNewHighWaterMark(n) {
                if (n >= MAX_HWM) { n = MAX_HWM; } else { n--; n |= n >>> 1; n |= n >>> 2; n |= n >>> 4; n |= n >>> 8; n |= n >>> 16; n++; }
                return n;
            }
            function howMuchToRead(n, state) {
                if (n <= 0 || state.length === 0 && state.ended) return 0; if (state.objectMode) return 1; if (n !== n) { if (state.flowing && state.length) return state.buffer.head.data.length; else return state.length; }
                if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n); if (n <= state.length) return n; if (!state.ended) { state.needReadable = true; return 0; }
                return state.length;
            }
            Readable.prototype.read = function (n) {
                debug('read', n); n = parseInt(n, 10); var state = this._readableState; var nOrig = n; if (n !== 0) state.emittedReadable = false; if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) { debug('read: emitReadable', state.length, state.ended); if (state.length === 0 && state.ended) endReadable(this); else emitReadable(this); return null; }
                n = howMuchToRead(n, state); if (n === 0 && state.ended) { if (state.length === 0) endReadable(this); return null; }
                var doRead = state.needReadable; debug('need readable', doRead); if (state.length === 0 || state.length - n < state.highWaterMark) { doRead = true; debug('length less than watermark', doRead); }
                if (state.ended || state.reading) { doRead = false; debug('reading or ended', doRead); } else if (doRead) { debug('do read'); state.reading = true; state.sync = true; if (state.length === 0) state.needReadable = true; this._read(state.highWaterMark); state.sync = false; if (!state.reading) n = howMuchToRead(nOrig, state); }
                var ret; if (n > 0) ret = fromList(n, state); else ret = null; if (ret === null) { state.needReadable = true; n = 0; } else { state.length -= n; }
                if (state.length === 0) { if (!state.ended) state.needReadable = true; if (nOrig !== n && state.ended) endReadable(this); }
                if (ret !== null) this.emit('data', ret); return ret;
            }; function onEofChunk(stream, state) {
                if (state.ended) return; if (state.decoder) { var chunk = state.decoder.end(); if (chunk && chunk.length) { state.buffer.push(chunk); state.length += state.objectMode ? 1 : chunk.length; } }
                state.ended = true; emitReadable(stream);
            }
            function emitReadable(stream) { var state = stream._readableState; state.needReadable = false; if (!state.emittedReadable) { debug('emitReadable', state.flowing); state.emittedReadable = true; if (state.sync) processNextTick(emitReadable_, stream); else emitReadable_(stream); } }
            function emitReadable_(stream) { debug('emit readable'); stream.emit('readable'); flow(stream); }
            function maybeReadMore(stream, state) { if (!state.readingMore) { state.readingMore = true; processNextTick(maybeReadMore_, stream, state); } }
            function maybeReadMore_(stream, state) {
                var len = state.length; while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {
                    debug('maybeReadMore read 0'); stream.read(0); if (len === state.length)
                        break; else len = state.length;
                }
                state.readingMore = false;
            }
            Readable.prototype._read = function (n) { this.emit('error', new Error('_read() is not implemented')); }; Readable.prototype.pipe = function (dest, pipeOpts) {
                var src = this; var state = this._readableState; switch (state.pipesCount) { case 0: state.pipes = dest; break; case 1: state.pipes = [state.pipes, dest]; break; default: state.pipes.push(dest); break; }
                state.pipesCount += 1; debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts); var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr; var endFn = doEnd ? onend : unpipe; if (state.endEmitted) processNextTick(endFn); else src.once('end', endFn); dest.on('unpipe', onunpipe); function onunpipe(readable, unpipeInfo) { debug('onunpipe'); if (readable === src) { if (unpipeInfo && unpipeInfo.hasUnpiped === false) { unpipeInfo.hasUnpiped = true; cleanup(); } } }
                function onend() { debug('onend'); dest.end(); }
                var ondrain = pipeOnDrain(src); dest.on('drain', ondrain); var cleanedUp = false; function cleanup() { debug('cleanup'); dest.removeListener('close', onclose); dest.removeListener('finish', onfinish); dest.removeListener('drain', ondrain); dest.removeListener('error', onerror); dest.removeListener('unpipe', onunpipe); src.removeListener('end', onend); src.removeListener('end', unpipe); src.removeListener('data', ondata); cleanedUp = true; if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain(); }
                var increasedAwaitDrain = false; src.on('data', ondata); function ondata(chunk) {
                    debug('ondata'); increasedAwaitDrain = false; var ret = dest.write(chunk); if (false === ret && !increasedAwaitDrain) {
                        if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) { debug('false write response, pause', src._readableState.awaitDrain); src._readableState.awaitDrain++; increasedAwaitDrain = true; }
                        src.pause();
                    }
                }
                function onerror(er) { debug('onerror', er); unpipe(); dest.removeListener('error', onerror); if (EElistenerCount(dest, 'error') === 0) dest.emit('error', er); }
                prependListener(dest, 'error', onerror); function onclose() { dest.removeListener('finish', onfinish); unpipe(); }
                dest.once('close', onclose); function onfinish() { debug('onfinish'); dest.removeListener('close', onclose); unpipe(); }
                dest.once('finish', onfinish); function unpipe() { debug('unpipe'); src.unpipe(dest); }
                dest.emit('pipe', src); if (!state.flowing) { debug('pipe resume'); src.resume(); }
                return dest;
            }; function pipeOnDrain(src) { return function () { var state = src._readableState; debug('pipeOnDrain', state.awaitDrain); if (state.awaitDrain) state.awaitDrain--; if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) { state.flowing = true; flow(src); } }; }
            Readable.prototype.unpipe = function (dest) {
                var state = this._readableState; var unpipeInfo = { hasUnpiped: false }; if (state.pipesCount === 0) return this; if (state.pipesCount === 1) { if (dest && dest !== state.pipes) return this; if (!dest) dest = state.pipes; state.pipes = null; state.pipesCount = 0; state.flowing = false; if (dest) dest.emit('unpipe', this, unpipeInfo); return this; }
                if (!dest) { var dests = state.pipes; var len = state.pipesCount; state.pipes = null; state.pipesCount = 0; state.flowing = false; for (var i = 0; i < len; i++) { dests[i].emit('unpipe', this, unpipeInfo); } return this; }
                var index = indexOf(state.pipes, dest); if (index === -1) return this; state.pipes.splice(index, 1); state.pipesCount -= 1; if (state.pipesCount === 1) state.pipes = state.pipes[0]; dest.emit('unpipe', this, unpipeInfo); return this;
            }; Readable.prototype.on = function (ev, fn) {
                var res = Stream.prototype.on.call(this, ev, fn); if (ev === 'data') { if (this._readableState.flowing !== false) this.resume(); } else if (ev === 'readable') { var state = this._readableState; if (!state.endEmitted && !state.readableListening) { state.readableListening = state.needReadable = true; state.emittedReadable = false; if (!state.reading) { processNextTick(nReadingNextTick, this); } else if (state.length) { emitReadable(this); } } }
                return res;
            }; Readable.prototype.addListener = Readable.prototype.on; function nReadingNextTick(self) { debug('readable nexttick read 0'); self.read(0); }
            Readable.prototype.resume = function () {
                var state = this._readableState; if (!state.flowing) { debug('resume'); state.flowing = true; resume(this, state); }
                return this;
            }; function resume(stream, state) { if (!state.resumeScheduled) { state.resumeScheduled = true; processNextTick(resume_, stream, state); } }
            function resume_(stream, state) {
                if (!state.reading) { debug('resume read 0'); stream.read(0); }
                state.resumeScheduled = false; state.awaitDrain = 0; stream.emit('resume'); flow(stream); if (state.flowing && !state.reading) stream.read(0);
            }
            Readable.prototype.pause = function () {
                debug('call pause flowing=%j', this._readableState.flowing); if (false !== this._readableState.flowing) { debug('pause'); this._readableState.flowing = false; this.emit('pause'); }
                return this;
            }; function flow(stream) { var state = stream._readableState; debug('flow', state.flowing); while (state.flowing && stream.read() !== null) { } }
            Readable.prototype.wrap = function (stream) {
                var state = this._readableState; var paused = false; var self = this; stream.on('end', function () {
                    debug('wrapped end'); if (state.decoder && !state.ended) { var chunk = state.decoder.end(); if (chunk && chunk.length) self.push(chunk); }
                    self.push(null);
                }); stream.on('data', function (chunk) { debug('wrapped data'); if (state.decoder) chunk = state.decoder.write(chunk); if (state.objectMode && (chunk === null || chunk === undefined)) return; else if (!state.objectMode && (!chunk || !chunk.length)) return; var ret = self.push(chunk); if (!ret) { paused = true; stream.pause(); } }); for (var i in stream) { if (this[i] === undefined && typeof stream[i] === 'function') { this[i] = function (method) { return function () { return stream[method].apply(stream, arguments); }; }(i); } }
                for (var n = 0; n < kProxyEvents.length; n++) { stream.on(kProxyEvents[n], self.emit.bind(self, kProxyEvents[n])); }
                self._read = function (n) { debug('wrapped _read', n); if (paused) { paused = false; stream.resume(); } }; return self;
            }; Readable._fromList = fromList; function fromList(n, state) {
                if (state.length === 0) return null; var ret; if (state.objectMode) ret = state.buffer.shift(); else if (!n || n >= state.length) { if (state.decoder) ret = state.buffer.join(''); else if (state.buffer.length === 1) ret = state.buffer.head.data; else ret = state.buffer.concat(state.length); state.buffer.clear(); } else { ret = fromListPartial(n, state.buffer, state.decoder); }
                return ret;
            }
            function fromListPartial(n, list, hasStrings) {
                var ret; if (n < list.head.data.length) { ret = list.head.data.slice(0, n); list.head.data = list.head.data.slice(n); } else if (n === list.head.data.length) { ret = list.shift(); } else { ret = hasStrings ? copyFromBufferString(n, list) : copyFromBuffer(n, list); }
                return ret;
            }
            function copyFromBufferString(n, list) {
                var p = list.head; var c = 1; var ret = p.data; n -= ret.length; while (p = p.next) {
                    var str = p.data; var nb = n > str.length ? str.length : n; if (nb === str.length) ret += str; else ret += str.slice(0, n); n -= nb; if (n === 0) {
                        if (nb === str.length) { ++c; if (p.next) list.head = p.next; else list.head = list.tail = null; } else { list.head = p; p.data = str.slice(nb); }
                        break;
                    }
                    ++c;
                }
                list.length -= c; return ret;
            }
            function copyFromBuffer(n, list) {
                var ret = Buffer.allocUnsafe(n); var p = list.head; var c = 1; p.data.copy(ret); n -= p.data.length; while (p = p.next) {
                    var buf = p.data; var nb = n > buf.length ? buf.length : n; buf.copy(ret, ret.length - n, 0, nb); n -= nb; if (n === 0) {
                        if (nb === buf.length) { ++c; if (p.next) list.head = p.next; else list.head = list.tail = null; } else { list.head = p; p.data = buf.slice(nb); }
                        break;
                    }
                    ++c;
                }
                list.length -= c; return ret;
            }
            function endReadable(stream) { var state = stream._readableState; if (state.length > 0) throw new Error('"endReadable()" called on non-empty stream'); if (!state.endEmitted) { state.ended = true; processNextTick(endReadableNT, state, stream); } }
            function endReadableNT(state, stream) { if (!state.endEmitted && state.length === 0) { state.endEmitted = true; stream.readable = false; stream.emit('end'); } }
            function forEach(xs, f) { for (var i = 0, l = xs.length; i < l; i++) { f(xs[i], i); } }
            function indexOf(xs, x) {
                for (var i = 0, l = xs.length; i < l; i++) { if (xs[i] === x) return i; }
                return -1;
            }
        }.call(exports, __webpack_require__(17), __webpack_require__(41)))
    }), (function (module, exports) { var toString = {}.toString; module.exports = Array.isArray || function (arr) { return toString.call(arr) == '[object Array]'; }; }), (function (module, exports, __webpack_require__) { module.exports = __webpack_require__(76).EventEmitter; }), (function (module, exports, __webpack_require__) {
        "use strict"; var processNextTick = __webpack_require__(77); function destroy(err, cb) {
            var _this = this; var readableDestroyed = this._readableState && this._readableState.destroyed; var writableDestroyed = this._writableState && this._writableState.destroyed; if (readableDestroyed || writableDestroyed) {
                if (cb) { cb(err); } else if (err && (!this._writableState || !this._writableState.errorEmitted)) { processNextTick(emitErrorNT, this, err); }
                return;
            }
            if (this._readableState) { this._readableState.destroyed = true; }
            if (this._writableState) { this._writableState.destroyed = true; }
            this._destroy(err || null, function (err) { if (!cb && err) { processNextTick(emitErrorNT, _this, err); if (_this._writableState) { _this._writableState.errorEmitted = true; } } else if (cb) { cb(err); } });
        }
        function undestroy() {
            if (this._readableState) { this._readableState.destroyed = false; this._readableState.reading = false; this._readableState.ended = false; this._readableState.endEmitted = false; }
            if (this._writableState) { this._writableState.destroyed = false; this._writableState.ended = false; this._writableState.ending = false; this._writableState.finished = false; this._writableState.errorEmitted = false; }
        }
        function emitErrorNT(self, err) { self.emit('error', err); }
        module.exports = { destroy: destroy, undestroy: undestroy };
    }), (function (module, exports, __webpack_require__) {
        "use strict"; module.exports = Transform; var Duplex = __webpack_require__(33); var util = __webpack_require__(56); util.inherits = __webpack_require__(16); util.inherits(Transform, Duplex); function TransformState(stream) { this.afterTransform = function (er, data) { return afterTransform(stream, er, data); }; this.needTransform = false; this.transforming = false; this.writecb = null; this.writechunk = null; this.writeencoding = null; }
        function afterTransform(stream, er, data) {
            var ts = stream._transformState; ts.transforming = false; var cb = ts.writecb; if (!cb) { return stream.emit('error', new Error('write callback called multiple times')); }
            ts.writechunk = null; ts.writecb = null; if (data !== null && data !== undefined) stream.push(data); cb(er); var rs = stream._readableState; rs.reading = false; if (rs.needReadable || rs.length < rs.highWaterMark) { stream._read(rs.highWaterMark); }
        }
        function Transform(options) {
            if (!(this instanceof Transform)) return new Transform(options); Duplex.call(this, options); this._transformState = new TransformState(this); var stream = this; this._readableState.needReadable = true; this._readableState.sync = false; if (options) { if (typeof options.transform === 'function') this._transform = options.transform; if (typeof options.flush === 'function') this._flush = options.flush; }
            this.once('prefinish', function () { if (typeof this._flush === 'function') this._flush(function (er, data) { done(stream, er, data); }); else done(stream); });
        }
        Transform.prototype.push = function (chunk, encoding) { this._transformState.needTransform = false; return Duplex.prototype.push.call(this, chunk, encoding); }; Transform.prototype._transform = function (chunk, encoding, cb) { throw new Error('_transform() is not implemented'); }; Transform.prototype._write = function (chunk, encoding, cb) { var ts = this._transformState; ts.writecb = cb; ts.writechunk = chunk; ts.writeencoding = encoding; if (!ts.transforming) { var rs = this._readableState; if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark); } }; Transform.prototype._read = function (n) { var ts = this._transformState; if (ts.writechunk !== null && ts.writecb && !ts.transforming) { ts.transforming = true; this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform); } else { ts.needTransform = true; } }; Transform.prototype._destroy = function (err, cb) { var _this = this; Duplex.prototype._destroy.call(this, err, function (err2) { cb(err2); _this.emit('close'); }); }; function done(stream, er, data) { if (er) return stream.emit('error', er); if (data !== null && data !== undefined) stream.push(data); var ws = stream._writableState; var ts = stream._transformState; if (ws.length) throw new Error('Calling transform done when ws.length != 0'); if (ts.transforming) throw new Error('Calling transform done when still transforming'); return stream.push(null); }
    }), (function (module, exports, __webpack_require__) { __webpack_require__(239); var SnippetPreview = __webpack_require__(126).SnippetPreview; var App = __webpack_require__(126).App; var removeMarks = __webpack_require__(519); var bindEvents = function (app) { document.getElementById("focusKeyword").addEventListener("input", app.analyzeTimer.bind(app)); tinymce.get("content").on("change", app.analyzeTimer.bind(app)) }; window.onload = function () { var snippetPreview = new SnippetPreview({ targetElement: document.getElementById("snippet") }); var app = new App({ snippetPreview: snippetPreview, targets: { output: "output", contentOutput: "contentOutput" }, callbacks: { getData: function () { return { keyword: document.getElementById("focusKeyword").value, text: tinymce.get("content").getContent() }; } }, marker: function (paper, marks) { var text = paper.getText(); text = removeMarks(text); marks.forEach(mark => text = mark.applyWithReplace(text)); tinymce.get("content").setContent(text); var markElements = tinymce.get("content").dom.select("yoastmark"); markElements.forEach(markElement => { markElement.setAttribute("style", "background-color: #e1bee7;"); markElement.setAttribute("data-mce-bogus", "1"); }); jQuery("html, body").animate({ scrollTop: jQuery("#inputForm").offset().top }, 500); } }); bindEvents(app); app.refresh(); var args = { usedKeywords: { "keyword": [1], "test": [2, 3, 4] }, searchUrl: "http://example.com/post?id={id}", postUrl: "http://example.com/search?kw={keyword}" }; }; }), (function (module, exports) { }), (function (module, exports, __webpack_require__) {
        "use strict"; var AssessmentResult = __webpack_require__(0); var isUndefined = __webpack_require__(3); var MissingArgument = __webpack_require__(57); var PreviouslyUsedKeyword = function PreviouslyUsedKeyword(app, args) {
            if (isUndefined(app)) { throw new MissingArgument("The previously keyword plugin requires the YoastSEO app"); }
            if (isUndefined(args)) { args = { usedKeywords: {}, searchUrl: "", postUrl: "" }; }
            this.app = app; this.usedKeywords = args.usedKeywords; this.searchUrl = args.searchUrl; this.postUrl = args.postUrl;
        }; PreviouslyUsedKeyword.prototype.registerPlugin = function () { this.app.registerAssessment("usedKeywords", { getResult: this.assess.bind(this), isApplicable: function isApplicable(paper) { return paper.hasKeyword(); } }, "previouslyUsedKeywords"); }; PreviouslyUsedKeyword.prototype.updateKeywordUsage = function (usedKeywords) { this.usedKeywords = usedKeywords; }; PreviouslyUsedKeyword.prototype.scoreAssessment = function (previouslyUsedKeywords, paper, i18n) {
            var count = previouslyUsedKeywords.count; var id = previouslyUsedKeywords.id; if (count === 0) { return { text: i18n.dgettext("js-text-analysis", "You've never used this focus keyword before, very good."), score: 9 }; }
            if (count === 1) { var url = "<a href='" + this.postUrl.replace("{id}", id) + "' target='_blank'>"; return { text: i18n.sprintf(i18n.dgettext("js-text-analysis", "You've used this focus keyword %1$sonce before%2$s. " + "It’s probably a good idea to read about %3$swhy you should not use your focus keyword more than once%4$s."), url, "</a>", "<a href='https://yoa.st/20x' target='_blank' rel='noopener noreferrer'>", "</a>"), score: 6 }; }
            if (count > 1) { url = "<a href='" + this.searchUrl.replace("{keyword}", encodeURIComponent(paper.getKeyword())) + "' target='_blank'>"; return { text: i18n.sprintf(i18n.dgettext("js-text-analysis", "You've used this focus keyword %1$s%2$d times before%3$s. " + "It’s probably a good idea to read about %4$swhy you should not use your focus keyword more than once%5$s."), url, count, "</a>", "<a href='https://yoa.st/20x' target='_blank' rel='noopener noreferrer'>", "</a>"), score: 1 }; }
        }; PreviouslyUsedKeyword.prototype.researchPreviouslyUsedKeywords = function (paper) {
            var keyword = paper.getKeyword(); var count = 0; var id = 0; if (!isUndefined(this.usedKeywords[keyword])) { count = this.usedKeywords[keyword].length; id = this.usedKeywords[keyword][0]; }
            return { id: id, count: count };
        }; PreviouslyUsedKeyword.prototype.assess = function (paper, researcher, i18n) { var previouslyUsedKeywords = this.researchPreviouslyUsedKeywords(paper); var previouslyUsedKeywordsResult = this.scoreAssessment(previouslyUsedKeywords, paper, i18n); var assessmentResult = new AssessmentResult(); assessmentResult.setScore(previouslyUsedKeywordsResult.score); assessmentResult.setText(previouslyUsedKeywordsResult.text); return assessmentResult; }; module.exports = PreviouslyUsedKeyword;
    }), (function (module, exports, __webpack_require__) {
        var Symbol = __webpack_require__(34); var objectProto = Object.prototype; var hasOwnProperty = objectProto.hasOwnProperty; var nativeObjectToString = objectProto.toString; var symToStringTag = Symbol ? Symbol.toStringTag : undefined; function getRawTag(value) {
            var isOwn = hasOwnProperty.call(value, symToStringTag), tag = value[symToStringTag]; try { value[symToStringTag] = undefined; var unmasked = true; } catch (e) { }
            var result = nativeObjectToString.call(value); if (unmasked) { if (isOwn) { value[symToStringTag] = tag; } else { delete value[symToStringTag]; } }
            return result;
        }
        module.exports = getRawTag;
    }), (function (module, exports) {
        var objectProto = Object.prototype; var nativeObjectToString = objectProto.toString; function objectToString(value) { return nativeObjectToString.call(value); }
        module.exports = objectToString;
    }), (function (module, exports) { module.exports = function isBuffer(arg) { return arg && typeof arg === 'object' && typeof arg.copy === 'function' && typeof arg.fill === 'function' && typeof arg.readUInt8 === 'function'; } }), (function (module, exports) {
        if (typeof Object.create === 'function') {
            module.exports = function inherits(ctor, superCtor) {
                ctor.super_ = superCtor
                ctor.prototype = Object.create(superCtor.prototype, { constructor: { value: ctor, enumerable: false, writable: true, configurable: true } });
            };
        } else {
            module.exports = function inherits(ctor, superCtor) {
                ctor.super_ = superCtor
                var TempCtor = function () { }
                TempCtor.prototype = superCtor.prototype
                ctor.prototype = new TempCtor()
                ctor.prototype.constructor = ctor
            }
        }
    }), (function (module, exports, __webpack_require__) { "use strict"; Object.defineProperty(exports, "__esModule", { value: true }); exports.default = function (paper) { return getSentences(paper.getText()); }; var getSentences = __webpack_require__(22); }), (function (module, exports, __webpack_require__) {
        var baseIsMatch = __webpack_require__(247), getMatchData = __webpack_require__(289), matchesStrictComparable = __webpack_require__(141); function baseMatches(source) {
            var matchData = getMatchData(source); if (matchData.length == 1 && matchData[0][2]) { return matchesStrictComparable(matchData[0][0], matchData[0][1]); }
            return function (object) { return object === source || baseIsMatch(object, source, matchData); };
        }
        module.exports = baseMatches;
    }), (function (module, exports, __webpack_require__) {
        var Stack = __webpack_require__(58), baseIsEqual = __webpack_require__(129); var COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2; function baseIsMatch(object, source, matchData, customizer) {
            var index = matchData.length, length = index, noCustomizer = !customizer; if (object == null) { return !length; }
            object = Object(object); while (index--) { var data = matchData[index]; if ((noCustomizer && data[2]) ? data[1] !== object[data[0]] : !(data[0] in object)) { return false; } }
            while (++index < length) {
                data = matchData[index]; var key = data[0], objValue = object[key], srcValue = data[1]; if (noCustomizer && data[2]) { if (objValue === undefined && !(key in object)) { return false; } } else {
                    var stack = new Stack; if (customizer) { var result = customizer(objValue, srcValue, key, object, source, stack); }
                    if (!(result === undefined ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack) : result)) { return false; }
                }
            }
            return true;
        }
        module.exports = baseIsMatch;
    }), (function (module, exports) {
        function listCacheClear() { this.__data__ = []; this.size = 0; }
        module.exports = listCacheClear;
    }), (function (module, exports, __webpack_require__) {
        var assocIndexOf = __webpack_require__(60); var arrayProto = Array.prototype; var splice = arrayProto.splice; function listCacheDelete(key) {
            var data = this.__data__, index = assocIndexOf(data, key); if (index < 0) { return false; }
            var lastIndex = data.length - 1; if (index == lastIndex) { data.pop(); } else { splice.call(data, index, 1); }
            --this.size; return true;
        }
        module.exports = listCacheDelete;
    }), (function (module, exports, __webpack_require__) {
        var assocIndexOf = __webpack_require__(60); function listCacheGet(key) { var data = this.__data__, index = assocIndexOf(data, key); return index < 0 ? undefined : data[index][1]; }
        module.exports = listCacheGet;
    }), (function (module, exports, __webpack_require__) {
        var assocIndexOf = __webpack_require__(60); function listCacheHas(key) { return assocIndexOf(this.__data__, key) > -1; }
        module.exports = listCacheHas;
    }), (function (module, exports, __webpack_require__) {
        var assocIndexOf = __webpack_require__(60); function listCacheSet(key, value) {
            var data = this.__data__, index = assocIndexOf(data, key); if (index < 0) { ++this.size; data.push([key, value]); } else { data[index][1] = value; }
            return this;
        }
        module.exports = listCacheSet;
    }), (function (module, exports, __webpack_require__) {
        var ListCache = __webpack_require__(59); function stackClear() { this.__data__ = new ListCache; this.size = 0; }
        module.exports = stackClear;
    }), (function (module, exports) {
        function stackDelete(key) { var data = this.__data__, result = data['delete'](key); this.size = data.size; return result; }
        module.exports = stackDelete;
    }), (function (module, exports) {
        function stackGet(key) { return this.__data__.get(key); }
        module.exports = stackGet;
    }), (function (module, exports) {
        function stackHas(key) { return this.__data__.has(key); }
        module.exports = stackHas;
    }), (function (module, exports, __webpack_require__) {
        var ListCache = __webpack_require__(59), Map = __webpack_require__(82), MapCache = __webpack_require__(83); var LARGE_ARRAY_SIZE = 200; function stackSet(key, value) {
            var data = this.__data__; if (data instanceof ListCache) {
                var pairs = data.__data__; if (!Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) { pairs.push([key, value]); this.size = ++data.size; return this; }
                data = this.__data__ = new MapCache(pairs);
            }
            data.set(key, value); this.size = data.size; return this;
        }
        module.exports = stackSet;
    }), (function (module, exports, __webpack_require__) {
        var isFunction = __webpack_require__(61), isMasked = __webpack_require__(259), isObject = __webpack_require__(5), toSource = __webpack_require__(128); var reRegExpChar = /[\\^$.*+?()[\]{}|]/g; var reIsHostCtor = /^\[object .+?Constructor\]$/; var funcProto = Function.prototype, objectProto = Object.prototype; var funcToString = funcProto.toString; var hasOwnProperty = objectProto.hasOwnProperty; var reIsNative = RegExp('^' +
            funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&').replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'); function baseIsNative(value) {
                if (!isObject(value) || isMasked(value)) { return false; }
                var pattern = isFunction(value) ? reIsNative : reIsHostCtor; return pattern.test(toSource(value));
            }
        module.exports = baseIsNative;
    }), (function (module, exports, __webpack_require__) {
        var coreJsData = __webpack_require__(260); var maskSrcKey = (function () { var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || ''); return uid ? ('Symbol(src)_1.' + uid) : ''; }()); function isMasked(func) { return !!maskSrcKey && (maskSrcKey in func); }
        module.exports = isMasked;
    }), (function (module, exports, __webpack_require__) { var root = __webpack_require__(9); var coreJsData = root['__core-js_shared__']; module.exports = coreJsData; }), (function (module, exports) {
        function getValue(object, key) { return object == null ? undefined : object[key]; }
        module.exports = getValue;
    }), (function (module, exports, __webpack_require__) {
        var Hash = __webpack_require__(263), ListCache = __webpack_require__(59), Map = __webpack_require__(82); function mapCacheClear() { this.size = 0; this.__data__ = { 'hash': new Hash, 'map': new (Map || ListCache), 'string': new Hash }; }
        module.exports = mapCacheClear;
    }), (function (module, exports, __webpack_require__) {
        var hashClear = __webpack_require__(264), hashDelete = __webpack_require__(265), hashGet = __webpack_require__(266), hashHas = __webpack_require__(267), hashSet = __webpack_require__(268); function Hash(entries) { var index = -1, length = entries == null ? 0 : entries.length; this.clear(); while (++index < length) { var entry = entries[index]; this.set(entry[0], entry[1]); } }
        Hash.prototype.clear = hashClear; Hash.prototype['delete'] = hashDelete; Hash.prototype.get = hashGet; Hash.prototype.has = hashHas; Hash.prototype.set = hashSet; module.exports = Hash;
    }), (function (module, exports, __webpack_require__) {
        var nativeCreate = __webpack_require__(62); function hashClear() { this.__data__ = nativeCreate ? nativeCreate(null) : {}; this.size = 0; }
        module.exports = hashClear;
    }), (function (module, exports) {
        function hashDelete(key) { var result = this.has(key) && delete this.__data__[key]; this.size -= result ? 1 : 0; return result; }
        module.exports = hashDelete;
    }), (function (module, exports, __webpack_require__) {
        var nativeCreate = __webpack_require__(62); var HASH_UNDEFINED = '__lodash_hash_undefined__'; var objectProto = Object.prototype; var hasOwnProperty = objectProto.hasOwnProperty; function hashGet(key) {
            var data = this.__data__; if (nativeCreate) { var result = data[key]; return result === HASH_UNDEFINED ? undefined : result; }
            return hasOwnProperty.call(data, key) ? data[key] : undefined;
        }
        module.exports = hashGet;
    }), (function (module, exports, __webpack_require__) {
        var nativeCreate = __webpack_require__(62); var objectProto = Object.prototype; var hasOwnProperty = objectProto.hasOwnProperty; function hashHas(key) { var data = this.__data__; return nativeCreate ? (data[key] !== undefined) : hasOwnProperty.call(data, key); }
        module.exports = hashHas;
    }), (function (module, exports, __webpack_require__) {
        var nativeCreate = __webpack_require__(62); var HASH_UNDEFINED = '__lodash_hash_undefined__'; function hashSet(key, value) { var data = this.__data__; this.size += this.has(key) ? 0 : 1; data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value; return this; }
        module.exports = hashSet;
    }), (function (module, exports, __webpack_require__) {
        var getMapData = __webpack_require__(63); function mapCacheDelete(key) { var result = getMapData(this, key)['delete'](key); this.size -= result ? 1 : 0; return result; }
        module.exports = mapCacheDelete;
    }), (function (module, exports) {
        function isKeyable(value) { var type = typeof value; return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean') ? (value !== '__proto__') : (value === null); }
        module.exports = isKeyable;
    }), (function (module, exports, __webpack_require__) {
        var getMapData = __webpack_require__(63); function mapCacheGet(key) { return getMapData(this, key).get(key); }
        module.exports = mapCacheGet;
    }), (function (module, exports, __webpack_require__) {
        var getMapData = __webpack_require__(63); function mapCacheHas(key) { return getMapData(this, key).has(key); }
        module.exports = mapCacheHas;
    }), (function (module, exports, __webpack_require__) {
        var getMapData = __webpack_require__(63); function mapCacheSet(key, value) { var data = getMapData(this, key), size = data.size; data.set(key, value); this.size += data.size == size ? 0 : 1; return this; }
        module.exports = mapCacheSet;
    }), (function (module, exports, __webpack_require__) {
        var Stack = __webpack_require__(58), equalArrays = __webpack_require__(130), equalByTag = __webpack_require__(278), equalObjects = __webpack_require__(279), getTag = __webpack_require__(88), isArray = __webpack_require__(4), isBuffer = __webpack_require__(44), isTypedArray = __webpack_require__(68); var COMPARE_PARTIAL_FLAG = 1; var argsTag = '[object Arguments]', arrayTag = '[object Array]', objectTag = '[object Object]'; var objectProto = Object.prototype; var hasOwnProperty = objectProto.hasOwnProperty; function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
            var objIsArr = isArray(object), othIsArr = isArray(other), objTag = objIsArr ? arrayTag : getTag(object), othTag = othIsArr ? arrayTag : getTag(other); objTag = objTag == argsTag ? objectTag : objTag; othTag = othTag == argsTag ? objectTag : othTag; var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag; if (isSameTag && isBuffer(object)) {
                if (!isBuffer(other)) { return false; }
                objIsArr = true; objIsObj = false;
            }
            if (isSameTag && !objIsObj) { stack || (stack = new Stack); return (objIsArr || isTypedArray(object)) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack); }
            if (!(bitmask & COMPARE_PARTIAL_FLAG)) { var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'), othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__'); if (objIsWrapped || othIsWrapped) { var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other; stack || (stack = new Stack); return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack); } }
            if (!isSameTag) { return false; }
            stack || (stack = new Stack); return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
        }
        module.exports = baseIsEqualDeep;
    }), (function (module, exports) {
        var HASH_UNDEFINED = '__lodash_hash_undefined__'; function setCacheAdd(value) { this.__data__.set(value, HASH_UNDEFINED); return this; }
        module.exports = setCacheAdd;
    }), (function (module, exports) {
        function setCacheHas(value) { return this.__data__.has(value); }
        module.exports = setCacheHas;
    }), (function (module, exports) {
        function arraySome(array, predicate) {
            var index = -1, length = array == null ? 0 : array.length; while (++index < length) { if (predicate(array[index], index, array)) { return true; } }
            return false;
        }
        module.exports = arraySome;
    }), (function (module, exports, __webpack_require__) {
        var Symbol = __webpack_require__(34), Uint8Array = __webpack_require__(131), eq = __webpack_require__(35), equalArrays = __webpack_require__(130), mapToArray = __webpack_require__(132), setToArray = __webpack_require__(66); var COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2; var boolTag = '[object Boolean]', dateTag = '[object Date]', errorTag = '[object Error]', mapTag = '[object Map]', numberTag = '[object Number]', regexpTag = '[object RegExp]', setTag = '[object Set]', stringTag = '[object String]', symbolTag = '[object Symbol]'; var arrayBufferTag = '[object ArrayBuffer]', dataViewTag = '[object DataView]'; var symbolProto = Symbol ? Symbol.prototype : undefined, symbolValueOf = symbolProto ? symbolProto.valueOf : undefined; function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
            switch (tag) {
                case dataViewTag: if ((object.byteLength != other.byteLength) || (object.byteOffset != other.byteOffset)) { return false; }
                    object = object.buffer; other = other.buffer; case arrayBufferTag: if ((object.byteLength != other.byteLength) || !equalFunc(new Uint8Array(object), new Uint8Array(other))) { return false; }
                    return true; case boolTag: case dateTag: case numberTag: return eq(+object, +other); case errorTag: return object.name == other.name && object.message == other.message; case regexpTag: case stringTag: return object == (other + ''); case mapTag: var convert = mapToArray; case setTag: var isPartial = bitmask & COMPARE_PARTIAL_FLAG; convert || (convert = setToArray); if (object.size != other.size && !isPartial) { return false; }
                    var stacked = stack.get(object); if (stacked) { return stacked == other; }
                    bitmask |= COMPARE_UNORDERED_FLAG; stack.set(object, other); var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack); stack['delete'](object); return result; case symbolTag: if (symbolValueOf) { return symbolValueOf.call(object) == symbolValueOf.call(other); }
            }
            return false;
        }
        module.exports = equalByTag;
    }), (function (module, exports, __webpack_require__) {
        var getAllKeys = __webpack_require__(133); var COMPARE_PARTIAL_FLAG = 1; var objectProto = Object.prototype; var hasOwnProperty = objectProto.hasOwnProperty; function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
            var isPartial = bitmask & COMPARE_PARTIAL_FLAG, objProps = getAllKeys(object), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length; if (objLength != othLength && !isPartial) { return false; }
            var index = objLength; while (index--) { var key = objProps[index]; if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) { return false; } }
            var stacked = stack.get(object); if (stacked && stack.get(other)) { return stacked == other; }
            var result = true; stack.set(object, other); stack.set(other, object); var skipCtor = isPartial; while (++index < objLength) {
                key = objProps[index]; var objValue = object[key], othValue = other[key]; if (customizer) { var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack); }
                if (!(compared === undefined ? (objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack)) : compared)) { result = false; break; }
                skipCtor || (skipCtor = key == 'constructor');
            }
            if (result && !skipCtor) { var objCtor = object.constructor, othCtor = other.constructor; if (objCtor != othCtor && ('constructor' in object && 'constructor' in other) && !(typeof objCtor == 'function' && objCtor instanceof objCtor && typeof othCtor == 'function' && othCtor instanceof othCtor)) { result = false; } }
            stack['delete'](object); stack['delete'](other); return result;
        }
        module.exports = equalObjects;
    }), (function (module, exports) {
        function baseTimes(n, iteratee) {
            var index = -1, result = Array(n); while (++index < n) { result[index] = iteratee(index); }
            return result;
        }
        module.exports = baseTimes;
    }), (function (module, exports, __webpack_require__) {
        var baseGetTag = __webpack_require__(21), isObjectLike = __webpack_require__(13); var argsTag = '[object Arguments]'; function baseIsArguments(value) { return isObjectLike(value) && baseGetTag(value) == argsTag; }
        module.exports = baseIsArguments;
    }), (function (module, exports) {
        function stubFalse() { return false; }
        module.exports = stubFalse;
    }), (function (module, exports, __webpack_require__) {
        var baseGetTag = __webpack_require__(21), isLength = __webpack_require__(87), isObjectLike = __webpack_require__(13); var argsTag = '[object Arguments]', arrayTag = '[object Array]', boolTag = '[object Boolean]', dateTag = '[object Date]', errorTag = '[object Error]', funcTag = '[object Function]', mapTag = '[object Map]', numberTag = '[object Number]', objectTag = '[object Object]', regexpTag = '[object RegExp]', setTag = '[object Set]', stringTag = '[object String]', weakMapTag = '[object WeakMap]'; var arrayBufferTag = '[object ArrayBuffer]', dataViewTag = '[object DataView]', float32Tag = '[object Float32Array]', float64Tag = '[object Float64Array]', int8Tag = '[object Int8Array]', int16Tag = '[object Int16Array]', int32Tag = '[object Int32Array]', uint8Tag = '[object Uint8Array]', uint8ClampedTag = '[object Uint8ClampedArray]', uint16Tag = '[object Uint16Array]', uint32Tag = '[object Uint32Array]'; var typedArrayTags = {}; typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true; typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false; function baseIsTypedArray(value) { return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)]; }
        module.exports = baseIsTypedArray;
    }), (function (module, exports, __webpack_require__) { (function (module) { var freeGlobal = __webpack_require__(127); var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports; var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module; var moduleExports = freeModule && freeModule.exports === freeExports; var freeProcess = moduleExports && freeGlobal.process; var nodeUtil = (function () { try { return freeProcess && freeProcess.binding && freeProcess.binding('util'); } catch (e) { } }()); module.exports = nodeUtil; }.call(exports, __webpack_require__(45)(module))) }), (function (module, exports, __webpack_require__) { var overArg = __webpack_require__(138); var nativeKeys = overArg(Object.keys, Object); module.exports = nativeKeys; }), (function (module, exports, __webpack_require__) { var getNative = __webpack_require__(25), root = __webpack_require__(9); var DataView = getNative(root, 'DataView'); module.exports = DataView; }), (function (module, exports, __webpack_require__) { var getNative = __webpack_require__(25), root = __webpack_require__(9); var Promise = getNative(root, 'Promise'); module.exports = Promise; }), (function (module, exports, __webpack_require__) { var getNative = __webpack_require__(25), root = __webpack_require__(9); var WeakMap = getNative(root, 'WeakMap'); module.exports = WeakMap; }), (function (module, exports, __webpack_require__) {
        var isStrictComparable = __webpack_require__(140), keys = __webpack_require__(26); function getMatchData(object) {
            var result = keys(object), length = result.length; while (length--) { var key = result[length], value = object[key]; result[length] = [key, value, isStrictComparable(value)]; }
            return result;
        }
        module.exports = getMatchData;
    }), (function (module, exports, __webpack_require__) {
        var baseIsEqual = __webpack_require__(129), get = __webpack_require__(291), hasIn = __webpack_require__(142), isKey = __webpack_require__(90), isStrictComparable = __webpack_require__(140), matchesStrictComparable = __webpack_require__(141), toKey = __webpack_require__(47); var COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2; function baseMatchesProperty(path, srcValue) {
            if (isKey(path) && isStrictComparable(srcValue)) { return matchesStrictComparable(toKey(path), srcValue); }
            return function (object) { var objValue = get(object, path); return (objValue === undefined && objValue === srcValue) ? hasIn(object, path) : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG); };
        }
        module.exports = baseMatchesProperty;
    }), (function (module, exports, __webpack_require__) {
        var baseGet = __webpack_require__(89); function get(object, path, defaultValue) { var result = object == null ? undefined : baseGet(object, path); return result === undefined ? defaultValue : result; }
        module.exports = get;
    }), (function (module, exports, __webpack_require__) {
        var memoizeCapped = __webpack_require__(293); var reLeadingDot = /^\./, rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g; var reEscapeChar = /\\(\\)?/g; var stringToPath = memoizeCapped(function (string) {
            var result = []; if (reLeadingDot.test(string)) { result.push(''); }
            string.replace(rePropName, function (match, number, quote, string) { result.push(quote ? string.replace(reEscapeChar, '$1') : (number || match)); }); return result;
        }); module.exports = stringToPath;
    }), (function (module, exports, __webpack_require__) {
        var memoize = __webpack_require__(36); var MAX_MEMOIZE_SIZE = 500; function memoizeCapped(func) {
            var result = memoize(func, function (key) {
                if (cache.size === MAX_MEMOIZE_SIZE) { cache.clear(); }
                return key;
            }); var cache = result.cache; return result;
        }
        module.exports = memoizeCapped;
    }), (function (module, exports, __webpack_require__) {
        var Symbol = __webpack_require__(34), arrayMap = __webpack_require__(24), isArray = __webpack_require__(4), isSymbol = __webpack_require__(46); var INFINITY = 1 / 0; var symbolProto = Symbol ? Symbol.prototype : undefined, symbolToString = symbolProto ? symbolProto.toString : undefined; function baseToString(value) {
            if (typeof value == 'string') { return value; }
            if (isArray(value)) { return arrayMap(value, baseToString) + ''; }
            if (isSymbol(value)) { return symbolToString ? symbolToString.call(value) : ''; }
            var result = (value + ''); return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
        }
        module.exports = baseToString;
    }), (function (module, exports) {
        function baseHasIn(object, key) { return object != null && key in Object(object); }
        module.exports = baseHasIn;
    }), (function (module, exports, __webpack_require__) {
        var baseProperty = __webpack_require__(297), basePropertyDeep = __webpack_require__(298), isKey = __webpack_require__(90), toKey = __webpack_require__(47); function property(path) { return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path); }
        module.exports = property;
    }), (function (module, exports) {
        function baseProperty(key) { return function (object) { return object == null ? undefined : object[key]; }; }
        module.exports = baseProperty;
    }), (function (module, exports, __webpack_require__) {
        var baseGet = __webpack_require__(89); function basePropertyDeep(path) { return function (object) { return baseGet(object, path); }; }
        module.exports = basePropertyDeep;
    }), (function (module, exports, __webpack_require__) {
        var baseFor = __webpack_require__(145), keys = __webpack_require__(26); function baseForOwn(object, iteratee) { return object && baseFor(object, iteratee, keys); }
        module.exports = baseForOwn;
    }), (function (module, exports) {
        function createBaseFor(fromRight) {
            return function (object, iteratee, keysFunc) {
                var index = -1, iterable = Object(object), props = keysFunc(object), length = props.length; while (length--) { var key = props[fromRight ? length : ++index]; if (iteratee(iterable[key], key, iterable) === false) { break; } }
                return object;
            };
        }
        module.exports = createBaseFor;
    }), (function (module, exports, __webpack_require__) {
        var isArrayLike = __webpack_require__(19); function createBaseEach(eachFunc, fromRight) {
            return function (collection, iteratee) {
                if (collection == null) { return collection; }
                if (!isArrayLike(collection)) { return eachFunc(collection, iteratee); }
                var length = collection.length, index = fromRight ? length : -1, iterable = Object(collection); while ((fromRight ? index-- : ++index < length)) { if (iteratee(iterable[index], index, iterable) === false) { break; } }
                return collection;
            };
        }
        module.exports = createBaseEach;
    }), (function (module, exports, __webpack_require__) {
        var identity = __webpack_require__(37); function castFunction(value) { return typeof value == 'function' ? value : identity; }
        module.exports = castFunction;
    }), (function (module, exports, __webpack_require__) {
        var isNumber = __webpack_require__(79); function isNaN(value) { return isNumber(value) && value != +value; }
        module.exports = isNaN;
    }), (function (module, exports, __webpack_require__) {
        var Symbol = __webpack_require__(34), isArguments = __webpack_require__(43), isArray = __webpack_require__(4); var spreadableSymbol = Symbol ? Symbol.isConcatSpreadable : undefined; function isFlattenable(value) { return isArray(value) || isArguments(value) || !!(spreadableSymbol && value && value[spreadableSymbol]); }
        module.exports = isFlattenable;
    }), (function (module, exports, __webpack_require__) {
        var assignMergeValue = __webpack_require__(151), cloneBuffer = __webpack_require__(153), cloneTypedArray = __webpack_require__(154), copyArray = __webpack_require__(155), initCloneObject = __webpack_require__(156), isArguments = __webpack_require__(43), isArray = __webpack_require__(4), isArrayLikeObject = __webpack_require__(97), isBuffer = __webpack_require__(44), isFunction = __webpack_require__(61), isObject = __webpack_require__(5), isPlainObject = __webpack_require__(157), isTypedArray = __webpack_require__(68), toPlainObject = __webpack_require__(307); function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
            var objValue = object[key], srcValue = source[key], stacked = stack.get(srcValue); if (stacked) { assignMergeValue(object, key, stacked); return; }
            var newValue = customizer ? customizer(objValue, srcValue, (key + ''), object, source, stack) : undefined; var isCommon = newValue === undefined; if (isCommon) {
                var isArr = isArray(srcValue), isBuff = !isArr && isBuffer(srcValue), isTyped = !isArr && !isBuff && isTypedArray(srcValue); newValue = srcValue; if (isArr || isBuff || isTyped) {
                    if (isArray(objValue)) { newValue = objValue; }
                    else if (isArrayLikeObject(objValue)) { newValue = copyArray(objValue); }
                    else if (isBuff) { isCommon = false; newValue = cloneBuffer(srcValue, true); }
                    else if (isTyped) { isCommon = false; newValue = cloneTypedArray(srcValue, true); }
                    else { newValue = []; }
                }
                else if (isPlainObject(srcValue) || isArguments(srcValue)) {
                    newValue = objValue; if (isArguments(objValue)) { newValue = toPlainObject(objValue); }
                    else if (!isObject(objValue) || (srcIndex && isFunction(objValue))) { newValue = initCloneObject(srcValue); }
                }
                else { isCommon = false; }
            }
            if (isCommon) { stack.set(srcValue, newValue); mergeFunc(newValue, srcValue, srcIndex, customizer, stack); stack['delete'](srcValue); }
            assignMergeValue(object, key, newValue);
        }
        module.exports = baseMergeDeep;
    }), (function (module, exports, __webpack_require__) {
        var isObject = __webpack_require__(5); var objectCreate = Object.create; var baseCreate = (function () {
            function object() { }
            return function (proto) {
                if (!isObject(proto)) { return {}; }
                if (objectCreate) { return objectCreate(proto); }
                object.prototype = proto; var result = new object; object.prototype = undefined; return result;
            };
        }()); module.exports = baseCreate;
    }), (function (module, exports, __webpack_require__) {
        var copyObject = __webpack_require__(38), keysIn = __webpack_require__(49); function toPlainObject(value) { return copyObject(value, keysIn(value)); }
        module.exports = toPlainObject;
    }), (function (module, exports, __webpack_require__) {
        var isObject = __webpack_require__(5), isPrototype = __webpack_require__(70), nativeKeysIn = __webpack_require__(309); var objectProto = Object.prototype; var hasOwnProperty = objectProto.hasOwnProperty; function baseKeysIn(object) {
            if (!isObject(object)) { return nativeKeysIn(object); }
            var isProto = isPrototype(object), result = []; for (var key in object) { if (!(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) { result.push(key); } }
            return result;
        }
        module.exports = baseKeysIn;
    }), (function (module, exports) {
        function nativeKeysIn(object) {
            var result = []; if (object != null) { for (var key in Object(object)) { result.push(key); } }
            return result;
        }
        module.exports = nativeKeysIn;
    }), (function (module, exports, __webpack_require__) { var constant = __webpack_require__(311), defineProperty = __webpack_require__(152), identity = __webpack_require__(37); var baseSetToString = !defineProperty ? identity : function (func, string) { return defineProperty(func, 'toString', { 'configurable': true, 'enumerable': false, 'value': constant(string), 'writable': true }); }; module.exports = baseSetToString; }), (function (module, exports) {
        function constant(value) { return function () { return value; }; }
        module.exports = constant;
    }), (function (module, exports) {
        var HOT_COUNT = 800, HOT_SPAN = 16; var nativeNow = Date.now; function shortOut(func) {
            var count = 0, lastCalled = 0; return function () {
                var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled); lastCalled = stamp; if (remaining > 0) { if (++count >= HOT_COUNT) { return arguments[0]; } } else { count = 0; }
                return func.apply(undefined, arguments);
            };
        }
        module.exports = shortOut;
    }), (function (module, exports, __webpack_require__) { "use strict"; var wordCount = __webpack_require__(23); module.exports = function (paper) { return wordCount(paper.getText()); }; }), (function (module, exports, __webpack_require__) { "use strict"; var punctuationRegexString = "[\\\u2013\\-\\(\\)_\\[\\]\u2019\u201C\u201D\"'.?!:;,\xBF\xA1\xAB\xBB\u2014\xD7+&]+"; var punctuationRegexStart = new RegExp("^" + punctuationRegexString); var punctuationRegexEnd = new RegExp(punctuationRegexString + "$"); module.exports = function (text) { text = text.replace(punctuationRegexStart, ""); text = text.replace(punctuationRegexEnd, ""); return text; }; }), (function (module, exports, __webpack_require__) {
        "use strict"; var getAnchors = __webpack_require__(162); var findKeywordInUrl = __webpack_require__(316); var getLinkType = __webpack_require__(318); var checkNofollow = __webpack_require__(325); var urlHelper = __webpack_require__(102); var escapeRegExp = __webpack_require__(12); var keywordInAnchor = function keywordInAnchor(keyword, anchor, locale) {
            if (keyword === "") { return false; }
            return findKeywordInUrl(anchor, keyword, locale);
        }; var countLinkTypes = function countLinkTypes(paper) {
            var keyword = escapeRegExp(paper.getKeyword()); var locale = paper.getLocale(); var anchors = getAnchors(paper.getText()); var permalink = paper.getPermalink(); var linkCount = { total: anchors.length, totalNaKeyword: 0, keyword: { totalKeyword: 0, matchedAnchors: [] }, internalTotal: 0, internalDofollow: 0, internalNofollow: 0, externalTotal: 0, externalDofollow: 0, externalNofollow: 0, otherTotal: 0, otherDofollow: 0, otherNofollow: 0 }; for (var i = 0; i < anchors.length; i++) {
                var currentAnchor = anchors[i]; var anchorLink = urlHelper.getFromAnchorTag(currentAnchor); var linkToSelf = urlHelper.areEqual(anchorLink, permalink); if (keywordInAnchor(keyword, currentAnchor, locale) && !linkToSelf) { linkCount.keyword.totalKeyword++; linkCount.keyword.matchedAnchors.push(currentAnchor); }
                var linkType = getLinkType(currentAnchor, permalink); var linkFollow = checkNofollow(currentAnchor); linkCount[linkType + "Total"]++; linkCount[linkType + linkFollow]++;
            }
            return linkCount;
        }; module.exports = function (paper) { return countLinkTypes(paper); };
    }), (function (module, exports, __webpack_require__) {
        "use strict"; var matchTextWithTransliteration = __webpack_require__(101); var escapeRegExp = __webpack_require__(12); module.exports = function (url, keyword, locale) {
            var formatUrl = url.match(/>(.*)/ig); keyword = escapeRegExp(keyword); if (formatUrl !== null) { formatUrl = formatUrl[0].replace(/<.*?>\s?/ig, ""); return matchTextWithTransliteration(formatUrl, keyword, locale).length > 0; }
            return false;
        };
    }), (function (module, exports, __webpack_require__) {
        "use strict"; var getLanguage = __webpack_require__(20); var isUndefined = __webpack_require__(3); var transliterations = { es: [{ letter: /[\u00F1]/g, alternative: "n" }, { letter: /[\u00D1]/g, alternative: "N" }, { letter: /[\u00E1]/g, alternative: "a" }, { letter: /[\u00C1]/g, alternative: "A" }, { letter: /[\u00E9]/g, alternative: "e" }, { letter: /[\u00C9]/g, alternative: "E" }, { letter: /[\u00ED]/g, alternative: "i" }, { letter: /[\u00CD]/g, alternative: "I" }, { letter: /[\u00F3]/g, alternative: "o" }, { letter: /[\u00D3]/g, alternative: "O" }, { letter: /[\u00FA\u00FC]/g, alternative: "u" }, { letter: /[\u00DA\u00DC]/g, alternative: "U" }], pl: [{ letter: /[\u0105]/g, alternative: "a" }, { letter: /[\u0104]/g, alternative: "A" }, { letter: /[\u0107]/g, alternative: "c" }, { letter: /[\u0106]/g, alternative: "C" }, { letter: /[\u0119]/g, alternative: "e" }, { letter: /[\u0118]/g, alternative: "E" }, { letter: /[\u0142]/g, alternative: "l" }, { letter: /[\u0141]/g, alternative: "L" }, { letter: /[\u0144]/g, alternative: "n" }, { letter: /[\u0143]/g, alternative: "N" }, { letter: /[\u00F3]/g, alternative: "o" }, { letter: /[\u00D3]/g, alternative: "O" }, { letter: /[\u015B]/g, alternative: "s" }, { letter: /[\u015A]/g, alternative: "S" }, { letter: /[\u017A\u017C]/g, alternative: "z" }, { letter: /[\u0179\u017B]/g, alternative: "Z" }], de: [{ letter: /[\u00E4]/g, alternative: "ae" }, { letter: /[\u00C4]/g, alternative: "Ae" }, { letter: /[\u00FC]/g, alternative: "ue" }, { letter: /[\u00DC]/g, alternative: "Ue" }, { letter: /[\u00F6]/g, alternative: "oe" }, { letter: /[\u00D6]/g, alternative: "Oe" }, { letter: /[\u00DF]/g, alternative: "ss" }, { letter: /[\u1E9E]/g, alternative: "SS" }], nbnn: [{ letter: /[\u00E6\u04D5]/g, alternative: "ae" }, { letter: /[\u00C6\u04D4]/g, alternative: "Ae" }, { letter: /[\u00E5]/g, alternative: "aa" }, { letter: /[\u00C5]/g, alternative: "Aa" }, { letter: /[\u00F8]/g, alternative: "oe" }, { letter: /[\u00D8]/g, alternative: "Oe" }, { letter: /[\u00E9\u00E8\u00EA]/g, alternative: "e" }, { letter: /[\u00C9\u00C8\u00CA]/g, alternative: "E" }, { letter: /[\u00F3\u00F2\u00F4]/g, alternative: "o" }, { letter: /[\u00D3\u00D2\u00D4]/g, alternative: "O" }], sv: [{ letter: /[\u00E5]/g, alternative: "aa" }, { letter: /[\u00C5]/g, alternative: "Aa" }, { letter: /[\u00E4]/g, alternative: "ae" }, { letter: /[\u00C4]/g, alternative: "Ae" }, { letter: /[\u00F6]/g, alternative: "oe" }, { letter: /[\u00D6]/g, alternative: "Oe" }, { letter: /[\u00E9]/g, alternative: "e" }, { letter: /[\u00C9]/g, alternative: "E" }, { letter: /[\u00E0]/g, alternative: "a" }, { letter: /[\u00C0]/g, alternative: "A" }], fi: [{ letter: /[\u00E5]/g, alternative: "aa" }, { letter: /[\u00C5]/g, alternative: "Aa" }, { letter: /[\u00E4]/g, alternative: "a" }, { letter: /[\u00C4]/g, alternative: "A" }, { letter: /[\u00F6]/g, alternative: "o" }, { letter: /[\u00D6]/g, alternative: "O" }, { letter: /[\u017E]/g, alternative: "zh" }, { letter: /[\u017D]/g, alternative: "Zh" }, { letter: /[\u0161]/g, alternative: "sh" }, { letter: /[\u0160]/g, alternative: "Sh" }], da: [{ letter: /[\u00E5]/g, alternative: "aa" }, { letter: /[\u00C5]/g, alternative: "Aa" }, { letter: /[\u00E6\u04D5]/g, alternative: "ae" }, { letter: /[\u00C6\u04D4]/g, alternative: "Ae" }, { letter: /[\u00C4]/g, alternative: "Ae" }, { letter: /[\u00F8]/g, alternative: "oe" }, { letter: /[\u00D8]/g, alternative: "Oe" }, { letter: /[\u00E9]/g, alternative: "e" }, { letter: /[\u00C9]/g, alternative: "E" }], tr: [{ letter: /[\u00E7]/g, alternative: "c" }, { letter: /[\u00C7]/g, alternative: "C" }, { letter: /[\u011F]/g, alternative: "g" }, { letter: /[\u011E]/g, alternative: "G" }, { letter: /[\u00F6]/g, alternative: "o" }, { letter: /[\u00D6]/g, alternative: "O" }, { letter: /[\u015F]/g, alternative: "s" }, { letter: /[\u015E]/g, alternative: "S" }, { letter: /[\u00E2]/g, alternative: "a" }, { letter: /[\u00C2]/g, alternative: "A" }, { letter: /[\u0131\u00EE]/g, alternative: "i" }, { letter: /[\u0130\u00CE]/g, alternative: "I" }, { letter: /[\u00FC\u00FB]/g, alternative: "u" }, { letter: /[\u00DC\u00DB]/g, alternative: "U" }], lv: [{ letter: /[\u0101]/g, alternative: "a" }, { letter: /[\u0100]/g, alternative: "A" }, { letter: /[\u010D]/g, alternative: "c" }, { letter: /[\u010C]/g, alternative: "C" }, { letter: /[\u0113]/g, alternative: "e" }, { letter: /[\u0112]/g, alternative: "E" }, { letter: /[\u0123]/g, alternative: "g" }, { letter: /[\u0122]/g, alternative: "G" }, { letter: /[\u012B]/g, alternative: "i" }, { letter: /[\u012A]/g, alternative: "I" }, { letter: /[\u0137]/g, alternative: "k" }, { letter: /[\u0136]/g, alternative: "K" }, { letter: /[\u013C]/g, alternative: "l" }, { letter: /[\u013B]/g, alternative: "L" }, { letter: /[\u0146]/g, alternative: "n" }, { letter: /[\u0145]/g, alternative: "N" }, { letter: /[\u0161]/g, alternative: "s" }, { letter: /[\u0160]/g, alternative: "S" }, { letter: /[\u016B]/g, alternative: "u" }, { letter: /[\u016A]/g, alternative: "U" }, { letter: /[\u017E]/g, alternative: "z" }, { letter: /[\u017D]/g, alternative: "Z" }], is: [{ letter: /[\u00E1]/g, alternative: "a" }, { letter: /[\u00C1]/g, alternative: "A" }, { letter: /[\u00F0]/g, alternative: "d" }, { letter: /[\u00D0]/g, alternative: "D" }, { letter: /[\u00E9]/g, alternative: "e" }, { letter: /[\u00C9]/g, alternative: "E" }, { letter: /[\u00ED]/g, alternative: "i" }, { letter: /[\u00CD]/g, alternative: "I" }, { letter: /[\u00F3\u00F6]/g, alternative: "o" }, { letter: /[\u00D3\u00D6]/g, alternative: "O" }, { letter: /[\u00FA]/g, alternative: "u" }, { letter: /[\u00DA]/g, alternative: "U" }, { letter: /[\u00FD]/g, alternative: "y" }, { letter: /[\u00DD]/g, alternative: "Y" }, { letter: /[\u00FE]/g, alternative: "th" }, { letter: /[\u00DE]/g, alternative: "Th" }, { letter: /[\u00E6\u04D5]/g, alternative: "ae" }, { letter: /[\u00C6\u04D4]/g, alternative: "Ae" }], fa: [{ letter: /[\u00E1]/g, alternative: "a" }, { letter: /[\u00C1]/g, alternative: "A" }, { letter: /[\u00F0]/g, alternative: "d" }, { letter: /[\u00D0]/g, alternative: "D" }, { letter: /[\u00ED]/g, alternative: "i" }, { letter: /[\u00CD]/g, alternative: "I" }, { letter: /[\u00FD]/g, alternative: "y" }, { letter: /[\u00DD]/g, alternative: "Y" }, { letter: /[\u00FA]/g, alternative: "u" }, { letter: /[\u00DA]/g, alternative: "U" }, { letter: /[\u00F3\u00F8]/g, alternative: "o" }, { letter: /[\u00D3\u00D8]/g, alternative: "O" }, { letter: /[\u00E6\u04D5]/g, alternative: "ae" }, { letter: /[\u00C6\u04D4]/g, alternative: "Ae" }], cs: [{ letter: /[\u00E1]/g, alternative: "a" }, { letter: /[\u00C1]/g, alternative: "A" }, { letter: /[\u010D]/g, alternative: "c" }, { letter: /[\u010C]/g, alternative: "C" }, { letter: /[\u010F]/g, alternative: "d" }, { letter: /[\u010E]/g, alternative: "D" }, { letter: /[\u00ED]/g, alternative: "i" }, { letter: /[\u00CD]/g, alternative: "I" }, { letter: /[\u0148]/g, alternative: "n" }, { letter: /[\u0147]/g, alternative: "N" }, { letter: /[\u00F3]/g, alternative: "o" }, { letter: /[\u00D3]/g, alternative: "O" }, { letter: /[\u0159]/g, alternative: "r" }, { letter: /[\u0158]/g, alternative: "R" }, { letter: /[\u0161]/g, alternative: "s" }, { letter: /[\u0160]/g, alternative: "S" }, { letter: /[\u0165]/g, alternative: "t" }, { letter: /[\u0164]/g, alternative: "T" }, { letter: /[\u00FD]/g, alternative: "y" }, { letter: /[\u00DD]/g, alternative: "Y" }, { letter: /[\u017E]/g, alternative: "z" }, { letter: /[\u017D]/g, alternative: "Z" }, { letter: /[\u00E9\u011B]/g, alternative: "e" }, { letter: /[\u00C9\u011A]/g, alternative: "E" }, { letter: /[\u00FA\u016F]/g, alternative: "u" }, { letter: /[\u00DA\u016E]/g, alternative: "U" }], ru: [{ letter: /[\u0430]/g, alternative: "a" }, { letter: /[\u0410]/g, alternative: "A" }, { letter: /[\u0431]/g, alternative: "b" }, { letter: /[\u0411]/g, alternative: "B" }, { letter: /[\u0432]/g, alternative: "v" }, { letter: /[\u0412]/g, alternative: "V" }, { letter: /[\u0433]/g, alternative: "g" }, { letter: /[\u0413]/g, alternative: "G" }, { letter: /[\u0434]/g, alternative: "d" }, { letter: /[\u0414]/g, alternative: "D" }, { letter: /[\u0435]/g, alternative: "e" }, { letter: /[\u0415]/g, alternative: "E" }, { letter: /[\u0436]/g, alternative: "zh" }, { letter: /[\u0416]/g, alternative: "Zh" }, { letter: /[\u0437]/g, alternative: "z" }, { letter: /[\u0417]/g, alternative: "Z" }, { letter: /[\u0456\u0438\u0439]/g, alternative: "i" }, { letter: /[\u0406\u0418\u0419]/g, alternative: "I" }, { letter: /[\u043A]/g, alternative: "k" }, { letter: /[\u041A]/g, alternative: "K" }, { letter: /[\u043B]/g, alternative: "l" }, { letter: /[\u041B]/g, alternative: "L" }, { letter: /[\u043C]/g, alternative: "m" }, { letter: /[\u041C]/g, alternative: "M" }, { letter: /[\u043D]/g, alternative: "n" }, { letter: /[\u041D]/g, alternative: "N" }, { letter: /[\u0440]/g, alternative: "r" }, { letter: /[\u0420]/g, alternative: "R" }, { letter: /[\u043E]/g, alternative: "o" }, { letter: /[\u041E]/g, alternative: "O" }, { letter: /[\u043F]/g, alternative: "p" }, { letter: /[\u041F]/g, alternative: "P" }, { letter: /[\u0441]/g, alternative: "s" }, { letter: /[\u0421]/g, alternative: "S" }, { letter: /[\u0442]/g, alternative: "t" }, { letter: /[\u0422]/g, alternative: "T" }, { letter: /[\u0443]/g, alternative: "u" }, { letter: /[\u0423]/g, alternative: "U" }, { letter: /[\u0444]/g, alternative: "f" }, { letter: /[\u0424]/g, alternative: "F" }, { letter: /[\u0445]/g, alternative: "kh" }, { letter: /[\u0425]/g, alternative: "Kh" }, { letter: /[\u0446]/g, alternative: "ts" }, { letter: /[\u0426]/g, alternative: "Ts" }, { letter: /[\u0447]/g, alternative: "ch" }, { letter: /[\u0427]/g, alternative: "Ch" }, { letter: /[\u0448]/g, alternative: "sh" }, { letter: /[\u0428]/g, alternative: "Sh" }, { letter: /[\u0449]/g, alternative: "shch" }, { letter: /[\u0429]/g, alternative: "Shch" }, { letter: /[\u044A]/g, alternative: "ie" }, { letter: /[\u042A]/g, alternative: "Ie" }, { letter: /[\u044B]/g, alternative: "y" }, { letter: /[\u042B]/g, alternative: "Y" }, { letter: /[\u044C]/g, alternative: "" }, { letter: /[\u042C]/g, alternative: "" }, { letter: /[\u0451\u044D]/g, alternative: "e" }, { letter: /[\u0401\u042D]/g, alternative: "E" }, { letter: /[\u044E]/g, alternative: "iu" }, { letter: /[\u042E]/g, alternative: "Iu" }, { letter: /[\u044F]/g, alternative: "ia" }, { letter: /[\u042F]/g, alternative: "Ia" }], eo: [{ letter: /[\u0109]/g, alternative: "ch" }, { letter: /[\u0108]/g, alternative: "Ch" }, { letter: /[\u011d]/g, alternative: "gh" }, { letter: /[\u011c]/g, alternative: "Gh" }, { letter: /[\u0125]/g, alternative: "hx" }, { letter: /[\u0124]/g, alternative: "Hx" }, { letter: /[\u0135]/g, alternative: "jx" }, { letter: /[\u0134]/g, alternative: "Jx" }, { letter: /[\u015d]/g, alternative: "sx" }, { letter: /[\u015c]/g, alternative: "Sx" }, { letter: /[\u016d]/g, alternative: "ux" }, { letter: /[\u016c]/g, alternative: "Ux" }], af: [{ letter: /[\u00E8\u00EA\u00EB]/g, alternative: "e" }, { letter: /[\u00CB\u00C8\u00CA]/g, alternative: "E" }, { letter: /[\u00EE\u00EF]/g, alternative: "i" }, { letter: /[\u00CE\u00CF]/g, alternative: "I" }, { letter: /[\u00F4\u00F6]/g, alternative: "o" }, { letter: /[\u00D4\u00D6]/g, alternative: "O" }, { letter: /[\u00FB\u00FC]/g, alternative: "u" }, { letter: /[\u00DB\u00DC]/g, alternative: "U" }], ca: [{ letter: /[\u00E0]/g, alternative: "a" }, { letter: /[\u00C0]/g, alternative: "A" }, { letter: /[\u00E9|\u00E8]/g, alternative: "e" }, { letter: /[\u00C9|\u00C8]/g, alternative: "E" }, { letter: /[\u00ED|\u00EF]/g, alternative: "i" }, { letter: /[\u00CD|\u00CF]/g, alternative: "I" }, { letter: /[\u00F3|\u00F2]/g, alternative: "o" }, { letter: /[\u00D3|\u00D2]/g, alternative: "O" }, { letter: /[\u00FA|\u00FC]/g, alternative: "u" }, { letter: /[\u00DA|\u00DC]/g, alternative: "U" }, { letter: /[\u00E7]/g, alternative: "c" }, { letter: /[\u00C7]/g, alternative: "C" }], ast: [{ letter: /[\u00F1]/g, alternative: "n" }, { letter: /[\u00D1]/g, alternative: "N" }], an: [{ letter: /[\u00FC]/g, alternative: "u" }, { letter: /[\u00F1]/g, alternative: "ny" }, { letter: /[\u00E7]/g, alternative: "c" }, { letter: /[\u00ED]/g, alternative: "i" }, { letter: /[\u00F3]/g, alternative: "o" }, { letter: /[\u00E1]/g, alternative: "a" }, { letter: /[\u00DC]/g, alternative: "U" }, { letter: /[\u00D1]/g, alternative: "Ny" }, { letter: /[\u00C7]/g, alternative: "C" }, { letter: /[\u00CD]/g, alternative: "I" }, { letter: /[\u00D3]/g, alternative: "O" }, { letter: /[\u00C1]/g, alternative: "A" }], ay: [{ letter: /(([\u00EF])|([\u00ED]))/g, alternative: "i" }, { letter: /(([\u00CF])|([\u00CD]))/g, alternative: "I" }, { letter: /[\u00E4]/g, alternative: "a" }, { letter: /[\u00C4]/g, alternative: "A" }, { letter: /[\u00FC]/g, alternative: "u" }, { letter: /[\u00DC]/g, alternative: "U" }, { letter: /[\u0027]/g, alternative: "" }, { letter: /[\u00F1]/g, alternative: "n" }, { letter: /[\u00D1]/g, alternative: "N" }], en: [{ letter: /[\u00E6\u04D5]/g, alternative: "ae" }, { letter: /[\u00C6\u04D4]/g, alternative: "Ae" }, { letter: /[\u0153]/g, alternative: "oe" }, { letter: /[\u0152]/g, alternative: "Oe" }, { letter: /[\u00EB\u00E9]/g, alternative: "e" }, { letter: /[\u00C9\u00CB]/g, alternative: "E" }, { letter: /[\u00F4\u00F6]/g, alternative: "o" }, { letter: /[\u00D4\u00D6]/g, alternative: "O" }, { letter: /[\u00EF]/g, alternative: "i" }, { letter: /[\u00CF]/g, alternative: "I" }, { letter: /[\u00E7]/g, alternative: "c" }, { letter: /[\u00C7]/g, alternative: "C" }, { letter: /[\u00F1]/g, alternative: "n" }, { letter: /[\u00D1]/g, alternative: "N" }, { letter: /[\u00FC]/g, alternative: "u" }, { letter: /[\u00DC]/g, alternative: "U" }, { letter: /[\u00E4]/g, alternative: "a" }, { letter: /[\u00C4]/g, alternative: "A" }], fr: [{ letter: /[\u00E6\u04D5]/g, alternative: "ae" }, { letter: /[\u00C6\u04D4]/g, alternative: "Ae" }, { letter: /[\u0153]/g, alternative: "oe" }, { letter: /[\u0152]/g, alternative: "Oe" }, { letter: /[\u00E9\u00E8\u00EB\u00EA]/g, alternative: "e" }, { letter: /[\u00C9\u00C8\u00CB\u00CA]/g, alternative: "E" }, { letter: /[\u00E0\u00E2]/g, alternative: "a" }, { letter: /[\u00C0\u00C2]/g, alternative: "A" }, { letter: /[\u00EF\u00EE]/g, alternative: "i" }, { letter: /[\u00CF\u00CE]/g, alternative: "I" }, { letter: /[\u00F9\u00FB\u00FC]/g, alternative: "u" }, { letter: /[\u00D9\u00DB\u00DC]/g, alternative: "U" }, { letter: /[\u00F4]/g, alternative: "o" }, { letter: /[\u00D4]/g, alternative: "O" }, { letter: /[\u00FF]/g, alternative: "y" }, { letter: /[\u0178]/g, alternative: "Y" }, { letter: /[\u00E7]/g, alternative: "c" }, { letter: /[\u00C7]/g, alternative: "C" }, { letter: /[\u00F1]/g, alternative: "n" }, { letter: /[\u00D1]/g, alternative: "N" }], it: [{ letter: /[\u00E0]/g, alternative: "a" }, { letter: /[\u00C0]/g, alternative: "A" }, { letter: /[\u00E9\u00E8]/g, alternative: "e" }, { letter: /[\u00C9\u00C8]/g, alternative: "E" }, { letter: /[\u00EC\u00ED\u00EE]/g, alternative: "i" }, { letter: /[\u00CC\u00CD\u00CE]/g, alternative: "I" }, { letter: /[\u00F3\u00F2]/g, alternative: "o" }, { letter: /[\u00D3\u00D2]/g, alternative: "O" }, { letter: /[\u00F9\u00FA]/g, alternative: "u" }, { letter: /[\u00D9\u00DA]/g, alternative: "U" }], nl: [{ letter: /[\u00E7]/g, alternative: "c" }, { letter: /[\u00C7]/g, alternative: "C" }, { letter: /[\u00F1]/g, alternative: "n" }, { letter: /[\u00D1]/g, alternative: "N" }, { letter: /[\u00E9\u00E8\u00EA\u00EB]/g, alternative: "e" }, { letter: /[\u00C9\u00C8\u00CA\u00CB]/g, alternative: "E" }, { letter: /[\u00F4\u00F6]/g, alternative: "o" }, { letter: /[\u00D4\u00D6]/g, alternative: "O" }, { letter: /[\u00EF]/g, alternative: "i" }, { letter: /[\u00CF]/g, alternative: "I" }, { letter: /[\u00FC]/g, alternative: "u" }, { letter: /[\u00DC]/g, alternative: "U" }, { letter: /[\u00E4]/g, alternative: "a" }, { letter: /[\u00C4]/g, alternative: "A" }], bm: [{ letter: /[\u025B]/g, alternative: "e" }, { letter: /[\u0190]/g, alternative: "E" }, { letter: /[\u0272]/g, alternative: "ny" }, { letter: /[\u019D]/g, alternative: "Ny" }, { letter: /[\u014B]/g, alternative: "ng" }, { letter: /[\u014A]/g, alternative: "Ng" }, { letter: /[\u0254]/g, alternative: "o" }, { letter: /[\u0186]/g, alternative: "O" }], uk: [{ letter: /[\u0431]/g, alternative: "b" }, { letter: /[\u0411]/g, alternative: "B" }, { letter: /[\u0432]/g, alternative: "v" }, { letter: /[\u0412]/g, alternative: "V" }, { letter: /[\u0433]/g, alternative: "h" }, { letter: /[\u0413]/g, alternative: "H" }, { letter: /[\u0491]/g, alternative: "g" }, { letter: /[\u0490]/g, alternative: "G" }, { letter: /[\u0434]/g, alternative: "d" }, { letter: /[\u0414]/g, alternative: "D" }, { letter: /[\u043A]/g, alternative: "k" }, { letter: /[\u041A]/g, alternative: "K" }, { letter: /[\u043B]/g, alternative: "l" }, { letter: /[\u041B]/g, alternative: "L" }, { letter: /[\u043C]/g, alternative: "m" }, { letter: /[\u041C]/g, alternative: "M" }, { letter: /[\u0070]/g, alternative: "r" }, { letter: /[\u0050]/g, alternative: "R" }, { letter: /[\u043F]/g, alternative: "p" }, { letter: /[\u041F]/g, alternative: "P" }, { letter: /[\u0441]/g, alternative: "s" }, { letter: /[\u0421]/g, alternative: "S" }, { letter: /[\u0442]/g, alternative: "t" }, { letter: /[\u0422]/g, alternative: "T" }, { letter: /[\u0443]/g, alternative: "u" }, { letter: /[\u0423]/g, alternative: "U" }, { letter: /[\u0444]/g, alternative: "f" }, { letter: /[\u0424]/g, alternative: "F" }, { letter: /[\u0445]/g, alternative: "kh" }, { letter: /[\u0425]/g, alternative: "Kh" }, { letter: /[\u0446]/g, alternative: "ts" }, { letter: /[\u0426]/g, alternative: "Ts" }, { letter: /[\u0447]/g, alternative: "ch" }, { letter: /[\u0427]/g, alternative: "Ch" }, { letter: /[\u0448]/g, alternative: "sh" }, { letter: /[\u0428]/g, alternative: "Sh" }, { letter: /[\u0449]/g, alternative: "shch" }, { letter: /[\u0429]/g, alternative: "Shch" }, { letter: /[\u044C\u042C]/g, alternative: "" }, { letter: /[\u0436]/g, alternative: "zh" }, { letter: /[\u0416]/g, alternative: "Zh" }, { letter: /[\u0437]/g, alternative: "z" }, { letter: /[\u0417]/g, alternative: "Z" }, { letter: /[\u0438]/g, alternative: "y" }, { letter: /[\u0418]/g, alternative: "Y" }, { letter: /^[\u0454]/g, alternative: "ye" }, { letter: /[\s][\u0454]/g, alternative: " ye" }, { letter: /[\u0454]/g, alternative: "ie" }, { letter: /^[\u0404]/g, alternative: "Ye" }, { letter: /[\s][\u0404]/g, alternative: " Ye" }, { letter: /[\u0404]/g, alternative: "IE" }, { letter: /^[\u0457]/g, alternative: "yi" }, { letter: /[\s][\u0457]/g, alternative: " yi" }, { letter: /[\u0457]/g, alternative: "i" }, { letter: /^[\u0407]/g, alternative: "Yi" }, { letter: /[\s][\u0407]/g, alternative: " Yi" }, { letter: /[\u0407]/g, alternative: "I" }, { letter: /^[\u0439]/g, alternative: "y" }, { letter: /[\s][\u0439]/g, alternative: " y" }, { letter: /[\u0439]/g, alternative: "i" }, { letter: /^[\u0419]/g, alternative: "Y" }, { letter: /[\s][\u0419]/g, alternative: " Y" }, { letter: /[\u0419]/g, alternative: "I" }, { letter: /^[\u044E]/g, alternative: "yu" }, { letter: /[\s][\u044E]/g, alternative: " yu" }, { letter: /[\u044E]/g, alternative: "iu" }, { letter: /^[\u042E]/g, alternative: "Yu" }, { letter: /[\s][\u042E]/g, alternative: " Yu" }, { letter: /[\u042E]/g, alternative: "IU" }, { letter: /^[\u044F]/g, alternative: "ya" }, { letter: /[\s][\u044F]/g, alternative: " ya" }, { letter: /[\u044F]/g, alternative: "ia" }, { letter: /^[\u042F]/g, alternative: "Ya" }, { letter: /[\s][\u042F]/g, alternative: " Ya" }, { letter: /[\u042F]/g, alternative: "IA" }], br: [{ letter: /\u0063\u0027\u0068/g, alternative: "ch" }, { letter: /\u0043\u0027\u0048/g, alternative: "CH" }, { letter: /[\u00e2]/g, alternative: "a" }, { letter: /[\u00c2]/g, alternative: "A" }, { letter: /[\u00ea]/g, alternative: "e" }, { letter: /[\u00ca]/g, alternative: "E" }, { letter: /[\u00ee]/g, alternative: "i" }, { letter: /[\u00ce]/g, alternative: "I" }, { letter: /[\u00f4]/g, alternative: "o" }, { letter: /[\u00d4]/g, alternative: "O" }, { letter: /[\u00fb\u00f9\u00fc]/g, alternative: "u" }, { letter: /[\u00db\u00d9\u00dc]/g, alternative: "U" }, { letter: /[\u00f1]/g, alternative: "n" }, { letter: /[\u00d1]/g, alternative: "N" }], ch: [{ letter: /[\u0027]/g, alternative: "" }, { letter: /[\u00e5]/g, alternative: "a" }, { letter: /[\u00c5]/g, alternative: "A" }, { letter: /[\u00f1]/g, alternative: "n" }, { letter: /[\u00d1]/g, alternative: "N" }], co: [{ letter: /[\u00e2\u00e0]/g, alternative: "a" }, { letter: /[\u00c2\u00c0]/g, alternative: "A" }, { letter: /[\u00e6\u04d5]/g, alternative: "ae" }, { letter: /[\u00c6\u04d4]/g, alternative: "Ae" }, { letter: /[\u00e7]/g, alternative: "c" }, { letter: /[\u00c7]/g, alternative: "C" }, { letter: /[\u00e9\u00ea\u00e8\u00eb]/g, alternative: "e" }, { letter: /[\u00c9\u00ca\u00c8\u00cb]/g, alternative: "E" }, { letter: /[\u00ec\u00ee\u00ef]/g, alternative: "i" }, { letter: /[\u00cc\u00ce\u00cf]/g, alternative: "I" }, { letter: /[\u00f1]/g, alternative: "n" }, { letter: /[\u00d1]/g, alternative: "N" }, { letter: /[\u00f4\u00f2]/g, alternative: "o" }, { letter: /[\u00d4\u00d2]/g, alternative: "O" }, { letter: /[\u0153]/g, alternative: "oe" }, { letter: /[\u0152]]/g, alternative: "Oe" }, { letter: /[\u00f9\u00fc]/g, alternative: "u" }, { letter: /[\u00d9\u00dc]/g, alternative: "U" }, { letter: /[\u00ff]/g, alternative: "y" }, { letter: /[\u0178]/g, alternative: "Y" }], csb: [{ letter: /[\u0105\u00e3]/g, alternative: "a" }, { letter: /[\u0104\u00c3]/g, alternative: "A" }, { letter: /[\u00e9\u00eb]/g, alternative: "e" }, { letter: /[\u00c9\u00cb]/g, alternative: "E" }, { letter: /[\u0142]/g, alternative: "l" }, { letter: /[\u0141]/g, alternative: "L" }, { letter: /[\u0144]/g, alternative: "n" }, { letter: /[\u0143]/g, alternative: "N" }, { letter: /[\u00f2\u00f3\u00f4]/g, alternative: "o" }, { letter: /[\u00d2\u00d3\u00d4]/g, alternative: "O" }, { letter: /[\u00f9]/g, alternative: "u" }, { letter: /[\u00d9]/g, alternative: "U" }, { letter: /[\u017c]/g, alternative: "z" }, { letter: /[\u017b]/g, alternative: "Z" }], cy: [{ letter: /[\u00e2]/g, alternative: "a" }, { letter: /[\u00c2]/g, alternative: "A" }, { letter: /[\u00ea]/g, alternative: "e" }, { letter: /[\u00ca]/g, alternative: "E" }, { letter: /[\u00ee]/g, alternative: "i" }, { letter: /[\u00ce]/g, alternative: "I" }, { letter: /[\u00f4]/g, alternative: "o" }, { letter: /[\u00d4]/g, alternative: "O" }, { letter: /[\u00fb]/g, alternative: "u" }, { letter: /[\u00db]/g, alternative: "U" }, { letter: /[\u0175]/g, alternative: "w" }, { letter: /[\u0174]/g, alternative: "W" }, { letter: /[\u0177]/g, alternative: "y" }, { letter: /[\u0176]/g, alternative: "Y" }], ee: [{ letter: /[\u0256]/g, alternative: "d" }, { letter: /[\u0189]/g, alternative: "D" }, { letter: /[\u025b]/g, alternative: "e" }, { letter: /[\u0190]/g, alternative: "E" }, { letter: /[\u0192]/g, alternative: "f" }, { letter: /[\u0191]/g, alternative: "F" }, { letter: /[\u0263]/g, alternative: "g" }, { letter: /[\u0194]/g, alternative: "G" }, { letter: /[\u014b]/g, alternative: "ng" }, { letter: /[\u014a]/g, alternative: "Ng" }, { letter: /[\u0254]/g, alternative: "o" }, { letter: /[\u0186]/g, alternative: "O" }, { letter: /[\u028b]/g, alternative: "w" }, { letter: /[\u01b2]/g, alternative: "W" }, { letter: /\u0061\u0303/g, alternative: "a" }, { letter: /[\u00e1\u00e0\u01ce\u00e2\u00e3]/g, alternative: "a" }, { letter: /\u0041\u0303/g, alternative: "A" }, { letter: /[\u00c1\u00c0\u01cd\u00c2\u00c3]/g, alternative: "A" }, { letter: /[\u00e9\u00e8\u011b\u00ea]/g, alternative: "e" }, { letter: /[\u00c9\u00c8\u011a\u00ca]/g, alternative: "E" }, { letter: /[\u00f3\u00f2\u01d2\u00f4]/g, alternative: "o" }, { letter: /[\u00d3\u00d2\u01d1\u00d4]/g, alternative: "O" }, { letter: /[\u00fa\u00f9\u01d4\u00fb]/g, alternative: "u" }, { letter: /[\u00da\u00d9\u01d3\u00db]/g, alternative: "U" }, { letter: /[\u00ed\u00ec\u01d0\u00ee]/g, alternative: "i" }, { letter: /[\u00cd\u00cc\u01cf\u00ce]/g, alternative: "I" }], et: [{ letter: /[\u0161]/g, alternative: "sh" }, { letter: /[\u0160]/g, alternative: "Sh" }, { letter: /[\u017e]/g, alternative: "zh" }, { letter: /[\u017d]/g, alternative: "Zh" }, { letter: /[\u00f5\u00f6]/g, alternative: "o" }, { letter: /[\u00d6\u00d5]/g, alternative: "O" }, { letter: /[\u00e4]/g, alternative: "a" }, { letter: /[\u00c4]/g, alternative: "A" }, { letter: /[\u00fc]/g, alternative: "u" }, { letter: /[\u00dc]/g, alternative: "U" }], eu: [{ letter: /[\u00f1]/g, alternative: "n" }, { letter: /[\u00d1]/g, alternative: "N" }, { letter: /[\u00e7]/g, alternative: "c" }, { letter: /[\u00c7]/g, alternative: "C" }, { letter: /[\u00fc]/g, alternative: "u" }, { letter: /[\u00dc]/g, alternative: "U" }], fuc: [{ letter: /[\u0253]/g, alternative: "b" }, { letter: /[\u0181]/g, alternative: "B" }, { letter: /[\u0257]/g, alternative: "d" }, { letter: /[\u018a]/g, alternative: "D" }, { letter: /[\u014b]/g, alternative: "ng" }, { letter: /[\u014a]/g, alternative: "Ng" }, { letter: /[\u0272\u00f1]/g, alternative: "ny" }, { letter: /[\u019d\u00d1]/g, alternative: "Ny" }, { letter: /[\u01b4]/g, alternative: "y" }, { letter: /[\u01b3]/g, alternative: "Y" }, { letter: /[\u0260]/g, alternative: "g" }, { letter: /[\u0193]/g, alternative: "G" }], fj: [{ letter: /[\u0101]/g, alternative: "a" }, { letter: /[\u0100]/g, alternative: "A" }, { letter: /[\u0113]/g, alternative: "e" }, { letter: /[\u0112]/g, alternative: "E" }, { letter: /[\u012b]/g, alternative: "i" }, { letter: /[\u012a]/g, alternative: "I" }, { letter: /[\u016b]/g, alternative: "u" }, { letter: /[\u016a]/g, alternative: "U" }, { letter: /[\u014d]/g, alternative: "o" }, { letter: /[\u014c]/g, alternative: "O" }], frp: [{ letter: /[\u00e2]/g, alternative: "a" }, { letter: /[\u00c2]/g, alternative: "A" }, { letter: /[\u00ea\u00e8\u00e9]/g, alternative: "e" }, { letter: /[\u00ca\u00c8\u00c9]/g, alternative: "E" }, { letter: /[\u00ee]/g, alternative: "i" }, { letter: /[\u00ce]/g, alternative: "I" }, { letter: /[\u00fb\u00fc]/g, alternative: "u" }, { letter: /[\u00db\u00dc]/g, alternative: "U" }, { letter: /[\u00f4]/g, alternative: "o" }, { letter: /[\u00d4]/g, alternative: "O" }], fur: [{ letter: /[\u00E7]/g, alternative: "c" }, { letter: /[\u00C7]/g, alternative: "C" }, { letter: /[\u00e0\u00e2]/g, alternative: "a" }, { letter: /[\u00c0\u00c2]/g, alternative: "A" }, { letter: /[\u00e8\u00ea]/g, alternative: "e" }, { letter: /[\u00c8\u00ca]/g, alternative: "E" }, { letter: /[\u00ec\u00ee]/g, alternative: "i" }, { letter: /[\u00cc\u00ce]/g, alternative: "I" }, { letter: /[\u00f2\u00f4]/g, alternative: "o" }, { letter: /[\u00d2\u00d4]/g, alternative: "O" }, { letter: /[\u00f9\u00fb]/g, alternative: "u" }, { letter: /[\u00d9\u00db]/g, alternative: "U" }, { letter: /[\u010d]/g, alternative: "c" }, { letter: /[\u010c]/g, alternative: "C" }, { letter: /[\u011f]/g, alternative: "g" }, { letter: /[\u011e]/g, alternative: "G" }, { letter: /[\u0161]/g, alternative: "s" }, { letter: /[\u0160]/g, alternative: "S" }], fy: [{ letter: /[\u00e2\u0101\u00e4\u00e5]/g, alternative: "a" }, { letter: /[\u00c2\u0100\u00c4\u00c5]/g, alternative: "A" }, { letter: /[\u00ea\u00e9\u0113]/g, alternative: "e" }, { letter: /[\u00ca\u00c9\u0112]/g, alternative: "E" }, { letter: /[\u00f4\u00f6]/g, alternative: "o" }, { letter: /[\u00d4\u00d6]/g, alternative: "O" }, { letter: /[\u00fa\u00fb\u00fc]/g, alternative: "u" }, { letter: /[\u00da\u00db\u00dc]/g, alternative: "U" }, { letter: /[\u00ed]/g, alternative: "i" }, { letter: /[\u00cd]/g, alternative: "I" }, { letter: /[\u0111\u00f0]/g, alternative: "d" }, { letter: /[\u0110\u00d0]/g, alternative: "D" }], ga: [{ letter: /[\u00e1]/g, alternative: "a" }, { letter: /[\u00c1]/g, alternative: "A" }, { letter: /[\u00e9]/g, alternative: "e" }, { letter: /[\u00c9]/g, alternative: "E" }, { letter: /[\u00f3]/g, alternative: "o" }, { letter: /[\u00d3]/g, alternative: "O" }, { letter: /[\u00fa]/g, alternative: "u" }, { letter: /[\u00da]/g, alternative: "U" }, { letter: /[\u00ed]/g, alternative: "i" }, { letter: /[\u00cd]/g, alternative: "I" }], gd: [{ letter: /[\u00e0]/g, alternative: "a" }, { letter: /[\u00c0]/g, alternative: "A" }, { letter: /[\u00e8]/g, alternative: "e" }, { letter: /[\u00c8]/g, alternative: "E" }, { letter: /[\u00f2]/g, alternative: "o" }, { letter: /[\u00d2]/g, alternative: "O" }, { letter: /[\u00f9]/g, alternative: "u" }, { letter: /[\u00d9]/g, alternative: "U" }, { letter: /[\u00ec]/g, alternative: "i" }, { letter: /[\u00cc]/g, alternative: "I" }], gl: [{ letter: /[\u00e1\u00e0]/g, alternative: "a" }, { letter: /[\u00c1\u00c0]/g, alternative: "A" }, { letter: /[\u00e9\u00ea]/g, alternative: "e" }, { letter: /[\u00c9\u00ca]/g, alternative: "E" }, { letter: /[\u00ed\u00ef]/g, alternative: "i" }, { letter: /[\u00cd\u00cf]/g, alternative: "I" }, { letter: /[\u00f3]/g, alternative: "o" }, { letter: /[\u00d3]/g, alternative: "O" }, { letter: /[\u00fa\u00fc]/g, alternative: "u" }, { letter: /[\u00da\u00dc]/g, alternative: "U" }, { letter: /[\u00e7]/g, alternative: "c" }, { letter: /[\u00c7]/g, alternative: "C" }, { letter: /[\u00f1]/g, alternative: "n" }, { letter: /[\u00d1]/g, alternative: "N" }], gn: [{ letter: /[\u2019]/g, alternative: "" }, { letter: /\u0067\u0303/g, alternative: "g" }, { letter: /\u0047\u0303/g, alternative: "G" }, { letter: /[\u00e3]/g, alternative: "a" }, { letter: /[\u00c3]/g, alternative: "A" }, { letter: /[\u1ebd]/g, alternative: "e" }, { letter: /[\u1ebc]/g, alternative: "E" }, { letter: /[\u0129]/g, alternative: "i" }, { letter: /[\u0128]/g, alternative: "I" }, { letter: /[\u00f5]/g, alternative: "o" }, { letter: /[\u00d5]/g, alternative: "O" }, { letter: /[\u00f1]/g, alternative: "n" }, { letter: /[\u00d1]/g, alternative: "N" }, { letter: /[\u0169]/g, alternative: "u" }, { letter: /[\u0168]/g, alternative: "U" }, { letter: /[\u1ef9]/g, alternative: "y" }, { letter: /[\u1ef8]/g, alternative: "Y" }], gsw: [{ letter: /[\u00e4]/g, alternative: "a" }, { letter: /[\u00c4]/g, alternative: "A" }, { letter: /[\u00f6]/g, alternative: "o" }, { letter: /[\u00d6]/g, alternative: "O" }, { letter: /[\u00fc]/g, alternative: "u" }, { letter: /[\u00dc]/g, alternative: "U" }], hat: [{ letter: /[\u00e8]/g, alternative: "e" }, { letter: /[\u00c8]/g, alternative: "E" }, { letter: /[\u00f2]/g, alternative: "o" }, { letter: /[\u00d2]/g, alternative: "O" }], haw: [{ letter: /[\u02bb\u0027\u2019]/g, alternative: "" }, { letter: /[\u0101]/g, alternative: "a" }, { letter: /[\u0113]/g, alternative: "e" }, { letter: /[\u012b]/g, alternative: "i" }, { letter: /[\u014d]/g, alternative: "o" }, { letter: /[\u016b]/g, alternative: "u" }, { letter: /[\u0100]/g, alternative: "A" }, { letter: /[\u0112]/g, alternative: "E" }, { letter: /[\u012a]/g, alternative: "I" }, { letter: /[\u014c]/g, alternative: "O" }, { letter: /[\u016a]/g, alternative: "U" }], hr: [{ letter: /[\u010d\u0107]/g, alternative: "c" }, { letter: /[\u010c\u0106]/g, alternative: "C" }, { letter: /[\u0111]/g, alternative: "dj" }, { letter: /[\u0110]/g, alternative: "Dj" }, { letter: /[\u0161]/g, alternative: "s" }, { letter: /[\u0160]/g, alternative: "S" }, { letter: /[\u017e]/g, alternative: "z" }, { letter: /[\u017d]/g, alternative: "Z" }, { letter: /[\u01c4]/g, alternative: "DZ" }, { letter: /[\u01c5]/g, alternative: "Dz" }, { letter: /[\u01c6]/g, alternative: "dz" }], ka: [{ letter: /[\u10d0]/g, alternative: "a" }, { letter: /[\u10d1]/g, alternative: "b" }, { letter: /[\u10d2]/g, alternative: "g" }, { letter: /[\u10d3]/g, alternative: "d" }, { letter: /[\u10d4]/g, alternative: "e" }, { letter: /[\u10d5]/g, alternative: "v" }, { letter: /[\u10d6]/g, alternative: "z" }, { letter: /[\u10d7]/g, alternative: "t" }, { letter: /[\u10d8]/g, alternative: "i" }, { letter: /[\u10d9]/g, alternative: "k" }, { letter: /[\u10da]/g, alternative: "l" }, { letter: /[\u10db]/g, alternative: "m" }, { letter: /[\u10dc]/g, alternative: "n" }, { letter: /[\u10dd]/g, alternative: "o" }, { letter: /[\u10de]/g, alternative: "p" }, { letter: /[\u10df]/g, alternative: "zh" }, { letter: /[\u10e0]/g, alternative: "r" }, { letter: /[\u10e1]/g, alternative: "s" }, { letter: /[\u10e2]/g, alternative: "t" }, { letter: /[\u10e3]/g, alternative: "u" }, { letter: /[\u10e4]/g, alternative: "p" }, { letter: /[\u10e5]/g, alternative: "k" }, { letter: /[\u10e6]/g, alternative: "gh" }, { letter: /[\u10e7]/g, alternative: "q" }, { letter: /[\u10e8]/g, alternative: "sh" }, { letter: /[\u10e9]/g, alternative: "ch" }, { letter: /[\u10ea]/g, alternative: "ts" }, { letter: /[\u10eb]/g, alternative: "dz" }, { letter: /[\u10ec]/g, alternative: "ts" }, { letter: /[\u10ed]/g, alternative: "ch" }, { letter: /[\u10ee]/g, alternative: "kh" }, { letter: /[\u10ef]/g, alternative: "j" }, { letter: /[\u10f0]/g, alternative: "h" }], kal: [{ letter: /[\u00E5]/g, alternative: "aa" }, { letter: /[\u00C5]/g, alternative: "Aa" }, { letter: /[\u00E6\u04D5]/g, alternative: "ae" }, { letter: /[\u00C6\u04D4]/g, alternative: "Ae" }, { letter: /[\u00C4]/g, alternative: "Ae" }, { letter: /[\u00F8]/g, alternative: "oe" }, { letter: /[\u00D8]/g, alternative: "Oe" }], kin: [{ letter: /[\u2019\u0027]/g, alternative: "" }], lb: [{ letter: /[\u00e4]/g, alternative: "a" }, { letter: /[\u00c4]/g, alternative: "A" }, { letter: /[\u00eb\u00e9]/g, alternative: "e" }, { letter: /[\u00cb\u00c9]/g, alternative: "E" }], li: [{ letter: /[\u00e1\u00e2\u00e0\u00e4]/g, alternative: "a" }, { letter: /[\u00c1\u00c2\u00c0\u00c4]/g, alternative: "A" }, { letter: /[\u00eb\u00e8\u00ea]/g, alternative: "e" }, { letter: /[\u00cb\u00c8\u00ca]/g, alternative: "E" }, { letter: /[\u00f6\u00f3]/g, alternative: "o" }, { letter: /[\u00d6\u00d3]/g, alternative: "O" }], lin: [{ letter: /[\u00e1\u00e2\u01ce]/g, alternative: "a" }, { letter: /[\u00c1\u00c2\u01cd]/g, alternative: "A" }, { letter: /\u025b\u0301/g, alternative: "e" }, { letter: /\u025b\u0302/g, alternative: "e" }, { letter: /\u025b\u030c/g, alternative: "e" }, { letter: /[\u00e9\u00ea\u011b\u025b]/g, alternative: "e" }, { letter: /\u0190\u0301/g, alternative: "E" }, { letter: /\u0190\u0302/g, alternative: "E" }, { letter: /\u0190\u030c/g, alternative: "E" }, { letter: /[\u00c9\u00ca\u011a\u0190]/g, alternative: "E" }, { letter: /[\u00ed\u00ee\u01d0]/g, alternative: "i" }, { letter: /[\u00cd\u00ce\u01cf]/g, alternative: "I" }, { letter: /\u0254\u0301/g, alternative: "o" }, { letter: /\u0254\u0302/g, alternative: "o" }, { letter: /\u0254\u030c/g, alternative: "o" }, { letter: /[\u00f3\u00f4\u01d2\u0254]/g, alternative: "o" }, { letter: /\u0186\u0301/g, alternative: "O" }, { letter: /\u0186\u0302/g, alternative: "O" }, { letter: /\u0186\u030c/g, alternative: "O" }, { letter: /[\u00d3\u00d4\u01d1\u0186]/g, alternative: "O" }, { letter: /[\u00fa]/g, alternative: "u" }, { letter: /[\u00da]/g, alternative: "U" }], lt: [{ letter: /[\u0105]/g, alternative: "a" }, { letter: /[\u0104]/g, alternative: "A" }, { letter: /[\u010d]/g, alternative: "c" }, { letter: /[\u010c]/g, alternative: "C" }, { letter: /[\u0119\u0117]/g, alternative: "e" }, { letter: /[\u0118\u0116]/g, alternative: "E" }, { letter: /[\u012f]/g, alternative: "i" }, { letter: /[\u012e]/g, alternative: "I" }, { letter: /[\u0161]/g, alternative: "s" }, { letter: /[\u0160]/g, alternative: "S" }, { letter: /[\u0173\u016b]/g, alternative: "u" }, { letter: /[\u0172\u016a]/g, alternative: "U" }, { letter: /[\u017e]/g, alternative: "z" }, { letter: /[\u017d]/g, alternative: "Z" }], mg: [{ letter: /[\u00f4]/g, alternative: "ao" }, { letter: /[\u00d4]/g, alternative: "Ao" }], mk: [{ letter: /[\u0430]/g, alternative: "a" }, { letter: /[\u0410]/g, alternative: "A" }, { letter: /[\u0431]/g, alternative: "b" }, { letter: /[\u0411]/g, alternative: "B" }, { letter: /[\u0432]/g, alternative: "v" }, { letter: /[\u0412]/g, alternative: "V" }, { letter: /[\u0433]/g, alternative: "g" }, { letter: /[\u0413]/g, alternative: "G" }, { letter: /[\u0434]/g, alternative: "d" }, { letter: /[\u0414]/g, alternative: "D" }, { letter: /[\u0453]/g, alternative: "gj" }, { letter: /[\u0403]/g, alternative: "Gj" }, { letter: /[\u0435]/g, alternative: "e" }, { letter: /[\u0415]/g, alternative: "E" }, { letter: /[\u0436]/g, alternative: "zh" }, { letter: /[\u0416]/g, alternative: "Zh" }, { letter: /[\u0437]/g, alternative: "z" }, { letter: /[\u0417]/g, alternative: "Z" }, { letter: /[\u0455]/g, alternative: "dz" }, { letter: /[\u0405]/g, alternative: "Dz" }, { letter: /[\u0438]/g, alternative: "i" }, { letter: /[\u0418]/g, alternative: "I" }, { letter: /[\u0458]/g, alternative: "j" }, { letter: /[\u0408]/g, alternative: "J" }, { letter: /[\u043A]/g, alternative: "k" }, { letter: /[\u041A]/g, alternative: "K" }, { letter: /[\u043B]/g, alternative: "l" }, { letter: /[\u041B]/g, alternative: "L" }, { letter: /[\u0459]/g, alternative: "lj" }, { letter: /[\u0409]/g, alternative: "Lj" }, { letter: /[\u043C]/g, alternative: "m" }, { letter: /[\u041C]/g, alternative: "M" }, { letter: /[\u043D]/g, alternative: "n" }, { letter: /[\u041D]/g, alternative: "N" }, { letter: /[\u045A]/g, alternative: "nj" }, { letter: /[\u040A]/g, alternative: "Nj" }, { letter: /[\u043E]/g, alternative: "o" }, { letter: /[\u041E]/g, alternative: "O" }, { letter: /[\u0440]/g, alternative: "r" }, { letter: /[\u0420]/g, alternative: "R" }, { letter: /[\u043F]/g, alternative: "p" }, { letter: /[\u041F]/g, alternative: "P" }, { letter: /[\u0441]/g, alternative: "s" }, { letter: /[\u0421]/g, alternative: "S" }, { letter: /[\u0442]/g, alternative: "t" }, { letter: /[\u0422]/g, alternative: "T" }, { letter: /[\u045C]/g, alternative: "kj" }, { letter: /[\u040C]/g, alternative: "Kj" }, { letter: /[\u0443]/g, alternative: "u" }, { letter: /[\u0423]/g, alternative: "U" }, { letter: /[\u0444]/g, alternative: "f" }, { letter: /[\u0424]/g, alternative: "F" }, { letter: /[\u0445]/g, alternative: "h" }, { letter: /[\u0425]/g, alternative: "H" }, { letter: /[\u0446]/g, alternative: "c" }, { letter: /[\u0426]/g, alternative: "C" }, { letter: /[\u0447]/g, alternative: "ch" }, { letter: /[\u0427]/g, alternative: "Ch" }, { letter: /[\u045F]/g, alternative: "dj" }, { letter: /[\u040F]/g, alternative: "Dj" }, { letter: /[\u0448]/g, alternative: "sh" }, { letter: /[\u0428]/g, alternative: "Sh" }], mri: [{ letter: /[\u0101]/g, alternative: "aa" }, { letter: /[\u0100]/g, alternative: "Aa" }, { letter: /[\u0113]/g, alternative: "ee" }, { letter: /[\u0112]/g, alternative: "Ee" }, { letter: /[\u012b]/g, alternative: "ii" }, { letter: /[\u012a]/g, alternative: "Ii" }, { letter: /[\u014d]/g, alternative: "oo" }, { letter: /[\u014c]/g, alternative: "Oo" }, { letter: /[\u016b]/g, alternative: "uu" }, { letter: /[\u016a]/g, alternative: "Uu" }], mwl: [{ letter: /[\u00e7]/g, alternative: "c" }, { letter: /[\u00c7]/g, alternative: "C" }, { letter: /[\u00e1]/g, alternative: "a" }, { letter: /[\u00c1]/g, alternative: "A" }, { letter: /[\u00e9\u00ea]/g, alternative: "e" }, { letter: /[\u00c9\u00ca]/g, alternative: "E" }, { letter: /[\u00ed]/g, alternative: "i" }, { letter: /[\u00cd]/g, alternative: "I" }, { letter: /[\u00f3\u00f4]/g, alternative: "o" }, { letter: /[\u00d3\u00d4]/g, alternative: "O" }, { letter: /[\u00fa\u0169]/g, alternative: "u" }, { letter: /[\u00da\u0168]/g, alternative: "U" }], oci: [{ letter: /[\u00e7]/g, alternative: "c" }, { letter: /[\u00c7]/g, alternative: "C" }, { letter: /[\u00e0\u00e1]/g, alternative: "a" }, { letter: /[\u00c0\u00c1]/g, alternative: "A" }, { letter: /[\u00e8\u00e9]/g, alternative: "e" }, { letter: /[\u00c8\u00c9]/g, alternative: "E" }, { letter: /[\u00ed\u00ef]/g, alternative: "i" }, { letter: /[\u00cd\u00cf]/g, alternative: "I" }, { letter: /[\u00f2\u00f3]/g, alternative: "o" }, { letter: /[\u00d2\u00d3]/g, alternative: "O" }, { letter: /[\u00fa\u00fc]/g, alternative: "u" }, { letter: /[\u00da\u00dc]/g, alternative: "U" }, { letter: /[\u00b7]/g, alternative: "" }], orm: [{ letter: /[\u0027]/g, alternative: "" }], pt: [{ letter: /[\u00e7]/g, alternative: "c" }, { letter: /[\u00c7]/g, alternative: "C" }, { letter: /[\u00e1\u00e2\u00e3\u00e0]/g, alternative: "a" }, { letter: /[\u00c1\u00c2\u00c3\u00c0]/g, alternative: "A" }, { letter: /[\u00e9\u00ea]/g, alternative: "e" }, { letter: /[\u00c9\u00ca]/g, alternative: "E" }, { letter: /[\u00ed]/g, alternative: "i" }, { letter: /[\u00cd]/g, alternative: "I" }, { letter: /[\u00f3\u00f4\u00f5]/g, alternative: "o" }, { letter: /[\u00d3\u00d4\u00d5]/g, alternative: "O" }, { letter: /[\u00fa]/g, alternative: "u" }, { letter: /[\u00da]/g, alternative: "U" }], roh: [{ letter: /[\u00e9\u00e8\u00ea]/g, alternative: "e" }, { letter: /[\u00c9\u00c8\u00ca]/g, alternative: "E" }, { letter: /[\u00ef]/g, alternative: "i" }, { letter: /[\u00cf]/g, alternative: "I" }, { letter: /[\u00f6]/g, alternative: "oe" }, { letter: /[\u00d6]/g, alternative: "Oe" }, { letter: /[\u00fc]/g, alternative: "ue" }, { letter: /[\u00dc]/g, alternative: "Ue" }, { letter: /[\u00e4]/g, alternative: "ae" }, { letter: /[\u00c4]/g, alternative: "Ae" }], rup: [{ letter: /[\u00e3]/g, alternative: "a" }, { letter: /[\u00c3]/g, alternative: "A" }], ro: [{ letter: /[\u0103\u00e2]/g, alternative: "a" }, { letter: /[\u0102\u00c2]/g, alternative: "A" }, { letter: /[\u00ee]/g, alternative: "i" }, { letter: /[\u00ce]/g, alternative: "I" }, { letter: /[\u0219\u015f]/g, alternative: "s" }, { letter: /[\u0218\u015e]/g, alternative: "S" }, { letter: /[\u021b\u0163]/g, alternative: "t" }, { letter: /[\u021a\u0162]/g, alternative: "T" }], tlh: [{ letter: /[\u2019\u0027]/g, alternative: "" }], sk: [{ letter: /[\u01c4]/g, alternative: "DZ" }, { letter: /[\u01c5]/g, alternative: "Dz" }, { letter: /[\u01c6]/g, alternative: "dz" }, { letter: /[\u00e1\u00e4]/g, alternative: "a" }, { letter: /[\u00c1\u00c4]/g, alternative: "A" }, { letter: /[\u010d]/g, alternative: "c" }, { letter: /[\u010c]/g, alternative: "C" }, { letter: /[\u010f]/g, alternative: "d" }, { letter: /[\u010e]/g, alternative: "D" }, { letter: /[\u00e9]/g, alternative: "e" }, { letter: /[\u00c9]/g, alternative: "E" }, { letter: /[\u00ed]/g, alternative: "i" }, { letter: /[\u00cd]/g, alternative: "I" }, { letter: /[\u013e\u013a]/g, alternative: "l" }, { letter: /[\u013d\u0139]/g, alternative: "L" }, { letter: /[\u0148]/g, alternative: "n" }, { letter: /[\u0147]/g, alternative: "N" }, { letter: /[\u00f3\u00f4]/g, alternative: "o" }, { letter: /[\u00d3\u00d4]/g, alternative: "O" }, { letter: /[\u0155]/g, alternative: "r" }, { letter: /[\u0154]/g, alternative: "R" }, { letter: /[\u0161]/g, alternative: "s" }, { letter: /[\u0160]/g, alternative: "S" }, { letter: /[\u0165]/g, alternative: "t" }, { letter: /[\u0164]/g, alternative: "T" }, { letter: /[\u00fa]/g, alternative: "u" }, { letter: /[\u00da]/g, alternative: "U" }, { letter: /[\u00fd]/g, alternative: "y" }, { letter: /[\u00dd]/g, alternative: "Y" }, { letter: /[\u017e]/g, alternative: "z" }, { letter: /[\u017d]/g, alternative: "Z" }], sl: [{ letter: /[\u010d\u0107]/g, alternative: "c" }, { letter: /[\u010c\u0106]/g, alternative: "C" }, { letter: /[\u0111]/g, alternative: "d" }, { letter: /[\u0110]/g, alternative: "D" }, { letter: /[\u0161]/g, alternative: "s" }, { letter: /[\u0160]/g, alternative: "S" }, { letter: /[\u017e]/g, alternative: "z" }, { letter: /[\u017d]/g, alternative: "Z" }, { letter: /[\u00e0\u00e1\u0203\u0201]/g, alternative: "a" }, { letter: /[\u00c0\u00c1\u0202\u0200]/g, alternative: "A" }, { letter: /[\u00e8\u00e9\u0207\u0205]/g, alternative: "e" }, { letter: /\u01dd\u0300/g, alternative: "e" }, { letter: /\u01dd\u030f/g, alternative: "e" }, { letter: /\u1eb9\u0301/g, alternative: "e" }, { letter: /\u1eb9\u0311/g, alternative: "e" }, { letter: /[\u00c8\u00c9\u0206\u0204]/g, alternative: "E" }, { letter: /\u018e\u030f/g, alternative: "E" }, { letter: /\u018e\u0300/g, alternative: "E" }, { letter: /\u1eb8\u0311/g, alternative: "E" }, { letter: /\u1eb8\u0301/g, alternative: "E" }, { letter: /[\u00ec\u00ed\u020b\u0209]/g, alternative: "i" }, { letter: /[\u00cc\u00cd\u020a\u0208]/g, alternative: "I" }, { letter: /[\u00f2\u00f3\u020f\u020d]/g, alternative: "o" }, { letter: /\u1ecd\u0311/g, alternative: "o" }, { letter: /\u1ecd\u0301/g, alternative: "o" }, { letter: /\u1ecc\u0311/g, alternative: "O" }, { letter: /\u1ecc\u0301/g, alternative: "O" }, { letter: /[\u00d2\u00d3\u020e\u020c]/g, alternative: "O" }, { letter: /[\u00f9\u00fa\u0217\u0215]/g, alternative: "u" }, { letter: /[\u00d9\u00da\u0216\u0214]/g, alternative: "U" }, { letter: /[\u0155\u0213]/g, alternative: "r" }, { letter: /[\u0154\u0212]/g, alternative: "R" }], sq: [{ letter: /[\u00e7]/g, alternative: "c" }, { letter: /[\u00c7]/g, alternative: "C" }, { letter: /[\u00eb]/g, alternative: "e" }, { letter: /[\u00cb]/g, alternative: "E" }], hu: [{ letter: /[\u00e1]/g, alternative: "a" }, { letter: /[\u00c1]/g, alternative: "A" }, { letter: /[\u00e9]/g, alternative: "e" }, { letter: /[\u00c9]/g, alternative: "E" }, { letter: /[\u00ed]/g, alternative: "i" }, { letter: /[\u00cd]/g, alternative: "I" }, { letter: /[\u00f3\u00f6\u0151]/g, alternative: "o" }, { letter: /[\u00d3\u00d6\u0150]/g, alternative: "O" }, { letter: /[\u00fa\u00fc\u0171]/g, alternative: "u" }, { letter: /[\u00da\u00dc\u0170]/g, alternative: "U" }], srd: [{ letter: /[\u00e7]/g, alternative: "c" }, { letter: /[\u00c7]/g, alternative: "C" }, { letter: /[\u00e0\u00e1]/g, alternative: "a" }, { letter: /[\u00c0\u00c1]/g, alternative: "A" }, { letter: /[\u00e8\u00e9]/g, alternative: "e" }, { letter: /[\u00c8\u00c9]/g, alternative: "E" }, { letter: /[\u00ed\u00ef]/g, alternative: "i" }, { letter: /[\u00cd\u00cf]/g, alternative: "I" }, { letter: /[\u00f2\u00f3]/g, alternative: "o" }, { letter: /[\u00d2\u00d3]/g, alternative: "O" }, { letter: /[\u00fa\u00f9]/g, alternative: "u" }, { letter: /[\u00da\u00d9]/g, alternative: "U" }], szl: [{ letter: /[\u0107]/g, alternative: "c" }, { letter: /[\u0106]/g, alternative: "C" }, { letter: /[\u00e3]/g, alternative: "a" }, { letter: /[\u00c3]/g, alternative: "A" }, { letter: /[\u0142]/g, alternative: "u" }, { letter: /[\u0141]/g, alternative: "U" }, { letter: /[\u006e]/g, alternative: "n" }, { letter: /[\u004e]/g, alternative: "N" }, { letter: /[\u014f\u014d\u00f4\u00f5]/g, alternative: "o" }, { letter: /[\u014e\u014c\u00d4\u00d5]/g, alternative: "O" }, { letter: /[\u015b]/g, alternative: "s" }, { letter: /[\u015a]/g, alternative: "S" }, { letter: /[\u017a\u017c\u017e]/g, alternative: "z" }, { letter: /[\u0179\u017b\u017d]/g, alternative: "Z" }, { letter: /[\u016f]/g, alternative: "u" }, { letter: /[\u016e]/g, alternative: "U" }, { letter: /[\u010d]/g, alternative: "cz" }, { letter: /[\u010c]/g, alternative: "Cz" }, { letter: /[\u0159]/g, alternative: "rz" }, { letter: /[\u0158]/g, alternative: "Rz" }, { letter: /[\u0161]/g, alternative: "sz" }, { letter: /[\u0160]/g, alternative: "Sz" }], tah: [{ letter: /[\u0101\u00e2\u00e0]/g, alternative: "a" }, { letter: /[\u0100\u00c2\u00c0]/g, alternative: "A" }, { letter: /[\u00ef\u00ee\u00ec]/g, alternative: "i" }, { letter: /[\u00cf\u00ce\u00cc]/g, alternative: "I" }, { letter: /[\u0113\u00ea\u00e9]/g, alternative: "e" }, { letter: /[\u0112\u00ca\u00c9]/g, alternative: "E" }, { letter: /[\u016b\u00fb\u00fa]/g, alternative: "u" }, { letter: /[\u016a\u00db\u00da]/g, alternative: "U" }, { letter: /[\u00e7]/g, alternative: "c" }, { letter: /[\u00c7]/g, alternative: "C" }, { letter: /[\u00f2\u00f4\u014d]/g, alternative: "o" }, { letter: /[\u00d2\u00d4\u014c]/g, alternative: "O" }, { letter: /[\u2019\u0027\u2018]/g, alternative: "" }], vec: [{ letter: /\u0073\u002d\u0063/g, alternative: "sc" }, { letter: /\u0053\u002d\u0043/g, alternative: "SC" }, { letter: /\u0073\u0027\u0063/g, alternative: "sc" }, { letter: /\u0053\u0027\u0043/g, alternative: "SC" }, { letter: /\u0073\u2019\u0063/g, alternative: "sc" }, { letter: /\u0053\u2019\u0043/g, alternative: "SC" }, { letter: /\u0073\u2018\u0063/g, alternative: "sc" }, { letter: /\u0053\u2018\u0043/g, alternative: "SC" }, { letter: /\u0053\u002d\u0063/g, alternative: "Sc" }, { letter: /\u0053\u0027\u0063/g, alternative: "Sc" }, { letter: /\u0053\u2019\u0063/g, alternative: "Sc" }, { letter: /\u0053\u2018\u0063/g, alternative: "Sc" }, { letter: /\u0063\u2019/g, alternative: "c" }, { letter: /\u0043\u2019/g, alternative: "C" }, { letter: /\u0063\u2018/g, alternative: "c" }, { letter: /\u0043\u2018/g, alternative: "C" }, { letter: /\u0063\u0027/g, alternative: "c" }, { letter: /\u0043\u0027/g, alternative: "C" }, { letter: /[\u00e0\u00e1\u00e2]/g, alternative: "a" }, { letter: /[\u00c0\u00c1\u00c2]/g, alternative: "A" }, { letter: /[\u00e8\u00e9]/g, alternative: "e" }, { letter: /[\u00c8\u00c9]/g, alternative: "E" }, { letter: /[\u00f2\u00f3]/g, alternative: "o" }, { letter: /[\u00d2\u00d3]/g, alternative: "O" }, { letter: /[\u00f9\u00fa]/g, alternative: "u" }, { letter: /[\u00d9\u00da]/g, alternative: "U" }, { letter: /[\u00e7\u010d\u010b]/g, alternative: "c" }, { letter: /[\u00c7\u010c\u010a]/g, alternative: "C" }, { letter: /[\u0142]/g, alternative: "l" }, { letter: /[\u00a3\u0141]/g, alternative: "L" }, { letter: /\ud835\udeff/g, alternative: "dh" }, { letter: /[\u0111\u03b4]/g, alternative: "dh" }, { letter: /[\u0110\u0394]/g, alternative: "Dh" }], wa: [{ letter: /[\u00e2\u00e5]/g, alternative: "a" }, { letter: /[\u00c2\u00c5]/g, alternative: "A" }, { letter: /[\u00e7]/g, alternative: "c" }, { letter: /[\u00c7]/g, alternative: "C" }, { letter: /\u0065\u030a/g, alternative: "e" }, { letter: /\u0045\u030a/g, alternative: "E" }, { letter: /[\u00eb\u00ea\u00e8\u00e9]/g, alternative: "e" }, { letter: /[\u00c9\u00c8\u00ca\u00cb]/g, alternative: "E" }, { letter: /[\u00ee]/g, alternative: "i" }, { letter: /[\u00ce]/g, alternative: "I" }, { letter: /[\u00f4\u00f6]/g, alternative: "o" }, { letter: /[\u00d6\u00d4]/g, alternative: "O" }, { letter: /[\u00fb]/g, alternative: "u" }, { letter: /[\u00db]/g, alternative: "U" }], yor: [{ letter: /[\u00e1\u00e0]/g, alternative: "a" }, { letter: /[\u00c1\u00c0]/g, alternative: "A" }, { letter: /[\u00ec\u00ed]/g, alternative: "i" }, { letter: /[\u00cc\u00cd]/g, alternative: "I" }, { letter: /\u1ecd\u0301/g, alternative: "o" }, { letter: /\u1ecc\u0301/g, alternative: "O" }, { letter: /\u1ecd\u0300/g, alternative: "o" }, { letter: /\u1ecc\u0300/g, alternative: "O" }, { letter: /[\u00f3\u00f2\u1ecd]/g, alternative: "o" }, { letter: /[\u00d3\u00d2\u1ecc]/g, alternative: "O" }, { letter: /[\u00fa\u00f9]/g, alternative: "u" }, { letter: /[\u00da\u00d9]/g, alternative: "U" }, { letter: /\u1eb9\u0301/g, alternative: "e" }, { letter: /\u1eb8\u0301/g, alternative: "E" }, { letter: /\u1eb9\u0300/g, alternative: "e" }, { letter: /\u1eb8\u0300/g, alternative: "E" }, { letter: /[\u00e9\u00e8\u1eb9]/g, alternative: "e" }, { letter: /[\u00c9\u00c8\u1eb8]/g, alternative: "E" }, { letter: /[\u1e63]/g, alternative: "s" }, { letter: /[\u1e62]/g, alternative: "S" }] }; module.exports = function (locale) {
            if (isUndefined(locale)) { return []; }
            switch (getLanguage(locale)) { case "es": return transliterations.es; case "pl": return transliterations.pl; case "de": return transliterations.de; case "nb": case "nn": return transliterations.nbnn; case "sv": return transliterations.sv; case "fi": return transliterations.fi; case "da": return transliterations.da; case "tr": return transliterations.tr; case "lv": return transliterations.lv; case "is": return transliterations.is; case "fa": return transliterations.fa; case "cs": return transliterations.cs; case "ru": return transliterations.ru; case "eo": return transliterations.eo; case "af": return transliterations.af; case "bal": case "ca": return transliterations.ca; case "ast": return transliterations.ast; case "an": return transliterations.an; case "ay": return transliterations.ay; case "en": return transliterations.en; case "fr": return transliterations.fr; case "it": return transliterations.it; case "nl": return transliterations.nl; case "bm": return transliterations.bm; case "uk": return transliterations.uk; case "br": return transliterations.br; case "ch": return transliterations.ch; case "csb": return transliterations.csb; case "cy": return transliterations.cy; case "ee": return transliterations.ee; case "et": return transliterations.et; case "eu": return transliterations.eu; case "fuc": return transliterations.fuc; case "fj": return transliterations.fj; case "frp": return transliterations.frp; case "fur": return transliterations.fur; case "fy": return transliterations.fy; case "ga": return transliterations.ga; case "gd": return transliterations.gd; case "gl": return transliterations.gl; case "gn": return transliterations.gn; case "gsw": return transliterations.gsw; case "hat": return transliterations.hat; case "haw": return transliterations.haw; case "hr": return transliterations.hr; case "ka": return transliterations.ka; case "kal": return transliterations.kal; case "kin": return transliterations.kin; case "lb": return transliterations.lb; case "li": return transliterations.li; case "lin": return transliterations.lin; case "lt": return transliterations.lt; case "mg": return transliterations.mg; case "mk": return transliterations.mk; case "mri": return transliterations.mri; case "mwl": return transliterations.mwl; case "oci": return transliterations.oci; case "orm": return transliterations.orm; case "pt": return transliterations.pt; case "roh": return transliterations.roh; case "rup": return transliterations.rup; case "ro": return transliterations.ro; case "tlh": return transliterations.tlh; case "sk": return transliterations.sk; case "sl": return transliterations.sl; case "sq": return transliterations.sq; case "hu": return transliterations.hu; case "srd": return transliterations.srd; case "szl": return transliterations.szl; case "tah": return transliterations.tah; case "vec": return transliterations.vec; case "wa": return transliterations.wa; case "yor": return transliterations.yor; default: return []; }
        };
    }), (function (module, exports, __webpack_require__) {
        "use strict"; var urlHelper = __webpack_require__(102); module.exports = function (text, url) {
            var linkType = "other"; var anchorUrl = urlHelper.getFromAnchorTag(text); if (anchorUrl.match(/https?:\/\//ig) !== null) { linkType = "external"; if (urlHelper.getHostname(anchorUrl) === urlHelper.getHostname(url)) { linkType = "internal"; } }
            return linkType;
        };
    }), (function (module, exports, __webpack_require__) {
        "use strict"; var punycode = __webpack_require__(320); var util = __webpack_require__(321); exports.parse = urlParse; exports.resolve = urlResolve; exports.resolveObject = urlResolveObject; exports.format = urlFormat; exports.Url = Url; function Url() { this.protocol = null; this.slashes = null; this.auth = null; this.host = null; this.port = null; this.hostname = null; this.hash = null; this.search = null; this.query = null; this.pathname = null; this.path = null; this.href = null; }
        var protocolPattern = /^([a-z0-9.+-]+:)/i, portPattern = /:[0-9]*$/, simplePathPattern = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/, delims = ['<', '>', '"', '`', ' ', '\r', '\n', '\t'], unwise = ['{', '}', '|', '\\', '^', '`'].concat(delims), autoEscape = ['\''].concat(unwise), nonHostChars = ['%', '/', '?', ';', '#'].concat(autoEscape), hostEndingChars = ['/', '?', '#'], hostnameMaxLen = 255, hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/, hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/, unsafeProtocol = { 'javascript': true, 'javascript:': true }, hostlessProtocol = { 'javascript': true, 'javascript:': true }, slashedProtocol = { 'http': true, 'https': true, 'ftp': true, 'gopher': true, 'file': true, 'http:': true, 'https:': true, 'ftp:': true, 'gopher:': true, 'file:': true }, querystring = __webpack_require__(322); function urlParse(url, parseQueryString, slashesDenoteHost) { if (url && util.isObject(url) && url instanceof Url) return url; var u = new Url; u.parse(url, parseQueryString, slashesDenoteHost); return u; }
        Url.prototype.parse = function (url, parseQueryString, slashesDenoteHost) {
            if (!util.isString(url)) { throw new TypeError("Parameter 'url' must be a string, not " + typeof url); }
            var queryIndex = url.indexOf('?'), splitter = (queryIndex !== -1 && queryIndex < url.indexOf('#')) ? '?' : '#', uSplit = url.split(splitter), slashRegex = /\\/g; uSplit[0] = uSplit[0].replace(slashRegex, '/'); url = uSplit.join(splitter); var rest = url; rest = rest.trim(); if (!slashesDenoteHost && url.split('#').length === 1) {
                var simplePath = simplePathPattern.exec(rest); if (simplePath) {
                    this.path = rest; this.href = rest; this.pathname = simplePath[1]; if (simplePath[2]) { this.search = simplePath[2]; if (parseQueryString) { this.query = querystring.parse(this.search.substr(1)); } else { this.query = this.search.substr(1); } } else if (parseQueryString) { this.search = ''; this.query = {}; }
                    return this;
                }
            }
            var proto = protocolPattern.exec(rest); if (proto) { proto = proto[0]; var lowerProto = proto.toLowerCase(); this.protocol = lowerProto; rest = rest.substr(proto.length); }
            if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) { var slashes = rest.substr(0, 2) === '//'; if (slashes && !(proto && hostlessProtocol[proto])) { rest = rest.substr(2); this.slashes = true; } }
            if (!hostlessProtocol[proto] && (slashes || (proto && !slashedProtocol[proto]))) {
                var hostEnd = -1; for (var i = 0; i < hostEndingChars.length; i++) {
                    var hec = rest.indexOf(hostEndingChars[i]); if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
                        hostEnd = hec;
                }
                var auth, atSign; if (hostEnd === -1) { atSign = rest.lastIndexOf('@'); } else { atSign = rest.lastIndexOf('@', hostEnd); }
                if (atSign !== -1) { auth = rest.slice(0, atSign); rest = rest.slice(atSign + 1); this.auth = decodeURIComponent(auth); }
                hostEnd = -1; for (var i = 0; i < nonHostChars.length; i++) {
                    var hec = rest.indexOf(nonHostChars[i]); if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
                        hostEnd = hec;
                }
                if (hostEnd === -1)
                    hostEnd = rest.length; this.host = rest.slice(0, hostEnd); rest = rest.slice(hostEnd); this.parseHost(); this.hostname = this.hostname || ''; var ipv6Hostname = this.hostname[0] === '[' && this.hostname[this.hostname.length - 1] === ']'; if (!ipv6Hostname) {
                        var hostparts = this.hostname.split(/\./); for (var i = 0, l = hostparts.length; i < l; i++) {
                            var part = hostparts[i]; if (!part) continue; if (!part.match(hostnamePartPattern)) {
                                var newpart = ''; for (var j = 0, k = part.length; j < k; j++) { if (part.charCodeAt(j) > 127) { newpart += 'x'; } else { newpart += part[j]; } }
                                if (!newpart.match(hostnamePartPattern)) {
                                    var validParts = hostparts.slice(0, i); var notHost = hostparts.slice(i + 1); var bit = part.match(hostnamePartStart); if (bit) { validParts.push(bit[1]); notHost.unshift(bit[2]); }
                                    if (notHost.length) { rest = '/' + notHost.join('.') + rest; }
                                    this.hostname = validParts.join('.'); break;
                                }
                            }
                        }
                    }
                if (this.hostname.length > hostnameMaxLen) { this.hostname = ''; } else { this.hostname = this.hostname.toLowerCase(); }
                if (!ipv6Hostname) { this.hostname = punycode.toASCII(this.hostname); }
                var p = this.port ? ':' + this.port : ''; var h = this.hostname || ''; this.host = h + p; this.href += this.host; if (ipv6Hostname) { this.hostname = this.hostname.substr(1, this.hostname.length - 2); if (rest[0] !== '/') { rest = '/' + rest; } }
            }
            if (!unsafeProtocol[lowerProto]) {
                for (var i = 0, l = autoEscape.length; i < l; i++) {
                    var ae = autoEscape[i]; if (rest.indexOf(ae) === -1)
                        continue; var esc = encodeURIComponent(ae); if (esc === ae) { esc = escape(ae); }
                    rest = rest.split(ae).join(esc);
                }
            }
            var hash = rest.indexOf('#'); if (hash !== -1) { this.hash = rest.substr(hash); rest = rest.slice(0, hash); }
            var qm = rest.indexOf('?'); if (qm !== -1) {
                this.search = rest.substr(qm); this.query = rest.substr(qm + 1); if (parseQueryString) { this.query = querystring.parse(this.query); }
                rest = rest.slice(0, qm);
            } else if (parseQueryString) { this.search = ''; this.query = {}; }
            if (rest) this.pathname = rest; if (slashedProtocol[lowerProto] && this.hostname && !this.pathname) { this.pathname = '/'; }
            if (this.pathname || this.search) { var p = this.pathname || ''; var s = this.search || ''; this.path = p + s; }
            this.href = this.format(); return this;
        }; function urlFormat(obj) { if (util.isString(obj)) obj = urlParse(obj); if (!(obj instanceof Url)) return Url.prototype.format.call(obj); return obj.format(); }
        Url.prototype.format = function () {
            var auth = this.auth || ''; if (auth) { auth = encodeURIComponent(auth); auth = auth.replace(/%3A/i, ':'); auth += '@'; }
            var protocol = this.protocol || '', pathname = this.pathname || '', hash = this.hash || '', host = false, query = ''; if (this.host) { host = auth + this.host; } else if (this.hostname) { host = auth + (this.hostname.indexOf(':') === -1 ? this.hostname : '[' + this.hostname + ']'); if (this.port) { host += ':' + this.port; } }
            if (this.query && util.isObject(this.query) && Object.keys(this.query).length) { query = querystring.stringify(this.query); }
            var search = this.search || (query && ('?' + query)) || ''; if (protocol && protocol.substr(-1) !== ':') protocol += ':'; if (this.slashes || (!protocol || slashedProtocol[protocol]) && host !== false) { host = '//' + (host || ''); if (pathname && pathname.charAt(0) !== '/') pathname = '/' + pathname; } else if (!host) { host = ''; }
            if (hash && hash.charAt(0) !== '#') hash = '#' + hash; if (search && search.charAt(0) !== '?') search = '?' + search; pathname = pathname.replace(/[?#]/g, function (match) { return encodeURIComponent(match); }); search = search.replace('#', '%23'); return protocol + host + pathname + search + hash;
        }; function urlResolve(source, relative) { return urlParse(source, false, true).resolve(relative); }
        Url.prototype.resolve = function (relative) { return this.resolveObject(urlParse(relative, false, true)).format(); }; function urlResolveObject(source, relative) { if (!source) return relative; return urlParse(source, false, true).resolveObject(relative); }
        Url.prototype.resolveObject = function (relative) {
            if (util.isString(relative)) { var rel = new Url(); rel.parse(relative, false, true); relative = rel; }
            var result = new Url(); var tkeys = Object.keys(this); for (var tk = 0; tk < tkeys.length; tk++) { var tkey = tkeys[tk]; result[tkey] = this[tkey]; }
            result.hash = relative.hash; if (relative.href === '') { result.href = result.format(); return result; }
            if (relative.slashes && !relative.protocol) {
                var rkeys = Object.keys(relative); for (var rk = 0; rk < rkeys.length; rk++) {
                    var rkey = rkeys[rk]; if (rkey !== 'protocol')
                        result[rkey] = relative[rkey];
                }
                if (slashedProtocol[result.protocol] && result.hostname && !result.pathname) { result.path = result.pathname = '/'; }
                result.href = result.format(); return result;
            }
            if (relative.protocol && relative.protocol !== result.protocol) {
                if (!slashedProtocol[relative.protocol]) {
                    var keys = Object.keys(relative); for (var v = 0; v < keys.length; v++) { var k = keys[v]; result[k] = relative[k]; }
                    result.href = result.format(); return result;
                }
                result.protocol = relative.protocol; if (!relative.host && !hostlessProtocol[relative.protocol]) { var relPath = (relative.pathname || '').split('/'); while (relPath.length && !(relative.host = relPath.shift())); if (!relative.host) relative.host = ''; if (!relative.hostname) relative.hostname = ''; if (relPath[0] !== '') relPath.unshift(''); if (relPath.length < 2) relPath.unshift(''); result.pathname = relPath.join('/'); } else { result.pathname = relative.pathname; }
                result.search = relative.search; result.query = relative.query; result.host = relative.host || ''; result.auth = relative.auth; result.hostname = relative.hostname || relative.host; result.port = relative.port; if (result.pathname || result.search) { var p = result.pathname || ''; var s = result.search || ''; result.path = p + s; }
                result.slashes = result.slashes || relative.slashes; result.href = result.format(); return result;
            }
            var isSourceAbs = (result.pathname && result.pathname.charAt(0) === '/'), isRelAbs = (relative.host || relative.pathname && relative.pathname.charAt(0) === '/'), mustEndAbs = (isRelAbs || isSourceAbs || (result.host && relative.pathname)), removeAllDots = mustEndAbs, srcPath = result.pathname && result.pathname.split('/') || [], relPath = relative.pathname && relative.pathname.split('/') || [], psychotic = result.protocol && !slashedProtocol[result.protocol]; if (psychotic) {
                result.hostname = ''; result.port = null; if (result.host) { if (srcPath[0] === '') srcPath[0] = result.host; else srcPath.unshift(result.host); }
                result.host = ''; if (relative.protocol) {
                    relative.hostname = null; relative.port = null; if (relative.host) { if (relPath[0] === '') relPath[0] = relative.host; else relPath.unshift(relative.host); }
                    relative.host = null;
                }
                mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '');
            }
            if (isRelAbs) { result.host = (relative.host || relative.host === '') ? relative.host : result.host; result.hostname = (relative.hostname || relative.hostname === '') ? relative.hostname : result.hostname; result.search = relative.search; result.query = relative.query; srcPath = relPath; } else if (relPath.length) { if (!srcPath) srcPath = []; srcPath.pop(); srcPath = srcPath.concat(relPath); result.search = relative.search; result.query = relative.query; } else if (!util.isNullOrUndefined(relative.search)) {
                if (psychotic) { result.hostname = result.host = srcPath.shift(); var authInHost = result.host && result.host.indexOf('@') > 0 ? result.host.split('@') : false; if (authInHost) { result.auth = authInHost.shift(); result.host = result.hostname = authInHost.shift(); } }
                result.search = relative.search; result.query = relative.query; if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
                    result.path = (result.pathname ? result.pathname : '') +
                        (result.search ? result.search : '');
                }
                result.href = result.format(); return result;
            }
            if (!srcPath.length) {
                result.pathname = null; if (result.search) { result.path = '/' + result.search; } else { result.path = null; }
                result.href = result.format(); return result;
            }
            var last = srcPath.slice(-1)[0]; var hasTrailingSlash = ((result.host || relative.host || srcPath.length > 1) && (last === '.' || last === '..') || last === ''); var up = 0; for (var i = srcPath.length; i >= 0; i--) { last = srcPath[i]; if (last === '.') { srcPath.splice(i, 1); } else if (last === '..') { srcPath.splice(i, 1); up++; } else if (up) { srcPath.splice(i, 1); up--; } }
            if (!mustEndAbs && !removeAllDots) { for (; up--; up) { srcPath.unshift('..'); } }
            if (mustEndAbs && srcPath[0] !== '' && (!srcPath[0] || srcPath[0].charAt(0) !== '/')) { srcPath.unshift(''); }
            if (hasTrailingSlash && (srcPath.join('/').substr(-1) !== '/')) { srcPath.push(''); }
            var isAbsolute = srcPath[0] === '' || (srcPath[0] && srcPath[0].charAt(0) === '/'); if (psychotic) { result.hostname = result.host = isAbsolute ? '' : srcPath.length ? srcPath.shift() : ''; var authInHost = result.host && result.host.indexOf('@') > 0 ? result.host.split('@') : false; if (authInHost) { result.auth = authInHost.shift(); result.host = result.hostname = authInHost.shift(); } }
            mustEndAbs = mustEndAbs || (result.host && srcPath.length); if (mustEndAbs && !isAbsolute) { srcPath.unshift(''); }
            if (!srcPath.length) { result.pathname = null; result.path = null; } else { result.pathname = srcPath.join('/'); }
            if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
                result.path = (result.pathname ? result.pathname : '') +
                    (result.search ? result.search : '');
            }
            result.auth = relative.auth || result.auth; result.slashes = result.slashes || relative.slashes; result.href = result.format(); return result;
        }; Url.prototype.parseHost = function () {
            var host = this.host; var port = portPattern.exec(host); if (port) {
                port = port[0]; if (port !== ':') { this.port = port.substr(1); }
                host = host.substr(0, host.length - port.length);
            }
            if (host) this.hostname = host;
        };
    }), (function (module, exports, __webpack_require__) {
        (function (module, global) {
            var __WEBPACK_AMD_DEFINE_RESULT__;/*!https://mths.be/punycode v1.4.1 by @mathias*/; (function (root) {
                var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports; var freeModule = typeof module == 'object' && module && !module.nodeType && module; var freeGlobal = typeof global == 'object' && global; if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal || freeGlobal.self === freeGlobal) { root = freeGlobal; }
                var punycode, maxInt = 2147483647, base = 36, tMin = 1, tMax = 26, skew = 38, damp = 700, initialBias = 72, initialN = 128, delimiter = '-', regexPunycode = /^xn--/, regexNonASCII = /[^\x20-\x7E]/, regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g, errors = { 'overflow': 'Overflow: input needs wider integers to process', 'not-basic': 'Illegal input >= 0x80 (not a basic code point)', 'invalid-input': 'Invalid input' }, baseMinusTMin = base - tMin, floor = Math.floor, stringFromCharCode = String.fromCharCode, key; function error(type) { throw new RangeError(errors[type]); }
                function map(array, fn) {
                    var length = array.length; var result = []; while (length--) { result[length] = fn(array[length]); }
                    return result;
                }
                function mapDomain(string, fn) {
                    var parts = string.split('@'); var result = ''; if (parts.length > 1) { result = parts[0] + '@'; string = parts[1]; }
                    string = string.replace(regexSeparators, '\x2E'); var labels = string.split('.'); var encoded = map(labels, fn).join('.'); return result + encoded;
                }
                function ucs2decode(string) {
                    var output = [], counter = 0, length = string.length, value, extra; while (counter < length) { value = string.charCodeAt(counter++); if (value >= 0xD800 && value <= 0xDBFF && counter < length) { extra = string.charCodeAt(counter++); if ((extra & 0xFC00) == 0xDC00) { output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000); } else { output.push(value); counter--; } } else { output.push(value); } }
                    return output;
                }
                function ucs2encode(array) {
                    return map(array, function (value) {
                        var output = ''; if (value > 0xFFFF) { value -= 0x10000; output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800); value = 0xDC00 | value & 0x3FF; }
                        output += stringFromCharCode(value); return output;
                    }).join('');
                }
                function basicToDigit(codePoint) {
                    if (codePoint - 48 < 10) { return codePoint - 22; }
                    if (codePoint - 65 < 26) { return codePoint - 65; }
                    if (codePoint - 97 < 26) { return codePoint - 97; }
                    return base;
                }
                function digitToBasic(digit, flag) { return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5); }
                function adapt(delta, numPoints, firstTime) {
                    var k = 0; delta = firstTime ? floor(delta / damp) : delta >> 1; delta += floor(delta / numPoints); for (; delta > baseMinusTMin * tMax >> 1; k += base) { delta = floor(delta / baseMinusTMin); }
                    return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
                }
                function decode(input) {
                    var output = [], inputLength = input.length, out, i = 0, n = initialN, bias = initialBias, basic, j, index, oldi, w, k, digit, t, baseMinusT; basic = input.lastIndexOf(delimiter); if (basic < 0) { basic = 0; }
                    for (j = 0; j < basic; ++j) {
                        if (input.charCodeAt(j) >= 0x80) { error('not-basic'); }
                        output.push(input.charCodeAt(j));
                    }
                    for (index = basic > 0 ? basic + 1 : 0; index < inputLength;) {
                        for (oldi = i, w = 1, k = base; ; k += base) {
                            if (index >= inputLength) { error('invalid-input'); }
                            digit = basicToDigit(input.charCodeAt(index++)); if (digit >= base || digit > floor((maxInt - i) / w)) { error('overflow'); }
                            i += digit * w; t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias); if (digit < t) { break; }
                            baseMinusT = base - t; if (w > floor(maxInt / baseMinusT)) { error('overflow'); }
                            w *= baseMinusT;
                        }
                        out = output.length + 1; bias = adapt(i - oldi, out, oldi == 0); if (floor(i / out) > maxInt - n) { error('overflow'); }
                        n += floor(i / out); i %= out; output.splice(i++, 0, n);
                    }
                    return ucs2encode(output);
                }
                function encode(input) {
                    var n, delta, handledCPCount, basicLength, bias, j, m, q, k, t, currentValue, output = [], inputLength, handledCPCountPlusOne, baseMinusT, qMinusT; input = ucs2decode(input); inputLength = input.length; n = initialN; delta = 0; bias = initialBias; for (j = 0; j < inputLength; ++j) { currentValue = input[j]; if (currentValue < 0x80) { output.push(stringFromCharCode(currentValue)); } }
                    handledCPCount = basicLength = output.length; if (basicLength) { output.push(delimiter); }
                    while (handledCPCount < inputLength) {
                        for (m = maxInt, j = 0; j < inputLength; ++j) { currentValue = input[j]; if (currentValue >= n && currentValue < m) { m = currentValue; } }
                        handledCPCountPlusOne = handledCPCount + 1; if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) { error('overflow'); }
                        delta += (m - n) * handledCPCountPlusOne; n = m; for (j = 0; j < inputLength; ++j) {
                            currentValue = input[j]; if (currentValue < n && ++delta > maxInt) { error('overflow'); }
                            if (currentValue == n) {
                                for (q = delta, k = base; ; k += base) {
                                    t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias); if (q < t) { break; }
                                    qMinusT = q - t; baseMinusT = base - t; output.push(stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))); q = floor(qMinusT / baseMinusT);
                                }
                                output.push(stringFromCharCode(digitToBasic(q, 0))); bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength); delta = 0; ++handledCPCount;
                            }
                        }
                        ++delta; ++n;
                    }
                    return output.join('');
                }
                function toUnicode(input) { return mapDomain(input, function (string) { return regexPunycode.test(string) ? decode(string.slice(4).toLowerCase()) : string; }); }
                function toASCII(input) { return mapDomain(input, function (string) { return regexNonASCII.test(string) ? 'xn--' + encode(string) : string; }); }
                punycode = { 'version': '1.4.1', 'ucs2': { 'decode': ucs2decode, 'encode': ucs2encode }, 'decode': decode, 'encode': encode, 'toASCII': toASCII, 'toUnicode': toUnicode }; if (true) { !(__WEBPACK_AMD_DEFINE_RESULT__ = (function () { return punycode; }).call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)); } else if (freeExports && freeModule) { if (module.exports == freeExports) { freeModule.exports = punycode; } else { for (key in punycode) { punycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]); } } } else { root.punycode = punycode; }
            }(this));
        }.call(exports, __webpack_require__(45)(module), __webpack_require__(17)))
    }), (function (module, exports, __webpack_require__) { "use strict"; module.exports = { isString: function (arg) { return typeof (arg) === 'string'; }, isObject: function (arg) { return typeof (arg) === 'object' && arg !== null; }, isNull: function (arg) { return arg === null; }, isNullOrUndefined: function (arg) { return arg == null; } }; }), (function (module, exports, __webpack_require__) { "use strict"; exports.decode = exports.parse = __webpack_require__(323); exports.encode = exports.stringify = __webpack_require__(324); }), (function (module, exports, __webpack_require__) {
        "use strict"; function hasOwnProperty(obj, prop) { return Object.prototype.hasOwnProperty.call(obj, prop); }
        module.exports = function (qs, sep, eq, options) {
            sep = sep || '&'; eq = eq || '='; var obj = {}; if (typeof qs !== 'string' || qs.length === 0) { return obj; }
            var regexp = /\+/g; qs = qs.split(sep); var maxKeys = 1000; if (options && typeof options.maxKeys === 'number') { maxKeys = options.maxKeys; }
            var len = qs.length; if (maxKeys > 0 && len > maxKeys) { len = maxKeys; }
            for (var i = 0; i < len; ++i) {
                var x = qs[i].replace(regexp, '%20'), idx = x.indexOf(eq), kstr, vstr, k, v; if (idx >= 0) { kstr = x.substr(0, idx); vstr = x.substr(idx + 1); } else { kstr = x; vstr = ''; }
                k = decodeURIComponent(kstr); v = decodeURIComponent(vstr); if (!hasOwnProperty(obj, k)) { obj[k] = v; } else if (isArray(obj[k])) { obj[k].push(v); } else { obj[k] = [obj[k], v]; }
            }
            return obj;
        }; var isArray = Array.isArray || function (xs) { return Object.prototype.toString.call(xs) === '[object Array]'; };
    }), (function (module, exports, __webpack_require__) {
        "use strict"; var stringifyPrimitive = function (v) { switch (typeof v) { case 'string': return v; case 'boolean': return v ? 'true' : 'false'; case 'number': return isFinite(v) ? v : ''; default: return ''; } }; module.exports = function (obj, sep, eq, name) {
            sep = sep || '&'; eq = eq || '='; if (obj === null) { obj = undefined; }
            if (typeof obj === 'object') { return map(objectKeys(obj), function (k) { var ks = encodeURIComponent(stringifyPrimitive(k)) + eq; if (isArray(obj[k])) { return map(obj[k], function (v) { return ks + encodeURIComponent(stringifyPrimitive(v)); }).join(sep); } else { return ks + encodeURIComponent(stringifyPrimitive(obj[k])); } }).join(sep); }
            if (!name) return ''; return encodeURIComponent(stringifyPrimitive(name)) + eq +
                encodeURIComponent(stringifyPrimitive(obj));
        }; var isArray = Array.isArray || function (xs) { return Object.prototype.toString.call(xs) === '[object Array]'; }; function map(xs, f) {
            if (xs.map) return xs.map(f); var res = []; for (var i = 0; i < xs.length; i++) { res.push(f(xs[i], i)); }
            return res;
        }
        var objectKeys = Object.keys || function (obj) {
            var res = []; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) res.push(key); }
            return res;
        };
    }), (function (module, exports, __webpack_require__) {
        "use strict"; module.exports = function (text) {
            var linkFollow = "Dofollow"; if (text.match(/rel=([\'\"])nofollow\1/ig) !== null) { linkFollow = "Nofollow"; }
            return linkFollow;
        };
    }), (function (module, exports, __webpack_require__) { "use strict"; var getLinks = __webpack_require__(164); module.exports = function (paper) { var anchors = getLinks(paper); return anchors.length; }; }), (function (module, exports, __webpack_require__) {
        "use strict"; module.exports = function (paper) {
            var urlLength = paper.getUrl().length; var keywordLength = paper.getKeyword().length; var maxUrlLength = 40; var maxSlugLength = 20; if (urlLength > maxUrlLength && urlLength > keywordLength + maxSlugLength) { return true; }
            return false;
        };
    }), (function (module, exports, __webpack_require__) { "use strict"; var wordMatch = __webpack_require__(28); var escapeRegExp = __webpack_require__(12); module.exports = function (paper) { var title = paper.getTitle(); var keyword = escapeRegExp(paper.getKeyword()); var locale = paper.getLocale(); var result = { matches: 0, position: -1 }; result.matches = wordMatch(title, keyword, locale); result.position = title.toLocaleLowerCase().indexOf(keyword); return result; }; }), (function (module, exports, __webpack_require__) {
        "use strict"; var stripSomeTags = __webpack_require__(165); var subheadingMatch = __webpack_require__(330); var getSubheadingContents = __webpack_require__(333).getSubheadingContents; var escapeRegExp = __webpack_require__(12); module.exports = function (paper) {
            var text = paper.getText(); var keyword = escapeRegExp(paper.getKeyword()); var locale = paper.getLocale(); var result = { count: 0 }; text = stripSomeTags(text); var matches = getSubheadingContents(text); if (0 !== matches.length) { result.count = matches.length; result.matches = subheadingMatch(matches, keyword, locale); }
            return result;
        };
    }), (function (module, exports, __webpack_require__) {
        "use strict"; var replaceString = __webpack_require__(331); var removalWords = __webpack_require__(332)(); var matchTextWithTransliteration = __webpack_require__(101); module.exports = function (matches, keyword, locale) {
            var foundInHeader; if (matches === null) { foundInHeader = -1; } else { foundInHeader = 0; for (var i = 0; i < matches.length; i++) { var formattedHeaders = replaceString(matches[i], removalWords); if (matchTextWithTransliteration(formattedHeaders, keyword, locale).length > 0 || matchTextWithTransliteration(matches[i], keyword, locale).length > 0) { foundInHeader++; } } }
            return foundInHeader;
        };
    }), (function (module, exports, __webpack_require__) { "use strict"; module.exports = function (text, stringToReplace, replacement) { text = text.replace(stringToReplace, replacement); return text; }; }), (function (module, exports, __webpack_require__) { "use strict"; module.exports = function () { return [" a", " in", " an", " on", " for", " the", " and"]; }; }), (function (module, exports, __webpack_require__) {
        "use strict"; var map = __webpack_require__(2); function getSubheadings(text) {
            var subheadings = []; var regex = /<h([1-6])(?:[^>]+)?>(.*?)<\/h\1>/ig; var match; while ((match = regex.exec(text)) !== null) { subheadings.push(match); }
            return subheadings;
        }
        function getSubheadingContents(text) { var subheadings = getSubheadings(text); subheadings = map(subheadings, function (subheading) { return subheading[0]; }); return subheadings; }
        module.exports = { getSubheadings: getSubheadings, getSubheadingContents: getSubheadingContents };
    }), (function (module, exports, __webpack_require__) {
        "use strict"; var countWords = __webpack_require__(23); var matchWords = __webpack_require__(28); var escapeRegExp = __webpack_require__(12); module.exports = function (paper) {
            var keyword = escapeRegExp(paper.getKeyword()); var text = paper.getText(); var locale = paper.getLocale(); var wordCount = countWords(text); if (wordCount === 0) { return 0; }
            var keywordCount = matchWords(text, keyword, locale); return keywordCount / wordCount * 100;
        };
    }), (function (module, exports, __webpack_require__) { "use strict"; var stopWordsInText = __webpack_require__(166); var escapeRegExp = __webpack_require__(12); module.exports = function (paper) { var keyword = escapeRegExp(paper.getKeyword()); return stopWordsInText(keyword); }; }), (function (module, exports, __webpack_require__) { "use strict"; module.exports = function () { return ["a", "about", "above", "after", "again", "against", "all", "am", "an", "and", "any", "are", "as", "at", "be", "because", "been", "before", "being", "below", "between", "both", "but", "by", "could", "did", "do", "does", "doing", "down", "during", "each", "few", "for", "from", "further", "had", "has", "have", "having", "he", "he'd", "he'll", "he's", "her", "here", "here's", "hers", "herself", "him", "himself", "his", "how", "how's", "i", "i'd", "i'll", "i'm", "i've", "if", "in", "into", "is", "it", "it's", "its", "itself", "let's", "me", "more", "most", "my", "myself", "nor", "of", "on", "once", "only", "or", "other", "ought", "our", "ours", "ourselves", "out", "over", "own", "same", "she", "she'd", "she'll", "she's", "should", "so", "some", "such", "than", "that", "that's", "the", "their", "theirs", "them", "themselves", "then", "there", "there's", "these", "they", "they'd", "they'll", "they're", "they've", "this", "those", "through", "to", "too", "under", "until", "up", "very", "was", "we", "we'd", "we'll", "we're", "we've", "were", "what", "what's", "when", "when's", "where", "where's", "which", "while", "who", "who's", "whom", "why", "why's", "with", "would", "you", "you'd", "you'll", "you're", "you've", "your", "yours", "yourself", "yourselves"]; }; }), (function (module, exports, __webpack_require__) { "use strict"; module.exports = function () { return [{ base: "a", letters: /[\u0061\u24D0\uFF41\u1E9A\u00E0\u00E1\u00E2\u1EA7\u1EA5\u1EAB\u1EA9\u00E3\u0101\u0103\u1EB1\u1EAF\u1EB5\u1EB3\u0227\u01E1\u00E4\u01DF\u1EA3\u00E5\u01FB\u01CE\u0201\u0203\u1EA1\u1EAD\u1EB7\u1E01\u0105\u2C65\u0250]/g }, { base: "aa", letters: /[\uA733]/g }, { base: "ae", letters: /[\u00E6\u01FD\u01E3]/g }, { base: "ao", letters: /[\uA735]/g }, { base: "au", letters: /[\uA737]/g }, { base: "av", letters: /[\uA739\uA73B]/g }, { base: "ay", letters: /[\uA73D]/g }, { base: "b", letters: /[\u0062\u24D1\uFF42\u1E03\u1E05\u1E07\u0180\u0183\u0253]/g }, { base: "c", letters: /[\u0063\u24D2\uFF43\u0107\u0109\u010B\u010D\u00E7\u1E09\u0188\u023C\uA73F\u2184]/g }, { base: "d", letters: /[\u0064\u24D3\uFF44\u1E0B\u010F\u1E0D\u1E11\u1E13\u1E0F\u0111\u018C\u0256\u0257\uA77A]/g }, { base: "dz", letters: /[\u01F3\u01C6]/g }, { base: "e", letters: /[\u0065\u24D4\uFF45\u00E8\u00E9\u00EA\u1EC1\u1EBF\u1EC5\u1EC3\u1EBD\u0113\u1E15\u1E17\u0115\u0117\u00EB\u1EBB\u011B\u0205\u0207\u1EB9\u1EC7\u0229\u1E1D\u0119\u1E19\u1E1B\u0247\u025B\u01DD]/g }, { base: "f", letters: /[\u0066\u24D5\uFF46\u1E1F\u0192\uA77C]/g }, { base: "g", letters: /[\u0067\u24D6\uFF47\u01F5\u011D\u1E21\u011F\u0121\u01E7\u0123\u01E5\u0260\uA7A1\u1D79\uA77F]/g }, { base: "h", letters: /[\u0068\u24D7\uFF48\u0125\u1E23\u1E27\u021F\u1E25\u1E29\u1E2B\u1E96\u0127\u2C68\u2C76\u0265]/g }, { base: "hv", letters: /[\u0195]/g }, { base: "i", letters: /[\u0069\u24D8\uFF49\u00EC\u00ED\u00EE\u0129\u012B\u012D\u00EF\u1E2F\u1EC9\u01D0\u0209\u020B\u1ECB\u012F\u1E2D\u0268\u0131]/g }, { base: "j", letters: /[\u006A\u24D9\uFF4A\u0135\u01F0\u0249]/g }, { base: "k", letters: /[\u006B\u24DA\uFF4B\u1E31\u01E9\u1E33\u0137\u1E35\u0199\u2C6A\uA741\uA743\uA745\uA7A3]/g }, { base: "l", letters: /[\u006C\u24DB\uFF4C\u0140\u013A\u013E\u1E37\u1E39\u013C\u1E3D\u1E3B\u017F\u0142\u019A\u026B\u2C61\uA749\uA781\uA747]/g }, { base: "lj", letters: /[\u01C9]/g }, { base: "m", letters: /[\u006D\u24DC\uFF4D\u1E3F\u1E41\u1E43\u0271\u026F]/g }, { base: "n", letters: /[\u006E\u24DD\uFF4E\u01F9\u0144\u00F1\u1E45\u0148\u1E47\u0146\u1E4B\u1E49\u019E\u0272\u0149\uA791\uA7A5]/g }, { base: "nj", letters: /[\u01CC]/g }, { base: "o", letters: /[\u006F\u24DE\uFF4F\u00F2\u00F3\u00F4\u1ED3\u1ED1\u1ED7\u1ED5\u00F5\u1E4D\u022D\u1E4F\u014D\u1E51\u1E53\u014F\u022F\u0231\u00F6\u022B\u1ECF\u0151\u01D2\u020D\u020F\u01A1\u1EDD\u1EDB\u1EE1\u1EDF\u1EE3\u1ECD\u1ED9\u01EB\u01ED\u00F8\u01FF\u0254\uA74B\uA74D\u0275]/g }, { base: "oi", letters: /[\u01A3]/g }, { base: "ou", letters: /[\u0223]/g }, { base: "oo", letters: /[\uA74F]/g }, { base: "p", letters: /[\u0070\u24DF\uFF50\u1E55\u1E57\u01A5\u1D7D\uA751\uA753\uA755]/g }, { base: "q", letters: /[\u0071\u24E0\uFF51\u024B\uA757\uA759]/g }, { base: "r", letters: /[\u0072\u24E1\uFF52\u0155\u1E59\u0159\u0211\u0213\u1E5B\u1E5D\u0157\u1E5F\u024D\u027D\uA75B\uA7A7\uA783]/g }, { base: "s", letters: /[\u0073\u24E2\uFF53\u00DF\u015B\u1E65\u015D\u1E61\u0161\u1E67\u1E63\u1E69\u0219\u015F\u023F\uA7A9\uA785\u1E9B]/g }, { base: "t", letters: /[\u0074\u24E3\uFF54\u1E6B\u1E97\u0165\u1E6D\u021B\u0163\u1E71\u1E6F\u0167\u01AD\u0288\u2C66\uA787]/g }, { base: "tz", letters: /[\uA729]/g }, { base: "u", letters: /[\u0075\u24E4\uFF55\u00F9\u00FA\u00FB\u0169\u1E79\u016B\u1E7B\u016D\u00FC\u01DC\u01D8\u01D6\u01DA\u1EE7\u016F\u0171\u01D4\u0215\u0217\u01B0\u1EEB\u1EE9\u1EEF\u1EED\u1EF1\u1EE5\u1E73\u0173\u1E77\u1E75\u0289]/g }, { base: "v", letters: /[\u0076\u24E5\uFF56\u1E7D\u1E7F\u028B\uA75F\u028C]/g }, { base: "vy", letters: /[\uA761]/g }, { base: "w", letters: /[\u0077\u24E6\uFF57\u1E81\u1E83\u0175\u1E87\u1E85\u1E98\u1E89\u2C73]/g }, { base: "x", letters: /[\u0078\u24E7\uFF58\u1E8B\u1E8D]/g }, { base: "y", letters: /[\u0079\u24E8\uFF59\u1EF3\u00FD\u0177\u1EF9\u0233\u1E8F\u00FF\u1EF7\u1E99\u1EF5\u01B4\u024F\u1EFF]/g }, { base: "z", letters: /[\u007A\u24E9\uFF5A\u017A\u1E91\u017C\u017E\u1E93\u1E95\u01B6\u0225\u0240\u2C6C\uA763]/g }]; }; }), (function (module, exports, __webpack_require__) { "use strict"; var stopWordsInText = __webpack_require__(166); module.exports = function (paper) { return stopWordsInText(paper.getUrl().replace(/[-_]/g, " ")); }; }), (function (module, exports, __webpack_require__) {
        "use strict"; var stripNumbers = __webpack_require__(340); var countSentences = __webpack_require__(341); var countWords = __webpack_require__(23); var countSyllables = __webpack_require__(170); var formatNumber = __webpack_require__(52); var getLanguage = __webpack_require__(20); var getAverage = function getAverage(total, amount) { return total / amount; }; module.exports = function (paper) {
            var score = void 0; var text = paper.getText(); var locale = paper.getLocale(); var language = getLanguage(locale); if (text === "") { return 0; }
            text = stripNumbers(text); var numberOfSentences = countSentences(text); var numberOfWords = countWords(text); if (numberOfSentences === 0 || numberOfWords === 0) { return 0; }
            var numberOfSyllables = countSyllables(text, locale); var averageWordsPerSentence = getAverage(numberOfWords, numberOfSentences); var syllablesPer100Words = numberOfSyllables * (100 / numberOfWords); switch (language) { case "nl": score = 206.84 - 0.77 * syllablesPer100Words - 0.93 * averageWordsPerSentence; break; case "de": score = 180 - averageWordsPerSentence - 58.5 * numberOfSyllables / numberOfWords; break; case "it": score = 217 - 1.3 * averageWordsPerSentence - 0.6 * syllablesPer100Words; break; case "en": default: score = 206.835 - 1.015 * averageWordsPerSentence - 84.6 * (numberOfSyllables / numberOfWords); break; }
            return formatNumber(score);
        };
    }), (function (module, exports, __webpack_require__) {
        "use strict"; var stripSpaces = __webpack_require__(8); module.exports = function (text) {
            text = text.replace(/\b[0-9]+\b/g, ""); text = stripSpaces(text); if (text === ".") { text = ""; }
            return text;
        };
    }), (function (module, exports, __webpack_require__) {
        "use strict"; var getSentences = __webpack_require__(22); module.exports = function (text) {
            var sentences = getSentences(text); var sentenceCount = 0; for (var i = 0; i < sentences.length; i++) { sentenceCount++; }
            return sentenceCount;
        };
    }), (function (module, exports, __webpack_require__) {
        "use strict"; var getLanguage = __webpack_require__(20); var isUndefined = __webpack_require__(3); var de = __webpack_require__(343); var en = __webpack_require__(344); var nl = __webpack_require__(345); var it = __webpack_require__(346); var languages = { de: de, nl: nl, en: en, it: it }; module.exports = function () {
            var locale = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "en_US"; var language = getLanguage(locale); if (languages.hasOwnProperty(language)) { return languages[language]; }
            return languages["en"];
        };
    }), (function (module, exports) { module.exports = { "vowels": "aeiouyäöüáéâàèîêâûôœ", "deviations": { "vowels": [{ "fragments": ["ouil", "deaux", "deau$", "oard", "äthiop", "euil", "veau", "eau$", "ueue", "lienisch", "ance$", "ence$", "time$", "once$", "ziat", "guette", "ête", "ôte$", "[hp]omme$", "[qdscn]ue$", "aire$", "ture$", "êpe$", "[^q]ui$", "tiche$", "vice$", "oile$", "zial", "cruis", "leas", "coa[ct]", "[^i]deal", "[fw]eat", "[lsx]ed$"], "countModifier": -1 }, { "fragments": ["aau", "a[äöüo]", "äue", "äeu", "aei", "aue", "aeu", "ael", "ai[aeo]", "saik", "aismus", "ä[aeoi]", "auä", "éa", "e[äaoö]", "ei[eo]", "ee[aeiou]", "eu[aäe]", "eum$", "eü", "o[aäöü]", "poet", "oo[eo]", "oie", "oei[^l]", "oeu[^f]", "öa", "[fgrz]ieu", "mieun", "tieur", "ieum", "i[aiuü]", "[^l]iä", "[^s]chien", "io[bcdfhjkmpqtuvwx]", "[bdhmprv]ion", "[lr]ior", "[^g]io[gs]", "[dr]ioz", "elioz", "zioni", "bio[lnorz]", "iö[^s]", "ie[ei]", "rier$", "öi[eg]", "[^r]öisch", "[^gqv]u[aeéioöuü]", "quie$", "quie[^s]", "uäu", "^us-", "^it-", "üe", "naiv", "aisch$", "aische$", "aische[nrs]$", "[lst]ien", "dien$", "gois", "[^g]rient", "[aeiou]y[aeiou]", "byi", "yä", "[a-z]y[ao]", "yau", "koor", "scient", "eriel", "[dg]oing"], "countModifier": 1 }, { "fragments": ["eauü", "ioi", "ioo", "ioa", "iii", "oai", "eueu"], "countModifier": 1 }], "words": { "full": [{ "word": "beach", "syllables": 1 }, { "word": "beat", "syllables": 1 }, { "word": "beau", "syllables": 1 }, { "word": "beaune", "syllables": 1 }, { "word": "belle", "syllables": 1 }, { "word": "bouche", "syllables": 1 }, { "word": "brake", "syllables": 1 }, { "word": "cache", "syllables": 1 }, { "word": "chaiselongue", "syllables": 2 }, { "word": "choke", "syllables": 1 }, { "word": "cordiale", "syllables": 3 }, { "word": "core", "syllables": 1 }, { "word": "dope", "syllables": 1 }, { "word": "eat", "syllables": 1 }, { "word": "eye", "syllables": 1 }, { "word": "fake", "syllables": 1 }, { "word": "fame", "syllables": 1 }, { "word": "fatigue", "syllables": 2 }, { "word": "femme", "syllables": 1 }, { "word": "force", "syllables": 1 }, { "word": "game", "syllables": 1 }, { "word": "games", "syllables": 1 }, { "word": "gate", "syllables": 1 }, { "word": "grande", "syllables": 1 }, { "word": "ice", "syllables": 1 }, { "word": "ion", "syllables": 2 }, { "word": "joke", "syllables": 1 }, { "word": "jupe", "syllables": 1 }, { "word": "maisch", "syllables": 1 }, { "word": "maische", "syllables": 2 }, { "word": "move", "syllables": 1 }, { "word": "native", "syllables": 2 }, { "word": "nice", "syllables": 1 }, { "word": "one", "syllables": 1 }, { "word": "pipe", "syllables": 1 }, { "word": "prime", "syllables": 1 }, { "word": "rate", "syllables": 1 }, { "word": "rhythm", "syllables": 2 }, { "word": "ride", "syllables": 1 }, { "word": "rides", "syllables": 1 }, { "word": "rien", "syllables": 2 }, { "word": "save", "syllables": 1 }, { "word": "science", "syllables": 2 }, { "word": "siècle", "syllables": 1 }, { "word": "site", "syllables": 1 }, { "word": "suite", "syllables": 1 }, { "word": "take", "syllables": 1 }, { "word": "taupe", "syllables": 1 }, { "word": "universe", "syllables": 3 }, { "word": "vogue", "syllables": 1 }, { "word": "wave", "syllables": 1 }, { "word": "zion", "syllables": 2 }], "fragments": { "global": [{ "word": "abreaktion", "syllables": 4 }, { "word": "adware", "syllables": 2 }, { "word": "affaire", "syllables": 3 }, { "word": "aiguière", "syllables": 2 }, { "word": "anisette", "syllables": 3 }, { "word": "appeal", "syllables": 2 }, { "word": "backstage", "syllables": 2 }, { "word": "bankrate", "syllables": 2 }, { "word": "baseball", "syllables": 2 }, { "word": "basejump", "syllables": 2 }, { "word": "beachcomber", "syllables": 3 }, { "word": "beachvolleyball", "syllables": 4 }, { "word": "beagle", "syllables": 2 }, { "word": "beamer", "syllables": 2 }, { "word": "beamer", "syllables": 2 }, { "word": "béarnaise", "syllables": 3 }, { "word": "beaufort", "syllables": 2 }, { "word": "beaujolais", "syllables": 3 }, { "word": "beauté", "syllables": 2 }, { "word": "beauty", "syllables": 2 }, { "word": "belgier", "syllables": 3 }, { "word": "bestien", "syllables": 2 }, { "word": "biskuit", "syllables": 2 }, { "word": "bleach", "syllables": 1 }, { "word": "blue", "syllables": 1 }, { "word": "board", "syllables": 1 }, { "word": "boat", "syllables": 1 }, { "word": "bodysuit", "syllables": 3 }, { "word": "bordelaise", "syllables": 3 }, { "word": "break", "syllables": 1 }, { "word": "build", "syllables": 1 }, { "word": "bureau", "syllables": 2 }, { "word": "business", "syllables": 2 }, { "word": "cabrio", "syllables": 3 }, { "word": "cabriolet", "syllables": 4 }, { "word": "cachesexe", "syllables": 2 }, { "word": "camaieu", "syllables": 3 }, { "word": "canyon", "syllables": 2 }, { "word": "case", "syllables": 1 }, { "word": "catsuit", "syllables": 2 }, { "word": "centime", "syllables": 3 }, { "word": "chaise", "syllables": 2 }, { "word": "champion", "syllables": 2 }, { "word": "championat", "syllables": 3 }, { "word": "chapiteau", "syllables": 3 }, { "word": "chateau", "syllables": 2 }, { "word": "château", "syllables": 2 }, { "word": "cheat", "syllables": 1 }, { "word": "cheese", "syllables": 1 }, { "word": "chihuahua", "syllables": 3 }, { "word": "choice", "syllables": 1 }, { "word": "circonflexe", "syllables": 3 }, { "word": "clean", "syllables": 1 }, { "word": "cloche", "syllables": 1 }, { "word": "close", "syllables": 1 }, { "word": "clothes", "syllables": 1 }, { "word": "commerce", "syllables": 2 }, { "word": "crime", "syllables": 1 }, { "word": "crossrate", "syllables": 2 }, { "word": "cuisine", "syllables": 2 }, { "word": "culotte", "syllables": 2 }, { "word": "death", "syllables": 1 }, { "word": "defense", "syllables": 2 }, { "word": "détente", "syllables": 2 }, { "word": "dread", "syllables": 1 }, { "word": "dream", "syllables": 1 }, { "word": "dresscode", "syllables": 2 }, { "word": "dungeon", "syllables": 2 }, { "word": "easy", "syllables": 2 }, { "word": "engagement", "syllables": 3 }, { "word": "entente", "syllables": 2 }, { "word": "eye-catcher", "syllables": 3 }, { "word": "eyecatcher", "syllables": 3 }, { "word": "eyeliner", "syllables": 3 }, { "word": "eyeword", "syllables": 2 }, { "word": "fashion", "syllables": 2 }, { "word": "feature", "syllables": 2 }, { "word": "ferien", "syllables": 3 }, { "word": "fineliner", "syllables": 3 }, { "word": "fisheye", "syllables": 2 }, { "word": "flake", "syllables": 1 }, { "word": "flambeau", "syllables": 2 }, { "word": "flatrate", "syllables": 2 }, { "word": "fleece", "syllables": 1 }, { "word": "fraîche", "syllables": 1 }, { "word": "freak", "syllables": 1 }, { "word": "frites", "syllables": 1 }, { "word": "future", "syllables": 2 }, { "word": "gaelic", "syllables": 2 }, { "word": "game-show", "syllables": 2 }, { "word": "gameboy", "syllables": 2 }, { "word": "gamepad", "syllables": 2 }, { "word": "gameplay", "syllables": 2 }, { "word": "gameport", "syllables": 2 }, { "word": "gameshow", "syllables": 2 }, { "word": "garigue", "syllables": 2 }, { "word": "garrigue", "syllables": 2 }, { "word": "gatefold", "syllables": 2 }, { "word": "gateway", "syllables": 2 }, { "word": "geflashed", "syllables": 2 }, { "word": "georgier", "syllables": 4 }, { "word": "goal", "syllables": 1 }, { "word": "grapefruit", "syllables": 2 }, { "word": "great", "syllables": 1 }, { "word": "groupware", "syllables": 2 }, { "word": "gueule", "syllables": 1 }, { "word": "guide", "syllables": 1 }, { "word": "guilloche", "syllables": 2 }, { "word": "gynäzeen", "syllables": 4 }, { "word": "gynözeen", "syllables": 4 }, { "word": "haircare", "syllables": 2 }, { "word": "hardcore", "syllables": 2 }, { "word": "hardware", "syllables": 2 }, { "word": "head", "syllables": 1 }, { "word": "hearing", "syllables": 2 }, { "word": "heart", "syllables": 1 }, { "word": "heavy", "syllables": 2 }, { "word": "hedge", "syllables": 1 }, { "word": "heroin", "syllables": 3 }, { "word": "inclusive", "syllables": 3 }, { "word": "initiative", "syllables": 4 }, { "word": "inside", "syllables": 2 }, { "word": "jaguar", "syllables": 3 }, { "word": "jalousette", "syllables": 3 }, { "word": "jeans", "syllables": 1 }, { "word": "jeunesse", "syllables": 2 }, { "word": "juice", "syllables": 1 }, { "word": "jukebox", "syllables": 2 }, { "word": "jumpsuit", "syllables": 2 }, { "word": "kanarien", "syllables": 4 }, { "word": "kapriole", "syllables": 4 }, { "word": "karosserielinie", "syllables": 6 }, { "word": "konopeen", "syllables": 4 }, { "word": "lacrosse", "syllables": 2 }, { "word": "laplace", "syllables": 2 }, { "word": "late-", "syllables": 1 }, { "word": "lead", "syllables": 1 }, { "word": "league", "syllables": 1 }, { "word": "learn", "syllables": 1 }, { "word": "légière", "syllables": 2 }, { "word": "lizenziat", "syllables": 4 }, { "word": "load", "syllables": 1 }, { "word": "lotterielos", "syllables": 4 }, { "word": "lounge", "syllables": 1 }, { "word": "lyzeen", "syllables": 3 }, { "word": "madame", "syllables": 2 }, { "word": "mademoiselle", "syllables": 3 }, { "word": "magier", "syllables": 3 }, { "word": "make-up", "syllables": 2 }, { "word": "malware", "syllables": 2 }, { "word": "management", "syllables": 3 }, { "word": "manteau", "syllables": 2 }, { "word": "mausoleen", "syllables": 4 }, { "word": "mauve", "syllables": 1 }, { "word": "medien", "syllables": 3 }, { "word": "mesdames", "syllables": 2 }, { "word": "mesopotamien", "syllables": 6 }, { "word": "milliarde", "syllables": 3 }, { "word": "missile", "syllables": 2 }, { "word": "miszellaneen", "syllables": 5 }, { "word": "mousse", "syllables": 1 }, { "word": "mousseline", "syllables": 3 }, { "word": "museen", "syllables": 3 }, { "word": "musette", "syllables": 2 }, { "word": "nahuatl", "syllables": 2 }, { "word": "noisette", "syllables": 2 }, { "word": "notebook", "syllables": 2 }, { "word": "nuance", "syllables": 3 }, { "word": "nuklease", "syllables": 4 }, { "word": "odeen", "syllables": 3 }, { "word": "offline", "syllables": 2 }, { "word": "offside", "syllables": 2 }, { "word": "oleaster", "syllables": 4 }, { "word": "on-stage", "syllables": 2 }, { "word": "online", "syllables": 2 }, { "word": "orpheen", "syllables": 3 }, { "word": "parforceritt", "syllables": 3 }, { "word": "patiens", "syllables": 2 }, { "word": "patient", "syllables": 2 }, { "word": "peace", "syllables": 1 }, { "word": "peace", "syllables": 1 }, { "word": "peanuts", "syllables": 2 }, { "word": "people", "syllables": 2 }, { "word": "perineen", "syllables": 4 }, { "word": "peritoneen", "syllables": 5 }, { "word": "picture", "syllables": 2 }, { "word": "piece", "syllables": 1 }, { "word": "pipeline", "syllables": 2 }, { "word": "plateau", "syllables": 2 }, { "word": "poesie", "syllables": 3 }, { "word": "poleposition", "syllables": 4 }, { "word": "portemanteau", "syllables": 3 }, { "word": "portemonnaie", "syllables": 3 }, { "word": "primerate", "syllables": 2 }, { "word": "primerate", "syllables": 2 }, { "word": "primetime", "syllables": 2 }, { "word": "protease", "syllables": 4 }, { "word": "protein", "syllables": 3 }, { "word": "prytaneen", "syllables": 4 }, { "word": "quotient", "syllables": 2 }, { "word": "radio", "syllables": 3 }, { "word": "reader", "syllables": 2 }, { "word": "ready", "syllables": 2 }, { "word": "reallife", "syllables": 2 }, { "word": "repeat", "syllables": 2 }, { "word": "retake", "syllables": 2 }, { "word": "rigole", "syllables": 2 }, { "word": "risolle", "syllables": 2 }, { "word": "road", "syllables": 1 }, { "word": "roaming", "syllables": 2 }, { "word": "roquefort", "syllables": 2 }, { "word": "safe", "syllables": 1 }, { "word": "savonette", "syllables": 3 }, { "word": "sciencefiction", "syllables": 3 }, { "word": "search", "syllables": 1 }, { "word": "selfmade", "syllables": 2 }, { "word": "septime", "syllables": 3 }, { "word": "serapeen", "syllables": 4 }, { "word": "service", "syllables": 2 }, { "word": "serviette", "syllables": 2 }, { "word": "share", "syllables": 1 }, { "word": "shave", "syllables": 1 }, { "word": "shore", "syllables": 1 }, { "word": "sidebar", "syllables": 2 }, { "word": "sideboard", "syllables": 2 }, { "word": "sidekick", "syllables": 2 }, { "word": "silhouette", "syllables": 3 }, { "word": "sitemap", "syllables": 2 }, { "word": "slide", "syllables": 1 }, { "word": "sneak", "syllables": 1 }, { "word": "soap", "syllables": 1 }, { "word": "softcore", "syllables": 2 }, { "word": "software", "syllables": 2 }, { "word": "soutanelle", "syllables": 3 }, { "word": "speak", "syllables": 1 }, { "word": "special", "syllables": 2 }, { "word": "spracheinstellung", "syllables": 5 }, { "word": "spyware", "syllables": 2 }, { "word": "square", "syllables": 1 }, { "word": "stagediving", "syllables": 3 }, { "word": "stakeholder", "syllables": 3 }, { "word": "statement", "syllables": 2 }, { "word": "steady", "syllables": 2 }, { "word": "steak", "syllables": 1 }, { "word": "stealth", "syllables": 1 }, { "word": "steam", "syllables": 1 }, { "word": "stoned", "syllables": 1 }, { "word": "stracciatella", "syllables": 4 }, { "word": "stream", "syllables": 1 }, { "word": "stride", "syllables": 1 }, { "word": "strike", "syllables": 1 }, { "word": "suitcase", "syllables": 2 }, { "word": "sweepstake", "syllables": 2 }, { "word": "t-bone", "syllables": 2 }, { "word": "t-shirt", "syllables": 1 }, { "word": "tailgate", "syllables": 2 }, { "word": "take-off", "syllables": 2 }, { "word": "take-over", "syllables": 3 }, { "word": "takeaway", "syllables": 3 }, { "word": "takeoff", "syllables": 2 }, { "word": "takeover", "syllables": 3 }, { "word": "throat", "syllables": 1 }, { "word": "time-out", "syllables": 2 }, { "word": "timelag", "syllables": 2 }, { "word": "timeline", "syllables": 2 }, { "word": "timesharing", "syllables": 3 }, { "word": "toast", "syllables": 1 }, { "word": "traubenmaische", "syllables": 4 }, { "word": "tristesse", "syllables": 2 }, { "word": "usenet", "syllables": 2 }, { "word": "varietät", "syllables": 4 }, { "word": "varieté", "syllables": 4 }, { "word": "vinaigrette", "syllables": 3 }, { "word": "vintage", "syllables": 2 }, { "word": "violett", "syllables": 3 }, { "word": "voice", "syllables": 1 }, { "word": "wakeboard", "syllables": 2 }, { "word": "washed", "syllables": 1 }, { "word": "waveboard", "syllables": 2 }, { "word": "wear", "syllables": 1 }, { "word": "wear", "syllables": 1 }, { "word": "website", "syllables": 2 }, { "word": "white", "syllables": 1 }, { "word": "widescreen", "syllables": 2 }, { "word": "wire", "syllables": 1 }, { "word": "yacht", "syllables": 1 }, { "word": "yorkshire", "syllables": 2 }, { "word": "éprouvette", "syllables": 3, "notFollowedBy": ["n"] }, { "word": "galette", "syllables": 2, "notFollowedBy": ["n"] }, { "word": "gigue", "syllables": 1, "notFollowedBy": ["n"] }, { "word": "groove", "syllables": 1, "notFollowedBy": ["n"] }, { "word": "morgue", "syllables": 1, "notFollowedBy": ["n"] }, { "word": "paillette", "syllables": 2, "notFollowedBy": ["n"] }, { "word": "raclette", "syllables": 2, "notFollowedBy": ["n"] }, { "word": "roulette", "syllables": 2, "notFollowedBy": ["n"] }, { "word": "spike", "syllables": 1, "notFollowedBy": ["n"] }, { "word": "style", "syllables": 1, "notFollowedBy": ["n"] }, { "word": "tablette", "syllables": 2, "notFollowedBy": ["n"] }, { "word": "grunge", "syllables": 1, "notFollowedBy": ["r"] }, { "word": "size", "syllables": 1, "notFollowedBy": ["r"] }, { "word": "value", "syllables": 1, "notFollowedBy": ["r"] }, { "word": "quiche", "syllables": 1, "notFollowedBy": ["s"] }, { "word": "house", "syllables": 1, "notFollowedBy": ["n", "s"] }, { "word": "sauce", "syllables": 1, "notFollowedBy": ["n", "s"] }, { "word": "space", "syllables": 1, "notFollowedBy": ["n", "s"] }, { "word": "airline", "syllables": 2, "notFollowedBy": ["n", "r"] }, { "word": "autosave", "syllables": 3, "notFollowedBy": ["n", "r"] }, { "word": "bagpipe", "syllables": 2, "notFollowedBy": ["n", "r"] }, { "word": "bike", "syllables": 1, "notFollowedBy": ["n", "r"] }, { "word": "dance", "syllables": 1, "notFollowedBy": ["n", "r"] }, { "word": "deadline", "syllables": 2, "notFollowedBy": ["n", "r"] }, { "word": "halfpipe", "syllables": 2, "notFollowedBy": ["n", "r"] }, { "word": "headline", "syllables": 2, "notFollowedBy": ["n", "r"] }, { "word": "home", "syllables": 1, "notFollowedBy": ["n", "r"] }, { "word": "hornpipe", "syllables": 2, "notFollowedBy": ["n", "r"] }, { "word": "hotline", "syllables": 2, "notFollowedBy": ["n", "r"] }, { "word": "infoline", "syllables": 3, "notFollowedBy": ["n", "r"] }, { "word": "inline", "syllables": 2, "notFollowedBy": ["n", "r"] }, { "word": "kite", "syllables": 1, "notFollowedBy": ["n", "r"] }, { "word": "rollerblade", "syllables": 1, "notFollowedBy": ["n", "r"] }, { "word": "score", "syllables": 1, "notFollowedBy": ["n", "r"] }, { "word": "skyline", "syllables": 2, "notFollowedBy": ["n", "r"] }, { "word": "slackline", "syllables": 2, "notFollowedBy": ["n", "r"] }, { "word": "slice", "syllables": 1, "notFollowedBy": ["n", "r", "s"] }, { "word": "snooze", "syllables": 1, "notFollowedBy": ["n", "r"] }, { "word": "storyline", "syllables": 3, "notFollowedBy": ["n", "r"] }, { "word": "office", "syllables": 2, "notFollowedBy": ["s", "r"] }, { "word": "space", "syllables": 1, "notFollowedBy": ["n", "s", "r"] }, { "word": "tease", "syllables": 1, "notFollowedBy": ["n", "s", "r"] }, { "word": "cache", "syllables": 1, "notFollowedBy": ["t"] }], "atBeginningOrEnd": [{ "word": "case", "syllables": 1 }, { "word": "life", "syllables": 1 }, { "word": "teak", "syllables": 1 }, { "word": "team", "syllables": 1 }, { "word": "creme", "syllables": 1, "notFollowedBy": ["n", "r"] }, { "word": "crème", "syllables": 1, "notFollowedBy": ["n", "r"] }, { "word": "drive", "syllables": 1, "notFollowedBy": ["n", "r"] }, { "word": "skate", "syllables": 1, "notFollowedBy": ["n", "r"] }, { "word": "update", "syllables": 2, "notFollowedBy": ["n", "r"] }, { "word": "upgrade", "syllables": 2, "notFollowedBy": ["n", "r"] }], "atBeginning": [{ "word": "anion", "syllables": 3 }, { "word": "facelift", "syllables": 2 }, { "word": "jiu", "syllables": 1 }, { "word": "pace", "syllables": 1 }, { "word": "shake", "syllables": 1 }, { "word": "tea", "syllables": 1 }, { "word": "trade", "syllables": 1 }, { "word": "deal", "syllables": 1 }], "atEnd": [{ "word": "face", "syllables": 1 }, { "word": "file", "syllables": 1 }, { "word": "mousse", "syllables": 1 }, { "word": "plate", "syllables": 1 }, { "word": "tape", "syllables": 1 }, { "word": "byte", "syllables": 1, "alsoFollowedBy": ["s"] }, { "word": "cape", "syllables": 1, "alsoFollowedBy": ["s"] }, { "word": "five", "syllables": 1, "alsoFollowedBy": ["s"] }, { "word": "hype", "syllables": 1, "alsoFollowedBy": ["s"] }, { "word": "leak", "syllables": 1, "alsoFollowedBy": ["s"] }, { "word": "like", "syllables": 1, "alsoFollowedBy": ["s"] }, { "word": "make", "syllables": 1, "alsoFollowedBy": ["s"] }, { "word": "phone", "syllables": 1, "alsoFollowedBy": ["s"] }, { "word": "rave", "syllables": 1, "alsoFollowedBy": ["s"] }, { "word": "regime", "syllables": 2, "alsoFollowedBy": ["s"] }, { "word": "statue", "syllables": 2, "alsoFollowedBy": ["s"] }, { "word": "store", "syllables": 1, "alsoFollowedBy": ["s"] }, { "word": "wave", "syllables": 1, "alsoFollowedBy": ["s"] }, { "word": "date", "syllables": 1, "notFollowedBy": ["n"] }, { "word": "image", "syllables": 2, "notFollowedBy": ["s"] }] } } } } }), (function (module, exports) { module.exports = { "vowels": "aeiouy", "deviations": { "vowels": [{ "fragments": ["cial", "tia", "cius", "giu", "ion", "[^bdnprv]iou", "sia$", "[^aeiuot]{2,}ed$", "[aeiouy][^aeiuoyts]{1,}e$", "[a-z]ely$", "[cgy]ed$", "rved$", "[aeiouy][dt]es?$", "eau", "ieu", "oeu", "[aeiouy][^aeiouydt]e[sd]?$", "[aeouy]rse$", "^eye"], "countModifier": -1 }, { "fragments": ["ia", "iu", "ii", "io", "[aeio][aeiou]{2}", "[aeiou]ing", "[^aeiou]ying", "ui[aeou]"], "countModifier": 1 }, { "fragments": ["^ree[jmnpqrsx]", "^reele", "^reeva", "riet", "dien", "[aeiouym][bdp]le$", "uei", "uou", "^mc", "ism$", "[^l]lien", "^coa[dglx].", "[^gqauieo]ua[^auieo]", "dn't$", "uity$", "ie(r|st)", "[aeiouw]y[aeiou]", "[^ao]ire[ds]", "[^ao]ire$"], "countModifier": 1 }, { "fragments": ["eoa", "eoo", "ioa", "ioe", "ioo"], "countModifier": 1 }], "words": { "full": [{ "word": "business", "syllables": 2 }, { "word": "coheiress", "syllables": 3 }, { "word": "colonel", "syllables": 2 }, { "word": "heiress", "syllables": 2 }, { "word": "i.e", "syllables": 2 }, { "word": "shoreline", "syllables": 2 }, { "word": "simile", "syllables": 3 }, { "word": "unheired", "syllables": 2 }, { "word": "wednesday", "syllables": 2 }], "fragments": { "global": [{ "word": "coyote", "syllables": 3 }, { "word": "graveyard", "syllables": 2 }, { "word": "lawyer", "syllables": 2 }] } } } } }), (function (module, exports) { module.exports = { "vowels": "aáäâeéëêiíïîoóöôuúüûy", "deviations": { "vowels": [{ "fragments": ["ue$", "dge$", "[tcp]iënt", "ace$", "[br]each", "[ainpr]tiaal", "[io]tiaan", "gua[yc]", "[^i]deal", "tive$", "load", "[^e]coke", "[^s]core$"], "countModifier": -1 }, { "fragments": ["aä", "aeu", "aie", "ao", "ë", "eo", "eú", "ieau", "ea$", "ea[^u]", "ei[ej]", "eu[iu]", "ï", "iei", "ienne", "[^l]ieu[^w]", "[^l]ieu$", "i[auiy]", "stion", "[^cstx]io", "^sion", "riè", "oö", "oa", "oeing", "oie", "[eu]ü", "[^q]u[aeèo]", "uie", "[bhnpr]ieel", "[bhnpr]iël"], "countModifier": 1 }, { "fragments": ["[aeolu]y[aeéèoóu]"], "countModifier": 1 }], "words": { "full": [{ "word": "bye", "syllables": 1 }, { "word": "core", "syllables": 1 }, { "word": "cure", "syllables": 1 }, { "word": "dei", "syllables": 2 }, { "word": "dope", "syllables": 1 }, { "word": "dude", "syllables": 1 }, { "word": "fake", "syllables": 1 }, { "word": "fame", "syllables": 1 }, { "word": "five", "syllables": 1 }, { "word": "hole", "syllables": 1 }, { "word": "least", "syllables": 1 }, { "word": "lone", "syllables": 1 }, { "word": "minute", "syllables": 2 }, { "word": "move", "syllables": 1 }, { "word": "nice", "syllables": 1 }, { "word": "one", "syllables": 1 }, { "word": "state", "syllables": 1 }, { "word": "surplace", "syllables": 2 }, { "word": "take", "syllables": 1 }, { "word": "trade", "syllables": 1 }, { "word": "wide", "syllables": 1 }], "fragments": { "global": [{ "word": "adieu", "syllables": 2 }, { "word": "airline", "syllables": 2 }, { "word": "airmiles", "syllables": 2 }, { "word": "alien", "syllables": 3 }, { "word": "ambient", "syllables": 3 }, { "word": "announcement", "syllables": 3 }, { "word": "appearance", "syllables": 3 }, { "word": "appeasement", "syllables": 3 }, { "word": "atheneum", "syllables": 4 }, { "word": "awesome", "syllables": 2 }, { "word": "baccalaurei", "syllables": 5 }, { "word": "baccalaureus", "syllables": 5 }, { "word": "baseball", "syllables": 3 }, { "word": "basejump", "syllables": 2 }, { "word": "banlieue", "syllables": 3 }, { "word": "bapao", "syllables": 2 }, { "word": "barbecue", "syllables": 3 }, { "word": "beamer", "syllables": 2 }, { "word": "beanie", "syllables": 2 }, { "word": "beat", "syllables": 1 }, { "word": "belle", "syllables": 2 }, { "word": "bête", "syllables": 1 }, { "word": "bingewatch", "syllables": 2 }, { "word": "blocnote", "syllables": 2 }, { "word": "blue", "syllables": 1 }, { "word": "board", "syllables": 1 }, { "word": "break", "syllables": 1 }, { "word": "broad", "syllables": 1 }, { "word": "bulls-eye", "syllables": 2 }, { "word": "business", "syllables": 2 }, { "word": "byebye", "syllables": 2 }, { "word": "cacao", "syllables": 2 }, { "word": "caesar", "syllables": 2 }, { "word": "camaieu", "syllables": 3 }, { "word": "caoutchouc", "syllables": 2 }, { "word": "carbolineum", "syllables": 5 }, { "word": "catchphrase", "syllables": 1 }, { "word": "carrier", "syllables": 3 }, { "word": "cheat", "syllables": 1 }, { "word": "cheese", "syllables": 1 }, { "word": "circonflexe", "syllables": 3 }, { "word": "clean", "syllables": 1 }, { "word": "cloak", "syllables": 1 }, { "word": "cobuying", "syllables": 3 }, { "word": "comeback", "syllables": 2 }, { "word": "comfortzone", "syllables": 3 }, { "word": "communiqué", "syllables": 4 }, { "word": "conopeum", "syllables": 4 }, { "word": "console", "syllables": 2 }, { "word": "corporate", "syllables": 3 }, { "word": "coûte", "syllables": 1 }, { "word": "creamer", "syllables": 2 }, { "word": "crime", "syllables": 1 }, { "word": "cruesli", "syllables": 2 }, { "word": "deadline", "syllables": 2 }, { "word": "deautoriseren", "syllables": 6 }, { "word": "deuce", "syllables": 1 }, { "word": "deum", "syllables": 2 }, { "word": "dirndl", "syllables": 2 }, { "word": "dread", "syllables": 2 }, { "word": "dreamteam", "syllables": 2 }, { "word": "drone", "syllables": 1 }, { "word": "enquête", "syllables": 3 }, { "word": "escape", "syllables": 2 }, { "word": "exposure", "syllables": 3 }, { "word": "extranei", "syllables": 4 }, { "word": "extraneus", "syllables": 4 }, { "word": "eyecatcher", "syllables": 3 }, { "word": "eyeliner", "syllables": 3 }, { "word": "eyeopener", "syllables": 4 }, { "word": "eyetracker", "syllables": 3 }, { "word": "eyetracking", "syllables": 3 }, { "word": "fairtrade", "syllables": 2 }, { "word": "fauteuil", "syllables": 2 }, { "word": "feature", "syllables": 2 }, { "word": "feuilletee", "syllables": 3 }, { "word": "feuilleton", "syllables": 3 }, { "word": "fisheye", "syllables": 2 }, { "word": "fineliner", "syllables": 3 }, { "word": "finetunen", "syllables": 3 }, { "word": "forehand", "syllables": 2 }, { "word": "freak", "syllables": 1 }, { "word": "fusioneren", "syllables": 4 }, { "word": "gayparade", "syllables": 3 }, { "word": "gaypride", "syllables": 2 }, { "word": "goal", "syllables": 1 }, { "word": "grapefruit", "syllables": 2 }, { "word": "gruyère", "syllables": 3 }, { "word": "guele", "syllables": 1 }, { "word": "guerrilla", "syllables": 3 }, { "word": "guest", "syllables": 1 }, { "word": "hardware", "syllables": 2 }, { "word": "haute", "syllables": 1 }, { "word": "healing", "syllables": 2 }, { "word": "heater", "syllables": 2 }, { "word": "heavy", "syllables": 2 }, { "word": "hoax", "syllables": 1 }, { "word": "hotline", "syllables": 2 }, { "word": "idee-fixe", "syllables": 3 }, { "word": "inclusive", "syllables": 3 }, { "word": "inline", "syllables": 2 }, { "word": "intake", "syllables": 2 }, { "word": "intensive", "syllables": 3 }, { "word": "jeans", "syllables": 1 }, { "word": "Jones", "syllables": 1 }, { "word": "jubileum", "syllables": 4 }, { "word": "kalfsribeye", "syllables": 3 }, { "word": "kraaiennest", "syllables": 3 }, { "word": "lastminute", "syllables": 3 }, { "word": "learning", "syllables": 2 }, { "word": "league", "syllables": 1 }, { "word": "line-up", "syllables": 2 }, { "word": "linoleum", "syllables": 4 }, { "word": "load", "syllables": 1 }, { "word": "loafer", "syllables": 2 }, { "word": "longread", "syllables": 2 }, { "word": "lookalike", "syllables": 3 }, { "word": "louis", "syllables": 3 }, { "word": "lyceum", "syllables": 3 }, { "word": "magazine", "syllables": 3 }, { "word": "mainstream", "syllables": 2 }, { "word": "make-over", "syllables": 3 }, { "word": "make-up", "syllables": 2 }, { "word": "malware", "syllables": 2 }, { "word": "marmoleum", "syllables": 4 }, { "word": "mausoleum", "syllables": 4 }, { "word": "medeauteur", "syllables": 4 }, { "word": "midlifecrisis", "syllables": 4 }, { "word": "migraineaura", "syllables": 5 }, { "word": "milkshake", "syllables": 2 }, { "word": "millefeuille", "syllables": 4 }, { "word": "mixed", "syllables": 1 }, { "word": "muesli", "syllables": 2 }, { "word": "museum", "syllables": 3 }, { "word": "must-have", "syllables": 2 }, { "word": "must-read", "syllables": 2 }, { "word": "notebook", "syllables": 2 }, { "word": "nonsense", "syllables": 2 }, { "word": "nowhere", "syllables": 2 }, { "word": "nurture", "syllables": 2 }, { "word": "offline", "syllables": 2 }, { "word": "oneliner", "syllables": 3 }, { "word": "onesie", "syllables": 2 }, { "word": "online", "syllables": 2 }, { "word": "opinion", "syllables": 3 }, { "word": "paella", "syllables": 3 }, { "word": "pacemaker", "syllables": 3 }, { "word": "panache", "syllables": 2 }, { "word": "papegaaienneus", "syllables": 5 }, { "word": "passe-partout", "syllables": 3 }, { "word": "peanuts", "syllables": 2 }, { "word": "perigeum", "syllables": 4 }, { "word": "perineum", "syllables": 4 }, { "word": "perpetuum", "syllables": 4 }, { "word": "petroleum", "syllables": 4 }, { "word": "phone", "syllables": 3 }, { "word": "picture", "syllables": 2 }, { "word": "placemat", "syllables": 2 }, { "word": "porte-manteau", "syllables": 3 }, { "word": "portefeuille", "syllables": 4 }, { "word": "presse-papier", "syllables": 3 }, { "word": "primetime", "syllables": 2 }, { "word": "queen", "syllables": 1 }, { "word": "questionnaire", "syllables": 3 }, { "word": "queue", "syllables": 1 }, { "word": "reader", "syllables": 2 }, { "word": "reality", "syllables": 3 }, { "word": "reallife", "syllables": 2 }, { "word": "remake", "syllables": 2 }, { "word": "repeat", "syllables": 2 }, { "word": "repertoire", "syllables": 3 }, { "word": "research", "syllables": 2 }, { "word": "reverence", "syllables": 3 }, { "word": "ribeye", "syllables": 2 }, { "word": "ringtone", "syllables": 3 }, { "word": "road", "syllables": 1 }, { "word": "roaming", "syllables": 2 }, { "word": "sciencefiction", "syllables": 4 }, { "word": "selfmade", "syllables": 2 }, { "word": "sidekick", "syllables": 2 }, { "word": "sightseeing", "syllables": 3 }, { "word": "skyline", "syllables": 2 }, { "word": "smile", "syllables": 1 }, { "word": "sneaky", "syllables": 2 }, { "word": "software", "syllables": 2 }, { "word": "sparerib", "syllables": 2 }, { "word": "speaker", "syllables": 2 }, { "word": "spread", "syllables": 1 }, { "word": "statement", "syllables": 2 }, { "word": "steak", "syllables": 1 }, { "word": "steeplechase", "syllables": 3 }, { "word": "stonewash", "syllables": 2 }, { "word": "store", "syllables": 1 }, { "word": "streaken", "syllables": 2 }, { "word": "stream", "syllables": 1 }, { "word": "streetware", "syllables": 1 }, { "word": "supersoaker", "syllables": 4 }, { "word": "surprise-party", "syllables": 4 }, { "word": "sweater", "syllables": 2 }, { "word": "teaser", "syllables": 2 }, { "word": "tenue", "syllables": 2 }, { "word": "template", "syllables": 2 }, { "word": "timeline", "syllables": 2 }, { "word": "tissue", "syllables": 2 }, { "word": "toast", "syllables": 1 }, { "word": "tête-à-tête", "syllables": 3 }, { "word": "typecast", "syllables": 2 }, { "word": "unique", "syllables": 2 }, { "word": "ureum", "syllables": 3 }, { "word": "vibe", "syllables": 1 }, { "word": "vieux", "syllables": 1 }, { "word": "ville", "syllables": 1 }, { "word": "vintage", "syllables": 2 }, { "word": "wandelyup", "syllables": 3 }, { "word": "wiseguy", "syllables": 2 }, { "word": "wake-up-call", "syllables": 3 }, { "word": "webcare", "syllables": 2 }, { "word": "winegum", "syllables": 2 }, { "word": "base", "syllables": 1, "notFollowedBy": ["e", "n", "r"] }, { "word": "game", "syllables": 1, "notFollowedBy": ["n", "l", "r"] }, { "word": "style", "syllables": 1, "notFollowedBy": ["n", "s"] }, { "word": "douche", "syllables": 1, "notFollowedBy": ["n", "s"] }, { "word": "space", "syllables": 1, "notFollowedBy": ["n", "s"] }, { "word": "striptease", "syllables": 2, "notFollowedBy": ["n", "s"] }, { "word": "jive", "syllables": 1, "notFollowedBy": ["n", "r"] }, { "word": "keynote", "syllables": 2, "notFollowedBy": ["n", "r"] }, { "word": "mountainbike", "syllables": 3, "notFollowedBy": ["n", "r"] }, { "word": "face", "syllables": 1, "notFollowedBy": ["n", "t"] }, { "word": "challenge", "syllables": 2, "notFollowedBy": ["n", "r", "s"] }, { "word": "cruise", "syllables": 1, "notFollowedBy": ["n", "r", "s"] }, { "word": "house", "syllables": 1, "notFollowedBy": ["n", "r", "s"] }, { "word": "dance", "syllables": 1, "notFollowedBy": ["n", "r", "s"] }, { "word": "franchise", "syllables": 2, "notFollowedBy": ["n", "r", "s"] }, { "word": "freelance", "syllables": 2, "notFollowedBy": ["n", "r", "s"] }, { "word": "lease", "syllables": 1, "notFollowedBy": ["n", "r", "s"] }, { "word": "linedance", "syllables": 2, "notFollowedBy": ["n", "r", "s"] }, { "word": "lounge", "syllables": 1, "notFollowedBy": ["n", "r", "s"] }, { "word": "merchandise", "syllables": 3, "notFollowedBy": ["n", "r", "s"] }, { "word": "performance", "syllables": 3, "notFollowedBy": ["n", "r", "s"] }, { "word": "release", "syllables": 2, "notFollowedBy": ["n", "r", "s"] }, { "word": "resource", "syllables": 2, "notFollowedBy": ["n", "r", "s"] }, { "word": "cache", "syllables": 1, "notFollowedBy": ["c", "l", "n", "t", "x"] }, { "word": "office", "syllables": 2, "notFollowedBy": ["r", "s"] }, { "word": "close", "syllables": 1, "notFollowedBy": ["r", "t"] }], "atBeginningOrEnd": [{ "word": "byte", "syllables": 1 }, { "word": "cake", "syllables": 1 }, { "word": "care", "syllables": 1 }, { "word": "coach", "syllables": 1 }, { "word": "coat", "syllables": 1 }, { "word": "earl", "syllables": 1 }, { "word": "foam", "syllables": 1 }, { "word": "gate", "syllables": 1 }, { "word": "head", "syllables": 1 }, { "word": "home", "syllables": 1 }, { "word": "live", "syllables": 1 }, { "word": "safe", "syllables": 1 }, { "word": "site", "syllables": 1 }, { "word": "soap", "syllables": 1 }, { "word": "teak", "syllables": 1 }, { "word": "team", "syllables": 1 }, { "word": "wave", "syllables": 1 }, { "word": "brace", "syllables": 1, "notFollowedBy": ["s"] }, { "word": "case", "syllables": 1, "notFollowedBy": ["s"] }, { "word": "fleece", "syllables": 1, "notFollowedBy": ["s"] }, { "word": "service", "syllables": 2, "notFollowedBy": ["s"] }, { "word": "voice", "syllables": 1, "notFollowedBy": ["s"] }, { "word": "kite", "syllables": 1, "notFollowedBy": ["n", "r"] }, { "word": "skate", "syllables": 1, "notFollowedBy": ["n", "r"] }, { "word": "race", "syllables": 1, "notFollowedBy": ["n", "r", "s"] }], "atBeginning": [{ "word": "coke", "syllables": 1 }, { "word": "deal", "syllables": 1 }, { "word": "image", "syllables": 2, "notFollowedBy": ["s"] }], "atEnd": [{ "word": "force", "syllables": 1 }, { "word": "tea", "syllables": 1 }, { "word": "time", "syllables": 1 }, { "word": "date", "syllables": 1, "alsoFollowedBy": ["s"] }, { "word": "hype", "syllables": 1, "alsoFollowedBy": ["s"] }, { "word": "quote", "syllables": 1, "alsoFollowedBy": ["s"] }, { "word": "tape", "syllables": 1, "alsoFollowedBy": ["s"] }, { "word": "upgrade", "syllables": 2, "alsoFollowedBy": ["s"] }] } } } } }), (function (module, exports) { module.exports = { "vowels": "aeiouyàèéìîïòù", "deviations": { "vowels": [{ "fragments": ["a[íúeo]", "e[íúao]", "o[íúaeè]", "í[aeo]", "ú[aeo]", "ai[aeou]", "àii", "aiì", "au[eé]", "ei[aàeèé]", "èia", "ia[èiì]", "iài", "oi[aàeèo]", "òia", "óio", "uí", "ui[aàó]", "ùio", "ouï", "coo[cmnpr]", "lcool", "coòf", "[aeuioìùèéàò]y[aeuioíìùèàó]", "ìa$", "èa$"], "countModifier": 1 }, { "fragments": ["aoi", "aoì", "ioe", "riae", "ïa$"], "countModifier": 1 }], "words": { "full": [{ "word": "via", "syllables": 2 }, { "word": "guaime", "syllables": 3 }, { "word": "guaina", "syllables": 3 }, { "word": "coke", "syllables": 1 }, { "word": "frame", "syllables": 1 }, { "word": "goal", "syllables": 1 }, { "word": "live", "syllables": 1 }, { "word": "mouse", "syllables": 1 }, { "word": "coon", "syllables": 1 }], "fragments": { "global": [{ "word": "mayoyào", "syllables": 4 }, { "word": "eye-liner", "syllables": 3 }, { "word": "scooner", "syllables": 2 }, { "word": "cocoon", "syllables": 2 }, { "word": "silhouette", "syllables": 4 }, { "word": "circuíto", "syllables": 4 }, { "word": "cruento", "syllables": 3 }, { "word": "cruènto", "syllables": 3 }, { "word": "rituale", "syllables": 4 }, { "word": "duello", "syllables": 3 }, { "word": "fuorviante", "syllables": 4 }, { "word": "league", "syllables": 1 }, { "word": "leader", "syllables": 2 }, { "word": "appeal", "syllables": 2 }, { "word": "backstage", "syllables": 2 }, { "word": "badge", "syllables": 1 }, { "word": "baseball", "syllables": 2 }, { "word": "beauty", "syllables": 2 }, { "word": "bondage", "syllables": 2, "notFollowedBy": ["s"] }, { "word": "break", "syllables": 1 }, { "word": "brokerage", "syllables": 3 }, { "word": "business", "syllables": 2 }, { "word": "cache", "syllables": 2, "notFollowedBy": ["s", "r"] }, { "word": "cashmere", "syllables": 2 }, { "word": "challenge", "syllables": 2, "notFollowedBy": ["s", "r"] }, { "word": "charleston", "syllables": 2 }, { "word": "cheap", "syllables": 1 }, { "word": "cottage", "syllables": 2, "notFollowedBy": ["s"] }, { "word": "cruise", "syllables": 1, "notFollowedBy": ["s", "r"] }, { "word": "device", "syllables": 2, "notFollowedBy": ["s"] }, { "word": "downgrade", "syllables": 2, "notFollowedBy": ["d"] }, { "word": "download", "syllables": 2 }, { "word": "drive", "syllables": 1, "notFollowedBy": ["r"] }, { "word": "endorsement", "syllables": 3 }, { "word": "drive", "syllables": 1, "notFollowedBy": ["r"] }, { "word": "executive", "syllables": 4 }, { "word": "firmware", "syllables": 2 }, { "word": "fobia", "syllables": 3 }, { "word": "float", "syllables": 1 }, { "word": "freak", "syllables": 1 }, { "word": "game", "syllables": 1, "notFollowedBy": ["r"] }, { "word": "guideline", "syllables": 2 }, { "word": "hardware", "syllables": 2 }, { "word": "homeless", "syllables": 2 }, { "word": "hardware", "syllables": 1, "notFollowedBy": ["r"] }, { "word": "hardware", "syllables": 1, "notFollowedBy": ["r"] }, { "word": "hardware", "syllables": 1, "notFollowedBy": ["r"] }, { "word": "hospice", "syllables": 2, "notFollowedBy": ["s"] }, { "word": "impeachment", "syllables": 3 }, { "word": "jeans", "syllables": 1 }, { "word": "jukebox", "syllables": 2 }, { "word": "leasing", "syllables": 2 }, { "word": "lease", "syllables": 1, "notFollowedBy": ["s"] }, { "word": "lounge", "syllables": 1, "notFollowedBy": ["r", "s"] }, { "word": "magazine", "syllables": 3 }, { "word": "notebook", "syllables": 2 }, { "word": "office", "syllables": 2, "notFollowedBy": ["r", "s"] }, { "word": "online", "syllables": 2 }, { "word": "offline", "syllables": 2 }, { "word": "overcoat", "syllables": 3 }, { "word": "offside", "syllables": 2, "notFollowedBy": ["r"] }, { "word": "overdrive", "syllables": 3 }, { "word": "oversize", "syllables": 3 }, { "word": "pacemaker", "syllables": 3 }, { "word": "package", "syllables": 2, "notFollowedBy": ["r", "s"] }, { "word": "pancake", "syllables": 2 }, { "word": "performance", "syllables": 3 }, { "word": "premium", "syllables": 3 }, { "word": "ragtime", "syllables": 2 }, { "word": "reading", "syllables": 2 }, { "word": "residence", "syllables": 3, "notFollowedBy": ["s"] }, { "word": "roaming", "syllables": 2 }, { "word": "rollerblade", "syllables": 3, "notFollowedBy": ["r"] }, { "word": "royalty", "syllables": 3 }, { "word": "shake", "syllables": 1, "notFollowedBy": ["r"] }, { "word": "shale", "syllables": 1 }, { "word": "shampooing", "syllables": 3 }, { "word": "shareware", "syllables": 2 }, { "word": "shearling", "syllables": 2 }, { "word": "sidecar", "syllables": 2 }, { "word": "hardware", "syllables": 1, "notFollowedBy": ["r"] }, { "word": "skate", "syllables": 1, "notFollowedBy": ["n", "r"] }, { "word": "trial", "syllables": 2 }, { "word": "toast", "syllables": 1 }, { "word": "texture", "syllables": 2 }, { "word": "testimonial", "syllables": 5 }, { "word": "teaser", "syllables": 2 }, { "word": "sweater", "syllables": 2 }, { "word": "suspense", "syllables": 2, "notFollowedBy": ["r"] }, { "word": "subroutine", "syllables": 3 }, { "word": "steadicam", "syllables": 3 }, { "word": "spread", "syllables": 1 }, { "word": "speaker", "syllables": 2 }, { "word": "board", "syllables": 1 }, { "word": "sneaker", "syllables": 2 }, { "word": "smartphone", "syllables": 2 }, { "word": "slide", "syllables": 1, "notFollowedBy": ["r"] }, { "word": "skyline", "syllables": 2 }, { "word": "skinhead", "syllables": 2 }, { "word": "update", "syllables": 2, "notFollowedBy": ["r"] }, { "word": "upgrade", "syllables": 2, "notFollowedBy": ["r"] }, { "word": "upload", "syllables": 2 }, { "word": "vintage", "syllables": 2 }, { "word": "wakeboard", "syllables": 2 }, { "word": "website", "syllables": 2 }, { "word": "welfare", "syllables": 2 }, { "word": "yeah", "syllables": 1 }, { "word": "yearling", "syllables": 2 }], "atEnd": [{ "word": "byte", "syllables": 1, "alsoFollowedBy": ["s"] }, { "word": "bite", "syllables": 1, "alsoFollowedBy": ["s"] }, { "word": "beat", "syllables": 1, "alsoFollowedBy": ["s"] }, { "word": "coach", "syllables": 1 }, { "word": "line", "syllables": 1, "alsoFollowedBy": ["s"] }], "atBeginning": [{ "word": "cheese", "syllables": 1 }, { "word": "head", "syllables": 1 }, { "word": "streak", "syllables": 1 }], "atBeginningOrEnd": [{ "word": "team", "syllables": 1 }, { "word": "stream", "syllables": 1 }] } } } } }), (function (module, exports, __webpack_require__) {
        var baseIteratee = __webpack_require__(18), isArrayLike = __webpack_require__(19), keys = __webpack_require__(26); function createFind(findIndexFunc) {
            return function (collection, predicate, fromIndex) {
                var iterable = Object(collection); if (!isArrayLike(collection)) { var iteratee = baseIteratee(predicate, 3); collection = keys(collection); predicate = function (key) { return iteratee(iterable[key], key, iterable); }; }
                var index = findIndexFunc(collection, predicate, fromIndex); return index > -1 ? iterable[iteratee ? collection[index] : index] : undefined;
            };
        }
        module.exports = createFind;
    }), (function (module, exports) {
        function baseSum(array, iteratee) {
            var result, index = -1, length = array.length; while (++index < length) { var current = iteratee(array[index]); if (current !== undefined) { result = result === undefined ? current : (result + current); } }
            return result;
        }
        module.exports = baseSum;
    }), (function (module, exports, __webpack_require__) { "use strict"; var SyllableCountStep = __webpack_require__(350); var isUndefined = __webpack_require__(3); var forEach = __webpack_require__(1); var SyllableCountIterator = function SyllableCountIterator(config) { this.countSteps = []; if (!isUndefined(config)) { this.createSyllableCountSteps(config.deviations.vowels); } }; SyllableCountIterator.prototype.createSyllableCountSteps = function (syllableCounts) { forEach(syllableCounts, function (syllableCountStep) { this.countSteps.push(new SyllableCountStep(syllableCountStep)); }.bind(this)); }; SyllableCountIterator.prototype.getAvailableSyllableCountSteps = function () { return this.countSteps; }; SyllableCountIterator.prototype.countSyllables = function (word) { var syllableCount = 0; forEach(this.countSteps, function (step) { syllableCount += step.countSyllables(word); }); return syllableCount; }; module.exports = SyllableCountIterator; }), (function (module, exports, __webpack_require__) {
        "use strict"; var isUndefined = __webpack_require__(3); var arrayToRegex = __webpack_require__(51); var SyllableCountStep = function SyllableCountStep(syllableRegex) { this._hasRegex = false; this._regex = ""; this._multiplier = ""; this.createRegex(syllableRegex); }; SyllableCountStep.prototype.hasRegex = function () { return this._hasRegex; }; SyllableCountStep.prototype.createRegex = function (syllableRegex) { if (!isUndefined(syllableRegex) && !isUndefined(syllableRegex.fragments)) { this._hasRegex = true; this._regex = arrayToRegex(syllableRegex.fragments, true); this._multiplier = syllableRegex.countModifier; } }; SyllableCountStep.prototype.getRegex = function () { return this._regex; }; SyllableCountStep.prototype.countSyllables = function (word) {
            if (this._hasRegex) { var match = word.match(this._regex) || []; return match.length * this._multiplier; }
            return 0;
        }; module.exports = SyllableCountStep;
    }), (function (module, exports, __webpack_require__) {
        "use strict"; var isUndefined = __webpack_require__(3); var pick = __webpack_require__(352); function DeviationFragment(options) { this._location = options.location; this._fragment = options.word; this._syllables = options.syllables; this._regex = null; this._options = pick(options, ["notFollowedBy", "alsoFollowedBy"]); }
        DeviationFragment.prototype.createRegex = function () {
            var regexString = ""; var options = this._options; var fragment = this._fragment; if (!isUndefined(options.notFollowedBy)) { fragment += "(?![" + options.notFollowedBy.join("") + "])"; }
            if (!isUndefined(options.alsoFollowedBy)) { fragment += "[" + options.alsoFollowedBy.join("") + "]?"; }
            switch (this._location) { case "atBeginning": regexString = "^" + fragment; break; case "atEnd": regexString = fragment + "$"; break; case "atBeginningOrEnd": regexString = "(^" + fragment + ")|(" + fragment + "$)"; break; default: regexString = fragment; break; }
            this._regex = new RegExp(regexString);
        }; DeviationFragment.prototype.getRegex = function () {
            if (null === this._regex) { this.createRegex(); }
            return this._regex;
        }; DeviationFragment.prototype.occursIn = function (word) { var regex = this.getRegex(); return regex.test(word); }; DeviationFragment.prototype.removeFrom = function (word) { return word.replace(this._fragment, " "); }; DeviationFragment.prototype.getSyllables = function () { return this._syllables; }; module.exports = DeviationFragment;
    }), (function (module, exports, __webpack_require__) { var basePick = __webpack_require__(353), flatRest = __webpack_require__(356); var pick = flatRest(function (object, paths) { return object == null ? {} : basePick(object, paths); }); module.exports = pick; }), (function (module, exports, __webpack_require__) {
        var basePickBy = __webpack_require__(354), hasIn = __webpack_require__(142); function basePick(object, paths) { return basePickBy(object, paths, function (value, path) { return hasIn(object, path); }); }
        module.exports = basePick;
    }), (function (module, exports, __webpack_require__) {
        var baseGet = __webpack_require__(89), baseSet = __webpack_require__(355), castPath = __webpack_require__(71); function basePickBy(object, paths, predicate) {
            var index = -1, length = paths.length, result = {}; while (++index < length) { var path = paths[index], value = baseGet(object, path); if (predicate(value, path)) { baseSet(result, castPath(path, object), value); } }
            return result;
        }
        module.exports = basePickBy;
    }), (function (module, exports, __webpack_require__) {
        var assignValue = __webpack_require__(98), castPath = __webpack_require__(71), isIndex = __webpack_require__(67), isObject = __webpack_require__(5), toKey = __webpack_require__(47); function baseSet(object, path, value, customizer) {
            if (!isObject(object)) { return object; }
            path = castPath(path, object); var index = -1, length = path.length, lastIndex = length - 1, nested = object; while (nested != null && ++index < length) {
                var key = toKey(path[index]), newValue = value; if (index != lastIndex) { var objValue = nested[key]; newValue = customizer ? customizer(objValue, key, nested) : undefined; if (newValue === undefined) { newValue = isObject(objValue) ? objValue : (isIndex(path[index + 1]) ? [] : {}); } }
                assignValue(nested, key, newValue); nested = nested[key];
            }
            return object;
        }
        module.exports = baseSet;
    }), (function (module, exports, __webpack_require__) {
        var flatten = __webpack_require__(175), overRest = __webpack_require__(158), setToString = __webpack_require__(159); function flatRest(func) { return setToString(overRest(func, undefined, flatten), func + ''); }
        module.exports = flatRest;
    }), (function (module, exports, __webpack_require__) { "use strict"; module.exports = function (paper) { return paper.getDescription().length; }; }), (function (module, exports, __webpack_require__) { "use strict"; var imageInText = __webpack_require__(176); module.exports = function (paper) { return imageInText(paper.getText()).length; }; }), (function (module, exports, __webpack_require__) {
        "use strict"; module.exports = function (text, regexString) {
            var regex = new RegExp(regexString, "ig"); var matches = text.match(regex); if (matches === null) { matches = []; }
            return matches;
        };
    }), (function (module, exports, __webpack_require__) {
        "use strict"; var imageInText = __webpack_require__(176); var imageAlttag = __webpack_require__(361); var wordMatch = __webpack_require__(28); var escapeRegExp = __webpack_require__(12); var matchAltProperties = function matchAltProperties(imageMatches, keyword, locale) {
            var altProperties = { noAlt: 0, withAlt: 0, withAltKeyword: 0, withAltNonKeyword: 0 }; for (var i = 0; i < imageMatches.length; i++) {
                var alttag = imageAlttag(imageMatches[i]); if (alttag === "") { altProperties.noAlt++; continue; }
                if (keyword === "" && alttag !== "") { altProperties.withAlt++; continue; }
                if (wordMatch(alttag, keyword, locale) === 0 && alttag !== "") { altProperties.withAltNonKeyword++; continue; }
                if (wordMatch(alttag, keyword, locale) > 0) { altProperties.withAltKeyword++; continue; }
            }
            return altProperties;
        }; module.exports = function (paper) { var keyword = escapeRegExp(paper.getKeyword().toLocaleLowerCase()); return matchAltProperties(imageInText(paper.getText()), keyword, paper.getLocale()); };
    }), (function (module, exports, __webpack_require__) {
        "use strict"; var stripSpaces = __webpack_require__(8); var regexAltTag = /alt=(['"])(.*?)\1/i; module.exports = function (text) {
            var alt = ""; var matches = text.match(regexAltTag); if (matches !== null) { alt = stripSpaces(matches[2]); alt = alt.replace(/&quot;/g, "\""); alt = alt.replace(/&#039;/g, "'"); }
            return alt;
        };
    }), (function (module, exports, __webpack_require__) {
        "use strict"; var countWords = __webpack_require__(23); var sanitizeString = __webpack_require__(169); function keyphraseLengthResearch(paper) { var keyphrase = sanitizeString(paper.getKeyword()); return countWords(keyphrase); }
        module.exports = keyphraseLengthResearch;
    }), (function (module, exports, __webpack_require__) {
        "use strict"; var matchTextWithWord = __webpack_require__(28); var escapeRegExp = __webpack_require__(12); module.exports = function (paper) {
            if (paper.getDescription() === "") { return -1; }
            var keyword = escapeRegExp(paper.getKeyword()); return matchTextWithWord(paper.getDescription(), keyword, paper.getLocale());
        };
    }), (function (module, exports, __webpack_require__) { "use strict"; var wordMatch = __webpack_require__(28); var escapeRegExp = __webpack_require__(12); module.exports = function (paper) { var keyword = paper.getKeyword().replace("'", "").replace(/\s/ig, "-"); keyword = escapeRegExp(keyword); return wordMatch(paper.getUrl(), keyword, paper.getLocale()); }; }), (function (module, exports, __webpack_require__) { "use strict"; var matchParagraphs = __webpack_require__(177); var wordMatch = __webpack_require__(28); var escapeRegExp = __webpack_require__(12); var reject = __webpack_require__(366); var isEmpty = __webpack_require__(10); module.exports = function (paper) { var paragraphs = matchParagraphs(paper.getText()); var keyword = escapeRegExp(paper.getKeyword().toLocaleLowerCase()); var paragraph = reject(paragraphs, isEmpty)[0] || ""; return wordMatch(paragraph, keyword, paper.getLocale()); }; }), (function (module, exports, __webpack_require__) {
        var arrayFilter = __webpack_require__(86), baseFilter = __webpack_require__(147), baseIteratee = __webpack_require__(18), isArray = __webpack_require__(4), negate = __webpack_require__(148); function reject(collection, predicate) { var func = isArray(collection) ? arrayFilter : baseFilter; return func(collection, negate(baseIteratee(predicate, 3))); }
        module.exports = reject;
    }), (function (module, exports, __webpack_require__) {
        "use strict"; module.exports = function (paper) {
            if (paper.hasTitle()) { return paper.getTitleWidth(); }
            return 0;
        };
    }), (function (module, exports, __webpack_require__) { "use strict"; var getWords = __webpack_require__(27); var countSyllables = __webpack_require__(170); var getSentences = __webpack_require__(22); var map = __webpack_require__(2); var forEach = __webpack_require__(1); var getWordComplexityForSentence = function getWordComplexityForSentence(sentence) { var words = getWords(sentence); var results = []; forEach(words, function (word, i) { results.push({ word: word, wordIndex: i, complexity: countSyllables(word) }); }); return results; }; module.exports = function (paper) { var sentences = getSentences(paper.getText()); return map(sentences, function (sentence) { return { sentence: sentence, words: getWordComplexityForSentence(sentence) }; }); }; }), (function (module, exports, __webpack_require__) { "use strict"; var countWords = __webpack_require__(23); var matchParagraphs = __webpack_require__(177); var filter = __webpack_require__(6); module.exports = function (paper) { var text = paper.getText(); var paragraphs = matchParagraphs(text); var paragraphsLength = []; paragraphs.map(function (paragraph) { paragraphsLength.push({ wordCount: countWords(paragraph), text: paragraph }); }); return filter(paragraphsLength, function (paragraphLength) { return paragraphLength.wordCount > 0; }); }; }), (function (module, exports, __webpack_require__) { "use strict"; var getSentences = __webpack_require__(22); var sentencesLength = __webpack_require__(178); module.exports = function (paper) { var sentences = getSentences(paper.getText()); return sentencesLength(sentences); }; }), (function (module, exports, __webpack_require__) { "use strict"; var getSentences = __webpack_require__(22); var sentencesLength = __webpack_require__(178); module.exports = function (paper) { var sentences = getSentences(paper.getDescription()); return sentencesLength(sentences); }; }), (function (module, exports, __webpack_require__) { "use strict"; var getSubheadingTexts = __webpack_require__(373); var countWords = __webpack_require__(23); var forEach = __webpack_require__(1); module.exports = function (paper) { var text = paper.getText(); var matches = getSubheadingTexts(text); var subHeadingTexts = []; forEach(matches, function (subHeading) { subHeadingTexts.push({ text: subHeading, wordCount: countWords(subHeading) }); }); return subHeadingTexts; }; }), (function (module, exports, __webpack_require__) { "use strict"; module.exports = function (text) { text = text.replace(/\|/ig, ""); text = text.replace(/<h([1-6])(?:[^>]+)?>(.*?)<\/h\1>/ig, "|"); var subheadings = text.split("|"); subheadings.shift(); return subheadings; }; }), (function (module, exports, __webpack_require__) {
        "use strict"; var createRegexFromDoubleArray = __webpack_require__(375); var getSentences = __webpack_require__(22); var normalizeSingleQuotes = __webpack_require__(74).normalizeSingle; var getTransitionWords = __webpack_require__(376); var matchWordInSentence = __webpack_require__(105).isWordInSentence; var forEach = __webpack_require__(1); var filter = __webpack_require__(6); var memoize = __webpack_require__(36); var createRegexFromDoubleArrayCached = memoize(createRegexFromDoubleArray); var matchTwoPartTransitionWords = function matchTwoPartTransitionWords(sentence, twoPartTransitionWords) { sentence = normalizeSingleQuotes(sentence); var twoPartTransitionWordsRegex = createRegexFromDoubleArrayCached(twoPartTransitionWords); return sentence.match(twoPartTransitionWordsRegex); }; var matchTransitionWords = function matchTransitionWords(sentence, transitionWords) { sentence = normalizeSingleQuotes(sentence); var matchedTransitionWords = filter(transitionWords, function (word) { return matchWordInSentence(word, sentence); }); return matchedTransitionWords; }; var checkSentencesForTransitionWords = function checkSentencesForTransitionWords(sentences, transitionWords) {
            var results = []; forEach(sentences, function (sentence) {
                var twoPartMatches = matchTwoPartTransitionWords(sentence, transitionWords.twoPartTransitionWords()); if (twoPartMatches !== null) { results.push({ sentence: sentence, transitionWords: twoPartMatches }); return; }
                var transitionWordMatches = matchTransitionWords(sentence, transitionWords.transitionWords); if (transitionWordMatches.length !== 0) { results.push({ sentence: sentence, transitionWords: transitionWordMatches }); return; }
            }); return results;
        }; module.exports = function (paper) { var locale = paper.getLocale(); var transitionWords = getTransitionWords(locale); var sentences = getSentences(paper.getText()); var sentenceResults = checkSentencesForTransitionWords(sentences, transitionWords); return { totalSentences: sentences.length, sentenceResults: sentenceResults, transitionWordSentences: sentenceResults.length }; };
    }), (function (module, exports, __webpack_require__) { "use strict"; var addWordBoundary = __webpack_require__(50); var wordCombinationToRegexString = function wordCombinationToRegexString(array) { array = array.map(function (word) { return addWordBoundary(word); }); return array.join("(.*?)"); }; module.exports = function (array) { array = array.map(function (wordCombination) { return wordCombinationToRegexString(wordCombination); }); var regexString = "(" + array.join(")|(") + ")"; return new RegExp(regexString, "ig"); }; }), (function (module, exports, __webpack_require__) { "use strict"; var transitionWordsEnglish = __webpack_require__(179)().allWords; var twoPartTransitionWordsEnglish = __webpack_require__(377); var transitionWordsGerman = __webpack_require__(180)().allWords; var twoPartTransitionWordsGerman = __webpack_require__(378); var transitionWordsFrench = __webpack_require__(181)().allWords; var twoPartTransitionWordsFrench = __webpack_require__(379); var transitionWordsSpanish = __webpack_require__(182)().allWords; var twoPartTransitionWordsSpanish = __webpack_require__(380); var transitionWordsDutch = __webpack_require__(183)().allWords; var twoPartTransitionWordsDutch = __webpack_require__(381); var transitionWordsItalian = __webpack_require__(184)().allWords; var twoPartTransitionWordsItalian = __webpack_require__(382); var getLanguage = __webpack_require__(20); module.exports = function (locale) { switch (getLanguage(locale)) { case "de": return { transitionWords: transitionWordsGerman, twoPartTransitionWords: twoPartTransitionWordsGerman }; case "es": return { transitionWords: transitionWordsSpanish, twoPartTransitionWords: twoPartTransitionWordsSpanish }; case "fr": return { transitionWords: transitionWordsFrench, twoPartTransitionWords: twoPartTransitionWordsFrench }; case "nl": return { transitionWords: transitionWordsDutch, twoPartTransitionWords: twoPartTransitionWordsDutch }; case "it": return { transitionWords: transitionWordsItalian, twoPartTransitionWords: twoPartTransitionWordsItalian }; default: case "en": return { transitionWords: transitionWordsEnglish, twoPartTransitionWords: twoPartTransitionWordsEnglish }; } }; }), (function (module, exports, __webpack_require__) { "use strict"; module.exports = function () { return [["both", "and"], ["if", "then"], ["not only", "but also"], ["neither", "nor"], ["either", "or"], ["not", "but"], ["whether", "or"], ["no sooner", "than"]]; }; }), (function (module, exports, __webpack_require__) { "use strict"; module.exports = function () { return [["anstatt", "dass"], ["bald", "bald"], ["dadurch", "dass"], ["dessen ungeachtet", "dass"], ["entweder", "oder"], ["einerseits", "andererseits"], ["erst", "wenn"], ["je", "desto"], ["je", "umsto"], ["nicht nur", "sondern auch"], ["ob", "oder"], ["ohne", "dass"], ["so", "dass"], ["sowohl", "als auch"], ["sowohl", "wie auch"], ["unbeschadet dessen", "dass"], ["weder", "noch"], ["wenn", "auch"], ["wenn", "schon"], ["nicht weil", "sondern"]]; }; }), (function (module, exports, __webpack_require__) { "use strict"; module.exports = function () { return [["à première vue", "mais à bien considérer les choses"], ["à première vue", "mais toute réflexion faite"], ["aussi", "que"], ["autant de", "que"], ["certes", "mais"], ["d'un côté", "de l'autre côté"], ["d'un côté", "de l'autre"], ["d'un côté", "d'un autre côté"], ["d'une part", "d'autre part"], ["d'une parte", "de l'autre parte"], ["moins de", "que"], ["non seulement", "mais aussi"], ["non seulement", "mais en outre"], ["non seulement", "mais encore"], ["plus de", "que"], ["quelque", "que"], ["si", "que"], ["soit", "soit"], ["tantôt", "tantôt"], ["tout d'abord", "ensuite"], ["tout", "que"]]; }; }), (function (module, exports, __webpack_require__) { "use strict"; module.exports = function () { return [["de un lado", "de otra parte"], ["de un lado", "de otro"], ["no", "sino que"], ["no", "sino"], ["por un lado", "por otro lado"], ["por una parte", "por otra parte"], ["por una parte", "por otra"], ["tanto", "como"], ["bien", "bien"]]; }; }), (function (module, exports, __webpack_require__) { "use strict"; module.exports = function () { return [["aan de ene kant", "aan de andere kant"], ["enerzijds", "anderzijds"], ["natuurlijk", "maar"], ["niet alleen", "maar ook"], ["noch", "noch"], ["zowel", "als"]]; }; }), (function (module, exports, __webpack_require__) { "use strict"; module.exports = function () { return [["né", "né"], ["non", "ma"], ["non prima", "che"], ["non prima", "di"], ["non solo", "ma anche"], ["o", "o"], ["se", "allora"], ["se", "o"], ["sia", "che"]]; }; }), (function (module, exports, __webpack_require__) { "use strict"; module.exports = function () { return [" ", "\\n", "\\r", "\\t", "\xA0", " ", ".", ",", "'", "(", ")", "\"", "+", "-", ";", "!", "?", ":", "/", "»", "«", "‹", "›", "<", ">"]; }; }), (function (module, exports) {
        function baseIsNaN(value) { return value !== value; }
        module.exports = baseIsNaN;
    }), (function (module, exports) {
        function strictIndexOf(array, value, fromIndex) {
            var index = fromIndex - 1, length = array.length; while (++index < length) { if (array[index] === value) { return index; } }
            return -1;
        }
        module.exports = strictIndexOf;
    }), (function (module, exports, __webpack_require__) {
        var arrayMap = __webpack_require__(24); function baseValues(object, props) { return arrayMap(props, function (key) { return object[key]; }); }
        module.exports = baseValues;
    }), (function (module, exports, __webpack_require__) {
        "use strict"; var getSentences = __webpack_require__(22); var stripHTMLTags = __webpack_require__(7).stripFullTags; var getLanguage = __webpack_require__(20); var Sentence = __webpack_require__(388); var getSentencePartsEnglish = __webpack_require__(389); var determinePassivesEnglish = __webpack_require__(401); var getSentencePartsGerman = __webpack_require__(402); var determinePassivesGerman = __webpack_require__(409); var forEach = __webpack_require__(1); var getSentenceParts = function getSentenceParts(sentence, language) {
            var sentenceParts = []; switch (language) { case "de": sentenceParts = getSentencePartsGerman(sentence); break; case "en": default: sentenceParts = getSentencePartsEnglish(sentence); break; }
            return sentenceParts;
        }; var determinePassives = function determinePassives(sentencePart, language) { switch (language) { case "de": sentencePart.setPassive(determinePassivesGerman(sentencePart.getSentencePartText(), sentencePart.getAuxiliaries())); break; case "en": default: sentencePart.setPassive(determinePassivesEnglish(sentencePart.getSentencePartText(), sentencePart.getAuxiliaries())); break; } }; module.exports = function (paper) { var text = paper.getText(); var locale = paper.getLocale(); var language = getLanguage(locale); var sentences = getSentences(text); var sentenceObjects = []; forEach(sentences, function (sentence) { sentenceObjects.push(new Sentence(sentence, locale)); }); var passiveSentences = []; forEach(sentenceObjects, function (sentence) { var strippedSentence = stripHTMLTags(sentence.getSentenceText()).toLocaleLowerCase(); var sentenceParts = getSentenceParts(strippedSentence, language); var passive = false; forEach(sentenceParts, function (sentencePart) { determinePassives(sentencePart, language); passive = passive || sentencePart.isPassive(); }); if (passive === true) { passiveSentences.push(sentence.getSentenceText()); } }); return { total: sentences.length, passives: passiveSentences }; };
    }), (function (module, exports, __webpack_require__) { "use strict"; var defaultAttributes = { locale: "en_US" }; var Sentence = function Sentence(sentence, locale) { this._sentenceText = sentence || ""; this._locale = locale || defaultAttributes.locale; this._isPassive = false; }; Sentence.prototype.getSentenceText = function () { return this._sentenceText; }; Sentence.prototype.getLocale = function () { return this._locale; }; module.exports = Sentence; }), (function (module, exports, __webpack_require__) {
        "use strict"; var verbEndingInIngRegex = /\w+ing(?=$|[ \n\r\t\.,'\(\)\"\+\-;!?:\/»«‹›<>])/ig; var stopCharacterRegex = /(?!([a-zA-Z]))([:,]|('ll)|('ve))(?=[ \n\r\t\'\"\+\-»«‹›<>])/ig; var ingExclusionArray = ["king", "cling", "ring", "being", "thing", "something", "anything"]; var indices = __webpack_require__(108); var getIndicesOfList = indices.getIndicesByWordList; var filterIndices = indices.filterIndices; var sortIndices = indices.sortIndices; var stripSpaces = __webpack_require__(8); var normalizeSingleQuotes = __webpack_require__(74).normalizeSingle; var arrayToRegex = __webpack_require__(51); var auxiliaries = __webpack_require__(109)().all; var SentencePart = __webpack_require__(390); var auxiliaryRegex = arrayToRegex(auxiliaries); var stopwords = __webpack_require__(400)(); var filter = __webpack_require__(6); var isUndefined = __webpack_require__(3); var includes = __webpack_require__(29); var map = __webpack_require__(2); var getVerbsEndingInIng = function getVerbsEndingInIng(sentence) { var matches = sentence.match(verbEndingInIngRegex) || []; return filter(matches, function (match) { return !includes(ingExclusionArray, stripSpaces(match)); }); }; var getStopCharacters = function getStopCharacters(sentence) {
            var match; var matches = []; stopCharacterRegex.lastIndex = 0; while ((match = stopCharacterRegex.exec(sentence)) !== null) { matches.push({ index: match.index, match: match[0] }); }
            return matches;
        }; var getSentenceBreakers = function getSentenceBreakers(sentence) { sentence = sentence.toLocaleLowerCase(); var auxiliaryIndices = getIndicesOfList(auxiliaries, sentence); var stopwordIndices = getIndicesOfList(stopwords, sentence); var stopCharacterIndices = getStopCharacters(sentence); var ingVerbs = getVerbsEndingInIng(sentence); var ingVerbsIndices = getIndicesOfList(ingVerbs, sentence); var indices = [].concat(auxiliaryIndices, stopwordIndices, ingVerbsIndices, stopCharacterIndices); indices = filterIndices(indices); return sortIndices(indices); }; var getAuxiliaryMatches = function getAuxiliaryMatches(sentencePart) { var auxiliaryMatches = sentencePart.match(auxiliaryRegex) || []; return map(auxiliaryMatches, function (auxiliaryMatch) { return stripSpaces(auxiliaryMatch); }); }; var getSentenceParts = function getSentenceParts(sentence) {
            var sentenceParts = []; sentence = normalizeSingleQuotes(sentence); if (sentence.match(auxiliaryRegex) === null) { return sentenceParts; }
            var indices = getSentenceBreakers(sentence); for (var i = 0; i < indices.length; i++) {
                var endIndex = sentence.length; if (!isUndefined(indices[i + 1])) { endIndex = indices[i + 1].index; }
                var sentencePart = stripSpaces(sentence.substr(indices[i].index, endIndex - indices[i].index)); var auxiliaryMatches = getAuxiliaryMatches(sentencePart); if (auxiliaryMatches.length !== 0) { sentenceParts.push(new SentencePart(sentencePart, auxiliaryMatches)); }
            }
            return sentenceParts;
        }; module.exports = function (sentence) { return getSentenceParts(sentence); };
    }), (function (module, exports, __webpack_require__) { "use strict"; var SentencePart = __webpack_require__(186); var getParticiples = __webpack_require__(187); var EnglishSentencePart = function EnglishSentencePart(sentencePartText, auxiliaries, locale) { SentencePart.call(this, sentencePartText, auxiliaries, locale); }; __webpack_require__(14).inherits(EnglishSentencePart, SentencePart); EnglishSentencePart.prototype.getParticiples = function () { return getParticiples(this.getSentencePartText(), this.getAuxiliaries()); }; module.exports = EnglishSentencePart; }), (function (module, exports, __webpack_require__) { "use strict"; var find = __webpack_require__(103); var irregulars = __webpack_require__(392)(); var regularParticiples = function regularParticiples(word) { var regularParticiplesRegex = /\w+ed($|[ \n\r\t\.,'\(\)\"\+\-;!?:\/»«‹›<>])/ig; return word.match(regularParticiplesRegex) || []; }; var irregularParticiples = function irregularParticiples(word) { var matches = []; find(irregulars, function (currentWord) { if (currentWord === word) { matches.push(currentWord); } }); return matches; }; module.exports = function () { return { regularParticiples: regularParticiples, irregularParticiples: irregularParticiples }; }; }), (function (module, exports, __webpack_require__) { "use strict"; module.exports = function () { return ["arisen", "awoken", "reawoken", "babysat", "backslid", "backslidden", "beat", "beaten", "become", "begun", "bent", "unbent", "bet", "bid", "outbid", "rebid", "underbid", "overbid", "bidden", "bitten", "blown", "bought", "overbought", "bound", "unbound", "rebound", "broadcast", "rebroadcast", "broken", "brought", "browbeat", "browbeaten", "built", "prebuilt", "rebuilt", "overbuilt", "burnt", "burst", "bust", "cast", "miscast", "recast", "caught", "chosen", "clung", "come", "overcome", "cost", "crept", "cut", "undercut", "recut", "daydreamt", "dealt", "misdealt", "redealt", "disproven", "done", "predone", "outdone", "misdone", "redone", "overdone", "undone", "drawn", "outdrawn", "redrawn", "overdrawn", "dreamt", "driven", "outdriven", "drunk", "outdrunk", "overdrunk", "dug", "dwelt", "eaten", "overeaten", "fallen", "felt", "fit", "refit", "retrofit", "flown", "outflown", "flung", "forbidden", "forecast", "foregone", "foreseen", "foretold", "forgiven", "forgotten", "forsaken", "fought", "outfought", "found", "frostbitten", "frozen", "unfrozen", "given", "gone", "undergone", "gotten", "ground", "reground", "grown", "outgrown", "regrown", "had", "handwritten", "heard", "reheard", "misheard", "overheard", "held", "hewn", "hidden", "unhidden", "hit", "hung", "rehung", "overhung", "unhung", "hurt", "inlaid", "input", "interwound", "interwoven", "jerry-built", "kept", "knelt", "knit", "reknit", "unknit", "known", "laid", "mislaid", "relaid", "overlaid", "lain", "underlain", "leant", "leapt", "outleapt", "learnt", "unlearnt", "relearnt", "mislearnt", "left", "lent", "let", "lip-read", "lit", "relit", "lost", "made", "premade", "remade", "meant", "met", "mown", "offset", "paid", "prepaid", "repaid", "overpaid", "partaken", "proofread", "proven", "put", "quick-frozen", "quit", "read", "misread", "reread", "retread", "rewaken", "rid", "ridden", "outridden", "overridden", "risen", "roughcast", "run", "outrun", "rerun", "overrun", "rung", "said", "sand-cast", "sat", "outsat", "sawn", "seen", "overseen", "sent", "resent", "set", "preset", "reset", "misset", "sewn", "resewn", "oversewn", "unsewn", "shaken", "shat", "shaven", "shit", "shone", "outshone", "shorn", "shot", "outshot", "overshot", "shown", "shrunk", "preshrunk", "shut", "sight-read", "slain", "slept", "outslept", "overslept", "slid", "slit", "slung", "unslung", "slunk", "smelt", "outsmelt", "snuck", "sold", "undersold", "presold", "outsold", "resold", "oversold", "sought", "sown", "spat", "spelt", "misspelt", "spent", "underspent", "outspent", "misspent", "overspent", "spilt", "overspilt", "spit", "split", "spoilt", "spoken", "outspoken", "misspoken", "overspoken", "spread", "sprung", "spun", "unspun", "stolen", "stood", "understood", "misunderstood", "strewn", "stricken", "stridden", "striven", "struck", "strung", "unstrung", "stuck", "unstuck", "stung", "stunk", "sublet", "sunburnt", "sung", "outsung", "sunk", "sweat", "swept", "swollen", "sworn", "outsworn", "swum", "outswum", "swung", "taken", "undertaken", "mistaken", "retaken", "overtaken", "taught", "mistaught", "retaught", "telecast", "test-driven", "test-flown", "thought", "outthought", "rethought", "overthought", "thrown", "outthrown", "overthrown", "thrust", "told", "retold", "torn", "retorn", "trod", "trodden", "typecast", "typeset", "upheld", "upset", "waylaid", "wept", "wet", "rewet", "withdrawn", "withheld", "withstood", "woken", "won", "rewon", "worn", "reworn", "wound", "rewound", "overwound", "unwound", "woven", "rewoven", "unwoven", "written", "typewritten", "underwritten", "outwritten", "miswritten", "rewritten", "overwritten", "wrung"]; }; }), (function (module, exports, __webpack_require__) {
        "use strict"; var Participle = __webpack_require__(188); var nonVerbsEndingEd = __webpack_require__(396)(); var getWordIndices = __webpack_require__(397); var arrayToRegex = __webpack_require__(51); var cannotDirectlyPrecedePassiveParticiple = __webpack_require__(111)().cannotDirectlyPrecedePassiveParticiple; var cannotBeBetweenAuxiliaryAndParticiple = __webpack_require__(111)().cannotBeBetweenPassiveAuxiliaryAndParticiple; var forEach = __webpack_require__(1); var includes = __webpack_require__(29); var isEmpty = __webpack_require__(10); var intersection = __webpack_require__(190); var directPrecedenceExceptionRegex = arrayToRegex(cannotDirectlyPrecedePassiveParticiple); var precedenceExceptionRegex = arrayToRegex(cannotBeBetweenAuxiliaryAndParticiple); var irregularExclusionArray = ["get", "gets", "getting", "got", "gotten"]; var includesIndex = function includesIndex(precedingWords, participleIndex) {
            if (isEmpty(precedingWords)) { return false; }
            var precedingWordsEndIndices = []; forEach(precedingWords, function (precedingWord) { var precedingWordsEndIndex = precedingWord.index + precedingWord.match.length + 1; precedingWordsEndIndices.push(precedingWordsEndIndex); }); return includes(precedingWordsEndIndices, participleIndex);
        }; var precedesIndex = function precedesIndex(precedingWords, participleIndex) {
            if (isEmpty(precedingWords)) { return false; }
            var precedingWordsIndices = []; forEach(precedingWords, function (precedingWord) { var precedingWordsIndex = precedingWord.index; precedingWordsIndices.push(precedingWordsIndex); }); var matches = []; forEach(precedingWordsIndices, function (precedingWordsIndex) { if (precedingWordsIndex + 1 < participleIndex) { matches.push(precedingWordsIndex); } }); if (matches.length) { return true; }
            return false;
        }; var EnglishParticiple = function EnglishParticiple(participle, sentencePart, attributes) { Participle.call(this, participle, sentencePart, attributes); this.checkException(); }; __webpack_require__(14).inherits(EnglishParticiple, Participle); EnglishParticiple.prototype.checkException = function () {
            if (isEmpty(this.getParticiple())) { this.setSentencePartPassiveness(false); return; }
            this.setSentencePartPassiveness(this.isPassive());
        }; EnglishParticiple.prototype.isPassive = function () { var sentencePart = this.getSentencePart(); var participleIndex = sentencePart.indexOf(this.getParticiple()); return !this.isNonVerbEndingEd() && !this.hasRidException() && !this.directPrecedenceException(sentencePart, participleIndex) && !this.precedenceException(sentencePart, participleIndex); }; EnglishParticiple.prototype.isNonVerbEndingEd = function () {
            if (this.getType() === "irregular") { return false; }
            return includes(nonVerbsEndingEd, this.getParticiple());
        }; EnglishParticiple.prototype.hasRidException = function () {
            if (this.getParticiple() === "rid") { var auxiliaries = this.getAuxiliaries(); return !isEmpty(intersection(irregularExclusionArray, auxiliaries)); }
            return false;
        }; EnglishParticiple.prototype.directPrecedenceException = function (sentencePart, participleIndex) { var directPrecedenceExceptionMatch = getWordIndices(sentencePart, directPrecedenceExceptionRegex); return includesIndex(directPrecedenceExceptionMatch, participleIndex); }; EnglishParticiple.prototype.precedenceException = function (sentencePart, participleIndex) { var precedenceExceptionMatch = getWordIndices(sentencePart, precedenceExceptionRegex); return precedesIndex(precedenceExceptionMatch, participleIndex); }; module.exports = EnglishParticiple;
    }), (function (module, exports, __webpack_require__) { var copyObject = __webpack_require__(38), createAssigner = __webpack_require__(99), keysIn = __webpack_require__(49); var assignInWith = createAssigner(function (object, source, srcIndex, customizer) { copyObject(source, keysIn(source), object, customizer); }); module.exports = assignInWith; }), (function (module, exports, __webpack_require__) {
        var eq = __webpack_require__(35); var objectProto = Object.prototype; var hasOwnProperty = objectProto.hasOwnProperty; function customDefaultsAssignIn(objValue, srcValue, key, object) {
            if (objValue === undefined || (eq(objValue, objectProto[key]) && !hasOwnProperty.call(object, key))) { return srcValue; }
            return objValue;
        }
        module.exports = customDefaultsAssignIn;
    }), (function (module, exports, __webpack_require__) { "use strict"; module.exports = function () { return ["ablebodied", "abovementioned", "absentminded", "accoladed", "accompanied", "acculturized", "accursed", "acerated", "acerbated", "acetylized", "achromatised", "achromatized", "acidified", "acned", "actualised", "adrenalised", "adulated", "adversed", "aestheticised", "affectioned", "affined", "affricated", "aforementioned", "agerelated", "aggrieved", "airbed", "aircooled", "airspeed", "alcoholized", "alcoved", "alkalised", "allianced", "aluminized", "alveolated", "ambered", "ammonified", "amplified", "anagrammatised", "anagrammatized", "anathematised", "aniseed", "ankled", "annualized", "anonymised", "anthologized", "antlered", "anucleated", "anviled", "anvilshaped", "apostrophised", "apostrophized", "appliqued", "apprized", "arbitrated", "armored", "articled", "ashamed", "assented", "atomised", "atrophied", "auricled", "auriculated", "aurified", "autopsied", "axled", "babied", "backhoed", "badmannered", "badtempered", "balustered", "baned", "barcoded", "bareboned", "barefooted", "barelegged", "barnacled", "based", "bayoneted", "beadyeyed", "beaked", "beaned", "beatified", "beautified", "beavered", "bed", "bedamned", "bedecked", "behoved", "belated", "bellbottomed", "bellshaped", "benighted", "bequeathed", "berried", "bespectacled", "bewhiskered", "bighearted", "bigmouthed", "bigoted", "bindweed", "binucleated", "biopsied", "bioturbed", "biped", "bipinnated", "birdfeed", "birdseed", "bisegmented", "bitterhearted", "blabbermouthed", "blackhearted", "bladed", "blankminded", "blearyeyed", "bleed", "blissed", "blobbed", "blondhaired", "bloodied", "bloodred", "bloodshed", "blueblooded", "boatshaped", "bobsled", "bodied", "boldhearted", "boogied", "boosed", "bosomed", "bottlefed", "bottlefeed", "bottlenecked", "bouldered", "bowlegged", "bowlshaped", "brandied", "bravehearted", "breastfed", "breastfeed", "breed", "brighteyed", "brindled", "broadhearted", "broadleaved", "broadminded", "brokenhearted", "broomed", "broomweed", "buccaned", "buckskinned", "bucktoothed", "buddied", "buffaloed", "bugeyed", "bugleweed", "bugweed", "bulletined", "bunked", "busied", "butterfingered", "cabbed", "caddied", "cairned", "calcified", "canalized", "candied", "cannulated", "canoed", "canopied", "canvased", "caped", "capsulated", "cassocked", "castellated", "catabolised", "catheterised", "caudated", "cellmediated", "cellulosed", "certified", "chagrined", "chambered", "chested", "chevroned", "chickenfeed", "chickenhearted", "chickweed", "chilblained", "childbed", "chinned", "chromatographed", "ciliated", "cindered", "cingulated", "circumstanced", "cisgendered", "citrullinated", "clappered", "clarified", "classified", "clawshaped", "claysized", "cleanhearted", "clearminded", "clearsighted", "cliched", "clodded", "cloistered", "closefisted", "closehearted", "closelipped", "closemouthed", "closeted", "cloudseed", "clubfooted", "clubshaped", "clued", "cockeyed", "codified", "coed", "coevolved", "coffined", "coiffed", "coinfected", "coldblooded", "coldhearted", "collateralised", "colonialised", "colorcoded", "colorised", "colourised", "columned", "commoditized", "compactified", "companioned", "complexioned", "conceited", "concerned", "concussed", "coneshaped", "congested", "contented", "convexed", "coralled", "corymbed", "cottonseed", "countrified", "countrybred", "courtmartialled", "coved", "coveralled", "cowshed", "cozied", "cragged", "crayoned", "credentialed", "creed", "crenulated", "crescentshaped", "cressweed", "crewed", "cricked", "crispated", "crossbarred", "crossbed", "crossbred", "crossbreed", "crossclassified", "crosseyed", "crossfertilised", "crossfertilized", "crossindexed", "crosslegged", "crossshaped", "crossstratified", "crossstriated", "crotched", "crucified", "cruelhearted", "crutched", "cubeshaped", "cubified", "cuckolded", "cucumbershaped", "cumbered", "cuminseed", "cupshaped", "curated", "curded", "curfewed", "curlicued", "curlycued", "curried", "curtsied", "cyclized", "cylindershaped", "damed", "dandified", "dangered", "darkhearted", "daybed", "daylighted", "deacidified", "deacylated", "deadhearted", "deadlined", "deaminized", "deathbed", "decalcified", "decertified", "deckbed", "declassified", "declutched", "decolourated", "decreed", "deed", "deeprooted", "deepseated", "defensed", "defied", "deflexed", "deglamorised", "degunkified", "dehumidified", "deified", "deled", "delegitimised", "demoded", "demystified", "denasalized", "denazified", "denied", "denitrified", "denticulated", "deseed", "desexualised", "desposited", "detoxified", "deuced", "devitrified", "dewlapped", "dezincified", "diagonalised", "dialogued", "died", "digitated", "dignified", "dilled", "dimwitted", "diphthonged", "disaffected", "disaggregated", "disarrayed", "discalced", "discolorated", "discolourated", "discshaped", "diseased", "disembodied", "disencumbered", "disfranchised", "diskshaped", "disproportionated", "disproportioned", "disqualified", "distempered", "districted", "diversified", "diverticulated", "divested", "divvied", "dizzied", "dogged", "dogsbodied", "dogsled", "domeshaped", "domiciled", "dormered", "doublebarrelled", "doublestranded", "doublewalled", "downhearted", "duckbilled", "eared", "echeloned", "eddied", "edified", "eggshaped", "elasticated", "electrified", "elegized", "embed", "embodied", "emceed", "empaneled", "empanelled", "emptyhearted", "emulsified", "engined", "ennobled", "envied", "enzymecatalysed", "enzymecatalyzed", "epitomised", "epoxidized", "epoxied", "etherised", "etherized", "evilhearted", "evilminded", "exceed", "excited", "exemplified", "exponentiated", "expurgated", "extravasated", "extraverted", "extroverted", "fabled", "facelifted", "facsimiled", "fainthearted", "falcated", "falsehearted", "falsified", "famed", "fancified", "fanged", "fanshaped", "fantasied", "farsighted", "fated", "fatted", "fazed", "featherbed", "fed", "federalized", "feeblehearted", "feebleminded", "feeblewitted", "feed", "fendered", "fenestrated", "ferried", "fevered", "fibered", "fibred", "ficklehearted", "fiercehearted", "figged", "filigreed", "filterfeed", "fireweed", "firmhearted", "fissured", "flanged", "flanneled", "flannelled", "flatbed", "flatfooted", "flatted", "flaxenhaired", "flaxseed", "flaxweed", "flighted", "floodgenerated", "flowerbed", "fluidised", "fluidized", "flurried", "fobbed", "fonded", "forcefeed", "foreshortened", "foresighted", "forkshaped", "formfeed", "fortified", "fortressed", "foulmouthed", "foureyed", "foxtailed", "fractionalised", "fractionalized", "frankhearted", "freed", "freehearted", "freespirited", "frenzied", "friezed", "frontiered", "fructified", "frumped", "fullblooded", "fullbodied", "fullfledged", "fullhearted", "funnelshaped", "furnaced", "gaitered", "galleried", "gangliated", "ganglionated", "gangrened", "gargoyled", "gasified", "gaunted", "gauntleted", "gauzed", "gavelled", "gelatinised", "gemmed", "genderized", "gentled", "gentlehearted", "gerrymandered", "gladhearted", "glamored", "globed", "gloried", "glorified", "glycosylated", "goateed", "gobletshaped", "godspeed", "goodhearted", "goodhumored", "goodhumoured", "goodnatured", "goodtempered", "goosed", "goosenecked", "goutweed", "grainfed", "grammaticalized", "grapeseed", "gratified", "graved", "gravelbed", "grayhaired", "greathearted", "greed", "greenweed", "grommeted", "groundspeed", "groved", "gruffed", "guiled", "gulled", "gumshoed", "gunkholed", "gussied", "guyed", "gyrostabilized", "hackneyed", "hagged", "haired", "halfcivilized", "halfhearted", "halfwitted", "haloed", "handballed", "handfed", "handfeed", "hardcoded", "hardhearted", "hardnosed", "hared", "harelipped", "hasted", "hatred", "haunched", "hawkeyed", "hayseed", "hayweed", "hearsed", "hearted", "heartshaped", "heavenlyminded", "heavyfooted", "heavyhearted", "heed", "heired", "heisted", "helicoptered", "helmed", "helmeted", "hemagglutinated", "hemolyzed", "hempseed", "hempweed", "heparinised", "heparinized", "herbed", "highheeled", "highminded", "highpriced", "highspeed", "highspirited", "hilled", "hipped", "hispanicised", "hocked", "hoed", "hogweed", "holstered", "homaged", "hoodooed", "hoofed", "hooknosed", "hooved", "horned", "horrified", "horseshoed", "horseweed", "hotbed", "hotblooded", "hothearted", "hotted", "hottempered", "hued", "humansized", "humidified", "humped", "hundred", "hutched", "hyperinflated", "hyperpigmented", "hyperstimulated", "hypertrophied", "hyphened", "hypophysectomised", "hypophysectomized", "hypopigmented", "hypostatised", "hysterectomized", "iconified", "iconised", "iconized", "ideologised", "illbred", "illconceived", "illdefined", "illdisposed", "illequipped", "illfated", "illfavored", "illfavoured", "illflavored", "illfurnished", "illhumored", "illhumoured", "illimited", "illmannered", "illnatured", "illomened", "illproportioned", "illqualified", "illscented", "illtempered", "illumed", "illusioned", "imbed", "imbossed", "imbued", "immatured", "impassioned", "impenetrated", "imperfected", "imperialised", "imperturbed", "impowered", "imputed", "inarticulated", "inbred", "inbreed", "incapsulated", "incased", "incrustated", "incrusted", "indebted", "indeed", "indemnified", "indentured", "indigested", "indisposed", "inexperienced", "infrared", "intensified", "intentioned", "interbedded", "interbred", "interbreed", "interluded", "introverted", "inured", "inventoried", "iodinated", "iodised", "irked", "ironfisted", "ironweed", "itchweed", "ivied", "ivyweed", "jagged", "jellified", "jerseyed", "jetlagged", "jetpropelled", "jeweled", "jewelled", "jewelweed", "jiggered", "jimmyweed", "jimsonweed", "jointweed", "joyweed", "jungled", "juried", "justiceweed", "justified", "karstified", "kerchiefed", "kettleshaped", "kibbled", "kidneyshaped", "kimonoed", "kindhearted", "kindred", "kingsized", "kirtled", "knacked", "knapweed", "kneed", "knobbed", "knobweed", "knopweed", "knotweed", "lakebed", "lakeweed", "lamed", "lamellated", "lanceshaped", "lanceted", "landbased", "lapeled", "lapelled", "largehearted", "lariated", "lased", "latticed", "lauded", "lavaged", "lavendered", "lawned", "led", "lefteyed", "legitimatised", "legitimatized", "leisured", "lensshaped", "leveed", "levied", "lichened", "lichenized", "lidded", "lifesized", "lightfingered", "lightfooted", "lighthearted", "lightminded", "lightspeed", "lignified", "likeminded", "lilylivered", "limbed", "linearised", "linearized", "linefeed", "linseed", "lionhearted", "liquefied", "liquified", "lithified", "liveried", "lobbied", "located", "locoweed", "longarmed", "longhaired", "longhorned", "longlegged", "longnecked", "longsighted", "longwinded", "lopsided", "loudmouthed", "louvered", "louvred", "lowbred", "lowpriced", "lowspirited", "lozenged", "lunated", "lyrated", "lysinated", "maced", "macroaggregated", "macrodissected", "maculated", "madweed", "magnified", "maidenweed", "maladapted", "maladjusted", "malnourished", "malrotated", "maned", "mannered", "manuevered", "manyhued", "manyshaped", "manysided", "masted", "mealymouthed", "meanspirited", "membered", "membraned", "metaled", "metalized", "metallised", "metallized", "metamerized", "metathesized", "meted", "methylated", "mettled", "microbrecciated", "microminiaturized", "microstratified", "middleaged", "midsized", "miffed", "mildhearted", "milkweed", "miniskirted", "misactivated", "misaligned", "mischiefed", "misclassified", "misdeed", "misdemeaned", "mismannered", "misnomered", "misproportioned", "miswired", "mitred", "mitted", "mittened", "moneyed", "monocled", "mononucleated", "monospaced", "monotoned", "monounsaturated", "mortified", "moseyed", "motorised", "motorized", "moussed", "moustached", "muddied", "mugweed", "multiarmed", "multibarreled", "multibladed", "multicelled", "multichambered", "multichanneled", "multichannelled", "multicoated", "multidirected", "multiengined", "multifaceted", "multilaminated", "multilaned", "multilayered", "multilobed", "multilobulated", "multinucleated", "multipronged", "multisegmented", "multisided", "multispeed", "multistemmed", "multistoried", "multitalented", "multitoned", "multitowered", "multivalued", "mummied", "mummified", "mustached", "mustachioed", "mutinied", "myelinated", "mystified", "mythicised", "naked", "narcotised", "narrowminded", "natured", "neaped", "nearsighted", "necrosed", "nectared", "need", "needleshaped", "newfangled", "newlywed", "nibbed", "nimblewitted", "nippled", "nixed", "nobled", "noduled", "noised", "nonaccented", "nonactivated", "nonadsorbed", "nonadulterated", "nonaerated", "nonaffiliated", "nonaliased", "nonalienated", "nonaligned", "nonarchived", "nonarmored", "nonassociated", "nonattenuated", "nonblackened", "nonbreastfed", "nonbrecciated", "nonbuffered", "nonbuttered", "noncarbonated", "noncarbonized", "noncatalogued", "noncatalyzed", "noncategorized", "noncertified", "nonchlorinated", "nonciliated", "noncircumcised", "noncivilized", "nonclassified", "noncoated", "noncodified", "noncoerced", "noncommercialized", "noncommissioned", "noncompacted", "noncompiled", "noncomplicated", "noncomposed", "noncomputed", "noncomputerized", "nonconcerted", "nonconditioned", "nonconfirmed", "noncongested", "nonconjugated", "noncooled", "noncorrugated", "noncoupled", "noncreated", "noncrowded", "noncultured", "noncurated", "noncushioned", "nondecoded", "nondecomposed", "nondedicated", "nondeferred", "nondeflated", "nondegenerated", "nondegraded", "nondelegated", "nondelimited", "nondelineated", "nondemarcated", "nondeodorized", "nondeployed", "nonderivatized", "nonderived", "nondetached", "nondetailed", "nondifferentiated", "nondigested", "nondigitized", "nondilapidated", "nondilated", "nondimensionalised", "nondimensionalized", "nondirected", "nondisabled", "nondisciplined", "nondispersed", "nondisputed", "nondisqualified", "nondisrupted", "nondisseminated", "nondissipated", "nondissolved", "nondistressed", "nondistributed", "nondiversified", "nondiverted", "nondocumented", "nondomesticated", "nondoped", "nondrafted", "nondrugged", "nondubbed", "nonducted", "nonearthed", "noneclipsed", "nonedged", "nonedited", "nonelasticized", "nonelectrified", "nonelectroplated", "nonelectroporated", "nonelevated", "noneliminated", "nonelongated", "nonembedded", "nonembodied", "nonemphasized", "nonencapsulated", "nonencoded", "nonencrypted", "nonendangered", "nonengraved", "nonenlarged", "nonenriched", "nonentangled", "nonentrenched", "nonepithelized", "nonequilibrated", "nonestablished", "nonetched", "nonethoxylated", "nonethylated", "nonetiolated", "nonexaggerated", "nonexcavated", "nonexhausted", "nonexperienced", "nonexpired", "nonfabricated", "nonfalsified", "nonfeathered", "nonfeatured", "nonfed", "nonfederated", "nonfeed", "nonfenestrated", "nonfertilized", "nonfilamented", "nonfinanced", "nonfinished", "nonfinned", "nonfissured", "nonflagellated", "nonflagged", "nonflared", "nonflavored", "nonfluidized", "nonfluorinated", "nonfluted", "nonforested", "nonformalized", "nonformatted", "nonfragmented", "nonfragranced", "nonfranchised", "nonfreckled", "nonfueled", "nonfumigated", "nonfunctionalized", "nonfunded", "nongalvanized", "nongated", "nongelatinized", "nongendered", "nongeneralized", "nongenerated", "nongifted", "nonglazed", "nonglucosated", "nonglucosylated", "nonglycerinated", "nongraded", "nongrounded", "nonhalogenated", "nonhandicapped", "nonhospitalised", "nonhospitalized", "nonhydrated", "nonincorporated", "nonindexed", "noninfected", "noninfested", "noninitialized", "noninitiated", "noninoculated", "noninseminated", "noninstitutionalized", "noninsured", "nonintensified", "noninterlaced", "noninterpreted", "nonintroverted", "noninvestigated", "noninvolved", "nonirrigated", "nonisolated", "nonisomerized", "nonissued", "nonitalicized", "nonitemized", "noniterated", "nonjaded", "nonlabelled", "nonlaminated", "nonlateralized", "nonlayered", "nonlegalized", "nonlegislated", "nonlesioned", "nonlexicalized", "nonliberated", "nonlichenized", "nonlighted", "nonlignified", "nonlimited", "nonlinearized", "nonlinked", "nonlobed", "nonlobotomized", "nonlocalized", "nonlysed", "nonmachined", "nonmalnourished", "nonmandated", "nonmarginalized", "nonmassaged", "nonmatriculated", "nonmatted", "nonmatured", "nonmechanized", "nonmedicated", "nonmedullated", "nonmentioned", "nonmetabolized", "nonmetallized", "nonmetastasized", "nonmetered", "nonmethoxylated", "nonmilled", "nonmineralized", "nonmirrored", "nonmodeled", "nonmoderated", "nonmodified", "nonmonetized", "nonmonitored", "nonmortgaged", "nonmotorized", "nonmottled", "nonmounted", "nonmultithreaded", "nonmutilated", "nonmyelinated", "nonnormalized", "nonnucleated", "nonobjectified", "nonobligated", "nonoccupied", "nonoiled", "nonopinionated", "nonoxygenated", "nonpaginated", "nonpaired", "nonparalyzed", "nonparameterized", "nonparasitized", "nonpasteurized", "nonpatterned", "nonphased", "nonphosphatized", "nonphosphorized", "nonpierced", "nonpigmented", "nonpiloted", "nonpipelined", "nonpitted", "nonplussed", "nonpuffed", "nonrandomized", "nonrated", "nonrefined", "nonregistered", "nonregulated", "nonrelated", "nonretarded", "nonsacred", "nonsalaried", "nonsanctioned", "nonsaturated", "nonscented", "nonscheduled", "nonseasoned", "nonsecluded", "nonsegmented", "nonsegregated", "nonselected", "nonsolidified", "nonspecialized", "nonspored", "nonstandardised", "nonstandardized", "nonstratified", "nonstressed", "nonstriated", "nonstriped", "nonstructured", "nonstylised", "nonstylized", "nonsubmerged", "nonsubscripted", "nonsubsidised", "nonsubsidized", "nonsubstituted", "nonsyndicated", "nonsynthesised", "nontabulated", "nontalented", "nonthreaded", "nontinted", "nontolerated", "nontranslated", "nontunnelled", "nonunified", "nonunionised", "nonupholstered", "nonutilised", "nonutilized", "nonvalued", "nonvaried", "nonverbalized", "nonvitrified", "nonvolatilised", "nonvolatilized", "normed", "nosebleed", "notated", "notified", "nuanced", "nullified", "numerated", "oarweed", "objectified", "obliqued", "obtunded", "occupied", "octupled", "odored", "oilseed", "oinked", "oldfashioned", "onesided", "oophorectomized", "opaqued", "openhearted", "openminded", "openmouthed", "opiated", "opinionated", "oracled", "oreweed", "ossified", "outbreed", "outmoded", "outrigged", "outriggered", "outsized", "outskated", "outspeed", "outtopped", "outtrumped", "outvoiced", "outweed", "ovated", "overadorned", "overaged", "overalled", "overassured", "overbred", "overbreed", "overcomplicated", "overdamped", "overdetailed", "overdiversified", "overdyed", "overequipped", "overfatigued", "overfed", "overfeed", "overindebted", "overintensified", "overinventoried", "overmagnified", "overmodified", "overpreoccupied", "overprivileged", "overproportionated", "overqualified", "overseed", "oversexed", "oversimplified", "oversized", "oversophisticated", "overstudied", "oversulfated", "ovicelled", "ovoidshaped", "ozonated", "pacified", "packeted", "palatalized", "paled", "palsied", "paned", "panicled", "parabled", "parallelepiped", "parallelized", "parallelopiped", "parenthesised", "parodied", "parqueted", "passioned", "paunched", "pauperised", "pedigreed", "pedimented", "pedunculated", "pegged", "peglegged", "penanced", "pencilshaped", "permineralized", "personified", "petrified", "photodissociated", "photoduplicated", "photoed", "photoinduced", "photolysed", "photolyzed", "pied", "pigeoned", "pigtailed", "pigweed", "pilastered", "pillared", "pilloried", "pimpled", "pinealectomised", "pinealectomized", "pinfeathered", "pinnacled", "pinstriped", "pixellated", "pixilated", "pixillated", "plainclothed", "plantarflexed", "pled", "plumaged", "pocked", "pokeweed", "polychlorinated", "polyunsaturated", "ponytailed", "pooched", "poorspirited", "popeyed", "poppyseed", "porcelainized", "porched", "poshed", "pottered", "poxed", "preachified", "precertified", "preclassified", "preconized", "preinoculated", "premed", "prenotified", "preoccupied", "preposed", "prequalified", "preshaped", "presignified", "prespecified", "prettified", "pried", "principled", "proceed", "prophesied", "propounded", "prosed", "protonated", "proudhearted", "proxied", "pulpified", "pumpkinseed", "puppied", "purebred", "pured", "pureed", "purified", "pustuled", "putrefied", "pyjamaed", "quadruped", "qualified", "quantified", "quantised", "quantized", "quarried", "queried", "questoned", "quicktempered", "quickwitted", "quiesced", "quietened", "quizzified", "racemed", "radiosensitised", "ragweed", "raindrenched", "ramped", "rapeseed", "rarefied", "rarified", "ratified", "razoredged", "reaccelerated", "reaccompanied", "reachieved", "reacknowledged", "readdicted", "readied", "reamplified", "reannealed", "reassociated", "rebadged", "rebiopsied", "recabled", "recategorised", "receipted", "recentred", "recertified", "rechoreographed", "reclarified", "reclassified", "reconferred", "recrystalized", "rectified", "recursed", "red", "redblooded", "redefied", "redenied", "rednecked", "redshifted", "redweed", "redyed", "reed", "reembodied", "reenlighted", "refeed", "refereed", "reflexed", "refortified", "refronted", "refuged", "reglorified", "reimpregnated", "reinitialized", "rejustified", "related", "reliquefied", "remedied", "remodified", "remonetized", "remythologized", "renotified", "renullified", "renumerated", "reoccupied", "repacified", "repurified", "reputed", "requalified", "rescinded", "reseed", "reshoed", "resolidified", "resorbed", "respecified", "restudied", "retabulated", "reticulated", "retinted", "retreed", "retroacted", "reunified", "reverified", "revested", "revivified", "rewed", "ridgepoled", "riffled", "rightminded", "rigidified", "rinded", "riped", "rited", "ritualised", "riverbed", "rivered", "roached", "roadbed", "robotised", "robotized", "romanized", "rosetted", "rosined", "roughhearted", "rubied", "ruddied", "runcinated", "russeted", "sabled", "sabred", "sabretoothed", "sacheted", "sacred", "saddlebred", "sainted", "salaried", "samoyed", "sanctified", "satellited", "savvied", "sawtoothed", "scandalled", "scarified", "scarped", "sceptred", "scissored", "screed", "screwshaped", "scrupled", "sculked", "scurried", "scuttled", "seabed", "seaweed", "seed", "seedbed", "selfassured", "selforganized", "semicivilized", "semidetached", "semidisassembled", "semidomesticated", "semipetrified", "semipronated", "semirefined", "semivitrified", "sentineled", "sepaled", "sepalled", "sequinned", "sexed", "shagged", "shaggycoated", "shaggyhaired", "shaled", "shammed", "sharpangled", "sharpclawed", "sharpcornered", "sharpeared", "sharpedged", "sharpeyed", "sharpflavored", "sharplimbed", "sharpnosed", "sharpsighted", "sharptailed", "sharptongued", "sharptoothed", "sharpwitted", "sharpworded", "shed", "shellbed", "shieldshaped", "shimmied", "shinned", "shirted", "shirtsleeved", "shoed", "shortbeaked", "shortbilled", "shortbodied", "shorthaired", "shortlegged", "shortlimbed", "shortnecked", "shortnosed", "shortsighted", "shortsleeved", "shortsnouted", "shortstaffed", "shorttailed", "shorttempered", "shorttoed", "shorttongued", "shortwinded", "shortwinged", "shotted", "shred", "shrewsized", "shrined", "shrinkproofed", "sickbed", "sickleshaped", "sickleweed", "signalised", "signified", "silicified", "siliconized", "silkweed", "siltsized", "silvertongued", "simpleminded", "simplified", "singlebarreled", "singlebarrelled", "singlebed", "singlebladed", "singlebreasted", "singlecelled", "singlefooted", "singlelayered", "singleminded", "singleseeded", "singleshelled", "singlestranded", "singlevalued", "sissified", "sistered", "sixgilled", "sixmembered", "sixsided", "sixstoried", "skulled", "slickered", "slipcased", "slowpaced", "slowwitted", "slurried", "smallminded", "smoothened", "smoothtongued", "snaggletoothed", "snouted", "snowballed", "snowcapped", "snowshed", "snowshoed", "snubnosed", "so-called", "sofabed", "softhearted", "sogged", "soled", "solidified", "soliped", "sorbed", "souled", "spearshaped", "specified", "spectacled", "sped", "speeched", "speechified", "speed", "spied", "spiffied", "spindleshaped", "spiritualised", "spirted", "splayfooted", "spoonfed", "spoonfeed", "spoonshaped", "spreadeagled", "squarejawed", "squareshaped", "squareshouldered", "squaretoed", "squeegeed", "staled", "starshaped", "starspangled", "starstudded", "statechartered", "statesponsored", "statued", "steadied", "steampowered", "steed", "steelhearted", "steepled", "sterned", "stiffnecked", "stilettoed", "stimied", "stinkweed", "stirrupshaped", "stockinged", "storeyed", "storied", "stouthearted", "straitlaced", "stratified", "strawberryflavored", "streambed", "stressinduced", "stretchered", "strictured", "strongbodied", "strongboned", "strongflavored", "stronghearted", "stronglimbed", "strongminded", "strongscented", "strongwilled", "stubbled", "studied", "stultified", "stupefied", "styed", "stymied", "subclassified", "subcommissioned", "subminiaturised", "subsaturated", "subulated", "suburbanised", "suburbanized", "suburbed", "succeed", "sueded", "sugarrelated", "sulfurized", "sunbed", "superhardened", "superinfected", "supersimplified", "surefooted", "sweetscented", "swifted", "swordshaped", "syllabified", "syphilized", "tabularized", "talented", "tarpapered", "tautomerized", "teated", "teed", "teenaged", "teetotaled", "tenderhearted", "tentacled", "tenured", "termed", "ternated", "testbed", "testified", "theatricalised", "theatricalized", "themed", "thicketed", "thickskinned", "thickwalled", "thighed", "thimbled", "thimblewitted", "thonged", "thoroughbred", "thralled", "threated", "throated", "throughbred", "thyroidectomised", "thyroidectomized", "tiaraed", "ticktocked", "tidied", "tightassed", "tightfisted", "tightlipped", "timehonoured", "tindered", "tined", "tinselled", "tippytoed", "tiptoed", "titled", "toed", "tomahawked", "tonged", "toolshed", "toothplated", "toplighted", "torchlighted", "toughhearted", "traditionalized", "trajected", "tranced", "transgendered", "transliterated", "translocated", "transmogrified", "treadled", "treed", "treelined", "tressed", "trialled", "triangled", "trifoliated", "trifoliolated", "trilobed", "trucklebed", "truehearted", "trumpetshaped", "trumpetweed", "tuberculated", "tumbleweed", "tunnelshaped", "turbaned", "turreted", "turtlenecked", "tuskshaped", "tweed", "twigged", "typified", "ulcered", "ultracivilised", "ultracivilized", "ultracooled", "ultradignified", "ultradispersed", "ultrafiltered", "ultrared", "ultrasimplified", "ultrasophisticated", "unabandoned", "unabashed", "unabbreviated", "unabetted", "unabolished", "unaborted", "unabraded", "unabridged", "unabsolved", "unabsorbed", "unaccelerated", "unaccented", "unaccentuated", "unacclimatised", "unacclimatized", "unaccompanied", "unaccomplished", "unaccosted", "unaccredited", "unaccrued", "unaccumulated", "unaccustomed", "unacidulated", "unacquainted", "unacquitted", "unactivated", "unactuated", "unadapted", "unaddicted", "unadjourned", "unadjudicated", "unadjusted", "unadmonished", "unadopted", "unadored", "unadorned", "unadsorbed", "unadulterated", "unadvertised", "unaerated", "unaffiliated", "unaggregated", "unagitated", "unaimed", "unaired", "unaliased", "unalienated", "unaligned", "unallocated", "unalloyed", "unalphabetized", "unamassed", "unamortized", "unamplified", "unanaesthetised", "unanaesthetized", "unaneled", "unanesthetised", "unanesthetized", "unangered", "unannealed", "unannexed", "unannihilated", "unannotated", "unanointed", "unanticipated", "unappareled", "unappendaged", "unapportioned", "unapprenticed", "unapproached", "unappropriated", "unarbitrated", "unarched", "unarchived", "unarmored", "unarmoured", "unarticulated", "unascertained", "unashamed", "unaspirated", "unassembled", "unasserted", "unassessed", "unassociated", "unassorted", "unassuaged", "unastonished", "unastounded", "unatoned", "unattained", "unattainted", "unattenuated", "unattributed", "unauctioned", "unaudited", "unauthenticated", "unautographed", "unaverted", "unawaked", "unawakened", "unawarded", "unawed", "unbaffled", "unbaited", "unbalconied", "unbanded", "unbanished", "unbaptised", "unbaptized", "unbarreled", "unbarrelled", "unbattered", "unbeaded", "unbearded", "unbeneficed", "unbesotted", "unbetrayed", "unbetrothed", "unbiased", "unbiassed", "unbigoted", "unbilled", "unblackened", "unblanketed", "unblasphemed", "unblazoned", "unblistered", "unblockaded", "unbloodied", "unbodied", "unbonded", "unbothered", "unbounded", "unbracketed", "unbranded", "unbreaded", "unbrewed", "unbridged", "unbridled", "unbroached", "unbudgeted", "unbuffed", "unbuffered", "unburnished", "unbutchered", "unbuttered", "uncached", "uncaked", "uncalcified", "uncalibrated", "uncamouflaged", "uncamphorated", "uncanceled", "uncancelled", "uncapitalized", "uncarbonated", "uncarpeted", "uncased", "uncashed", "uncastrated", "uncatalogued", "uncatalysed", "uncatalyzed", "uncategorised", "uncatered", "uncaulked", "uncelebrated", "uncensored", "uncensured", "uncertified", "unchambered", "unchanneled", "unchannelled", "unchaperoned", "uncharacterized", "uncharted", "unchartered", "unchastened", "unchastised", "unchelated", "uncherished", "unchilled", "unchristened", "unchronicled", "uncircumcised", "uncircumscribed", "uncited", "uncivilised", "uncivilized", "unclarified", "unclassed", "unclassified", "uncleaved", "unclimbed", "unclustered", "uncluttered", "uncoagulated", "uncoded", "uncodified", "uncoerced", "uncoined", "uncollapsed", "uncollated", "uncolonised", "uncolonized", "uncolumned", "uncombined", "uncommented", "uncommercialised", "uncommercialized", "uncommissioned", "uncommitted", "uncompacted", "uncompartmentalized", "uncompartmented", "uncompensated", "uncompiled", "uncomplicated", "uncompounded", "uncomprehened", "uncomputed", "unconcealed", "unconceded", "unconcluded", "uncondensed", "unconditioned", "unconfined", "unconfirmed", "uncongested", "unconglomerated", "uncongratulated", "unconjugated", "unconquered", "unconsecrated", "unconsoled", "unconsolidated", "unconstipated", "unconstricted", "unconstructed", "unconsumed", "uncontacted", "uncontracted", "uncontradicted", "uncontrived", "unconverted", "unconveyed", "unconvicted", "uncooked", "uncooled", "uncoordinated", "uncopyrighted", "uncored", "uncorrelated", "uncorroborated", "uncosted", "uncounseled", "uncounselled", "uncounterfeited", "uncoveted", "uncrafted", "uncramped", "uncrannied", "uncrazed", "uncreamed", "uncreased", "uncreated", "uncredentialled", "uncredited", "uncrested", "uncrevassed", "uncrippled", "uncriticised", "uncriticized", "uncropped", "uncrosslinked", "uncrowded", "uncrucified", "uncrumbled", "uncrystalized", "uncrystallised", "uncrystallized", "uncubed", "uncuddled", "uncued", "unculled", "uncultivated", "uncultured", "uncupped", "uncurated", "uncurbed", "uncurried", "uncurtained", "uncushioned", "undamped", "undampened", "undappled", "undarkened", "undated", "undaubed", "undazzled", "undeadened", "undeafened", "undebated", "undebunked", "undeceased", "undecimalized", "undeciphered", "undecked", "undeclared", "undecomposed", "undeconstructed", "undedicated", "undefeated", "undeferred", "undefied", "undefined", "undeflected", "undefrauded", "undefrayed", "undegassed", "undejected", "undelegated", "undeleted", "undelimited", "undelineated", "undemented", "undemolished", "undemonstrated", "undenatured", "undenied", "undented", "undeodorized", "undepicted", "undeputized", "underaged", "underarmed", "underassessed", "underbred", "underbudgeted", "undercapitalised", "undercapitalized", "underdiagnosed", "underdocumented", "underequipped", "underexploited", "underexplored", "underfed", "underfeed", "underfurnished", "undergoverned", "undergrazed", "underinflated", "underinsured", "underinvested", "underived", "undermaintained", "undermentioned", "undermotivated", "underperceived", "underpowered", "underprivileged", "underqualified", "underrehearsed", "underresourced", "underripened", "undersaturated", "undersexed", "undersized", "underspecified", "understaffed", "understocked", "understressed", "understudied", "underutilised", "underventilated", "undescaled", "undesignated", "undetached", "undetailed", "undetained", "undeteriorated", "undeterred", "undetonated", "undevised", "undevoted", "undevoured", "undiagnosed", "undialed", "undialysed", "undialyzed", "undiapered", "undiffracted", "undigested", "undignified", "undiluted", "undiminished", "undimmed", "undipped", "undirected", "undisciplined", "undiscouraged", "undiscussed", "undisfigured", "undisguised", "undisinfected", "undismayed", "undisposed", "undisproved", "undisputed", "undisrupted", "undissembled", "undissipated", "undissociated", "undissolved", "undistilled", "undistorted", "undistracted", "undistributed", "undisturbed", "undiversified", "undiverted", "undivulged", "undoctored", "undocumented", "undomesticated", "undosed", "undramatised", "undrilled", "undrugged", "undubbed", "unduplicated", "uneclipsed", "unedged", "unedited", "unejaculated", "unejected", "unelaborated", "unelapsed", "unelected", "unelectrified", "unelevated", "unelongated", "unelucidated", "unemaciated", "unemancipated", "unemasculated", "unembalmed", "unembed", "unembellished", "unembodied", "unemboldened", "unemerged", "unenacted", "unencoded", "unencrypted", "unencumbered", "unendangered", "unendorsed", "unenergized", "unenfranchised", "unengraved", "unenhanced", "unenlarged", "unenlivened", "unenraptured", "unenriched", "unentangled", "unentitled", "unentombed", "unentranced", "unentwined", "unenumerated", "unenveloped", "unenvied", "unequaled", "unequalised", "unequalized", "unequalled", "unequipped", "unerased", "unerected", "uneroded", "unerupted", "unescorted", "unestablished", "unevaluated", "unexaggerated", "unexampled", "unexcavated", "unexceeded", "unexcelled", "unexecuted", "unexerted", "unexhausted", "unexpensed", "unexperienced", "unexpired", "unexploited", "unexplored", "unexposed", "unexpurgated", "unextinguished", "unfabricated", "unfaceted", "unfanned", "unfashioned", "unfathered", "unfathomed", "unfattened", "unfavored", "unfavoured", "unfazed", "unfeathered", "unfed", "unfeigned", "unfermented", "unfertilised", "unfertilized", "unfilleted", "unfiltered", "unfinished", "unflavored", "unflavoured", "unflawed", "unfledged", "unfleshed", "unflurried", "unflushed", "unflustered", "unfluted", "unfocussed", "unforested", "unformatted", "unformulated", "unfortified", "unfractionated", "unfractured", "unfragmented", "unfrequented", "unfretted", "unfrosted", "unfueled", "unfunded", "unfurnished", "ungarbed", "ungarmented", "ungarnished", "ungeared", "ungerminated", "ungifted", "unglazed", "ungoverned", "ungraded", "ungrasped", "ungratified", "ungroomed", "ungrounded", "ungrouped", "ungummed", "ungusseted", "unhabituated", "unhampered", "unhandicapped", "unhardened", "unharvested", "unhasped", "unhatched", "unheralded", "unhindered", "unhomogenised", "unhomogenized", "unhonored", "unhonoured", "unhooded", "unhusked", "unhyphenated", "unified", "unillustrated", "unimpacted", "unimpaired", "unimpassioned", "unimpeached", "unimpelled", "unimplemented", "unimpregnated", "unimprisoned", "unimpugned", "unincorporated", "unincubated", "unincumbered", "unindemnified", "unindexed", "unindicted", "unindorsed", "uninduced", "unindustrialised", "unindustrialized", "uninebriated", "uninfected", "uninflated", "uninflected", "uninhabited", "uninhibited", "uninitialised", "uninitialized", "uninitiated", "uninoculated", "uninseminated", "uninsulated", "uninsured", "uninterpreted", "unintimidated", "unintoxicated", "unintroverted", "uninucleated", "uninverted", "uninvested", "uninvolved", "unissued", "unjaundiced", "unjointed", "unjustified", "unkeyed", "unkindled", "unlabelled", "unlacquered", "unlamented", "unlaminated", "unlarded", "unlaureled", "unlaurelled", "unleaded", "unleavened", "unled", "unlettered", "unlicenced", "unlighted", "unlimbered", "unlimited", "unlined", "unlipped", "unliquidated", "unlithified", "unlittered", "unliveried", "unlobed", "unlocalised", "unlocalized", "unlocated", "unlogged", "unlubricated", "unmagnified", "unmailed", "unmaimed", "unmaintained", "unmalted", "unmangled", "unmanifested", "unmanipulated", "unmannered", "unmanufactured", "unmapped", "unmarred", "unmastered", "unmatriculated", "unmechanised", "unmechanized", "unmediated", "unmedicated", "unmentioned", "unmerged", "unmerited", "unmetabolised", "unmetabolized", "unmetamorphosed", "unmethylated", "unmineralized", "unmitigated", "unmoderated", "unmodernised", "unmodernized", "unmodified", "unmodulated", "unmolded", "unmolested", "unmonitored", "unmortgaged", "unmotivated", "unmotorised", "unmotorized", "unmounted", "unmutated", "unmutilated", "unmyelinated", "unnaturalised", "unnaturalized", "unnotched", "unnourished", "unobligated", "unobstructed", "unoccupied", "unoiled", "unopposed", "unoptimised", "unordained", "unorganised", "unorganized", "unoriented", "unoriginated", "unornamented", "unoxidized", "unoxygenated", "unpacified", "unpackaged", "unpaired", "unparalleled", "unparallelled", "unparasitized", "unpardoned", "unparodied", "unpartitioned", "unpasteurised", "unpasteurized", "unpatented", "unpaved", "unpedigreed", "unpenetrated", "unpenned", "unperfected", "unperjured", "unpersonalised", "unpersuaded", "unperturbed", "unperverted", "unpestered", "unphosphorylated", "unphotographed", "unpigmented", "unpiloted", "unpledged", "unploughed", "unplumbed", "unpoised", "unpolarized", "unpoliced", "unpolled", "unpopulated", "unposed", "unpowered", "unprecedented", "unpredicted", "unprejudiced", "unpremeditated", "unprescribed", "unpressurised", "unpressurized", "unpriced", "unprimed", "unprincipled", "unprivileged", "unprized", "unprocessed", "unprofaned", "unprofessed", "unprohibited", "unprompted", "unpronounced", "unproposed", "unprospected", "unproved", "unpruned", "unpublicised", "unpublicized", "unpublished", "unpuckered", "unpunctuated", "unpurified", "unqualified", "unquantified", "unquenched", "unquoted", "unranked", "unrated", "unratified", "unrebuked", "unreckoned", "unrecompensed", "unreconciled", "unreconstructed", "unrectified", "unredeemed", "unrefined", "unrefreshed", "unrefrigerated", "unregarded", "unregimented", "unregistered", "unregulated", "unrehearsed", "unrelated", "unrelieved", "unrelinquished", "unrenewed", "unrented", "unrepealed", "unreplicated", "unreprimanded", "unrequited", "unrespected", "unrestricted", "unretained", "unretarded", "unrevised", "unrevived", "unrevoked", "unrifled", "unripened", "unrivaled", "unrivalled", "unroasted", "unroofed", "unrounded", "unruffled", "unsalaried", "unsalted", "unsanctified", "unsanctioned", "unsanded", "unsaponified", "unsated", "unsatiated", "unsatisfied", "unsaturated", "unscaled", "unscarred", "unscathed", "unscented", "unscheduled", "unschooled", "unscreened", "unscripted", "unseamed", "unseared", "unseasoned", "unseeded", "unsegmented", "unsegregated", "unselected", "unserviced", "unsexed", "unshamed", "unshaped", "unsharpened", "unsheared", "unshielded", "unshifted", "unshirted", "unshoed", "unshuttered", "unsifted", "unsighted", "unsilenced", "unsimplified", "unsized", "unskewed", "unskinned", "unslaked", "unsliced", "unsloped", "unsmoothed", "unsoiled", "unsoldered", "unsolicited", "unsolved", "unsophisticated", "unsorted", "unsourced", "unsoured", "unspaced", "unspanned", "unspecialised", "unspecialized", "unspecified", "unspiced", "unstaged", "unstandardised", "unstandardized", "unstapled", "unstarched", "unstarred", "unstated", "unsteadied", "unstemmed", "unsterilised", "unsterilized", "unstickered", "unstiffened", "unstifled", "unstigmatised", "unstigmatized", "unstilted", "unstippled", "unstipulated", "unstirred", "unstocked", "unstoked", "unstoppered", "unstratified", "unstressed", "unstriped", "unstructured", "unstudied", "unstumped", "unsubdued", "unsubmitted", "unsubsidised", "unsubsidized", "unsubstantiated", "unsubstituted", "unsugared", "unsummarized", "unsupervised", "unsuprised", "unsurveyed", "unswayed", "unsweetened", "unsyllabled", "unsymmetrized", "unsynchronised", "unsynchronized", "unsyncopated", "unsyndicated", "unsynthesized", "unsystematized", "untagged", "untainted", "untalented", "untanned", "untaped", "untapered", "untargeted", "untarnished", "untattooed", "untelevised", "untempered", "untenanted", "unterminated", "untextured", "unthickened", "unthinned", "unthrashed", "unthreaded", "unthrottled", "unticketed", "untiled", "untilled", "untilted", "untimbered", "untinged", "untinned", "untinted", "untitled", "untoasted", "untoggled", "untoothed", "untopped", "untoughened", "untracked", "untrammeled", "untrammelled", "untranscribed", "untransduced", "untransferred", "untranslated", "untransmitted", "untraumatized", "untraversed", "untufted", "untuned", "untutored", "unupgraded", "unupholstered", "unutilised", "unutilized", "unuttered", "unvaccinated", "unvacuumed", "unvalidated", "unvalued", "unvandalized", "unvaned", "unvanquished", "unvapourised", "unvapourized", "unvaried", "unvariegated", "unvarnished", "unvented", "unventilated", "unverbalised", "unverbalized", "unverified", "unversed", "unvetted", "unvictimized", "unviolated", "unvitrified", "unvocalized", "unvoiced", "unwaged", "unwarped", "unwarranted", "unwaxed", "unweakened", "unweaned", "unwearied", "unweathered", "unwebbed", "unwed", "unwedded", "unweeded", "unweighted", "unwelded", "unwinterized", "unwired", "unwitnessed", "unwonted", "unwooded", "unworshipped", "unwounded", "unzoned", "uprated", "uprighted", "upsized", "upswelled", "vacuolated", "valanced", "valueoriented", "varied", "vascularised", "vascularized", "vasectomised", "vaunted", "vectorised", "vectorized", "vegged", "verdured", "verified", "vermiculated", "vernacularized", "versified", "verticillated", "vesiculated", "vied", "vilified", "virtualised", "vitrified", "vivified", "volumed", "vulcanised", "wabbled", "wafered", "waisted", "walleyed", "wared", "warmblooded", "warmhearted", "warted", "waterbased", "waterbed", "watercooled", "watersaturated", "watershed", "wavegenerated", "waxweed", "weakhearted", "weakkneed", "weakminded", "wearied", "weatherised", "weatherstriped", "webfooted", "wedgeshaped", "weed", "weeviled", "welladapted", "welladjusted", "wellbred", "wellconducted", "welldefined", "welldisposed", "welldocumented", "wellequipped", "wellestablished", "wellfavored", "wellfed", "wellgrounded", "wellintentioned", "wellmannered", "wellminded", "wellorganised", "wellrounded", "wellshaped", "wellstructured", "whinged", "whinnied", "whiplashed", "whiskered", "wholehearted", "whorled", "widebased", "wideeyed", "widemeshed", "widemouthed", "widenecked", "widespaced", "wilded", "wildered", "wildeyed", "willinghearted", "windspeed", "winterfed", "winterfeed", "winterised", "wirehaired", "wised", "witchweed", "woaded", "wombed", "wooded", "woodshed", "wooled", "woolled", "woollyhaired", "woollystemmed", "woolyhaired", "woolyminded", "wormholed", "wormshaped", "wrappered", "wretched", "wronghearted", "ycleped", "yolked", "zincified", "zinckified", "zinkified", "zombified"]; }; }), (function (module, exports, __webpack_require__) {
        "use strict"; module.exports = function (sentencePart, regex) {
            var results = []; for (var match = regex.exec(sentencePart); match !== null; match = regex.exec(sentencePart)) { results.push({ match: match[0], index: match.index }); }
            return results;
        };
    }), (function (module, exports, __webpack_require__) {
        var SetCache = __webpack_require__(64), arrayIncludes = __webpack_require__(112), arrayIncludesWith = __webpack_require__(113), arrayMap = __webpack_require__(24), baseUnary = __webpack_require__(69), cacheHas = __webpack_require__(65); var nativeMin = Math.min; function baseIntersection(arrays, iteratee, comparator) {
            var includes = comparator ? arrayIncludesWith : arrayIncludes, length = arrays[0].length, othLength = arrays.length, othIndex = othLength, caches = Array(othLength), maxLength = Infinity, result = []; while (othIndex--) {
                var array = arrays[othIndex]; if (othIndex && iteratee) { array = arrayMap(array, baseUnary(iteratee)); }
                maxLength = nativeMin(array.length, maxLength); caches[othIndex] = !comparator && (iteratee || (length >= 120 && array.length >= 120)) ? new SetCache(othIndex && array) : undefined;
            }
            array = arrays[0]; var index = -1, seen = caches[0]; outer: while (++index < length && result.length < maxLength) {
                var value = array[index], computed = iteratee ? iteratee(value) : value; value = (comparator || value !== 0) ? value : 0; if (!(seen ? cacheHas(seen, computed) : includes(result, computed, comparator))) {
                    othIndex = othLength; while (--othIndex) { var cache = caches[othIndex]; if (!(cache ? cacheHas(cache, computed) : includes(arrays[othIndex], computed, comparator))) { continue outer; } }
                    if (seen) { seen.push(computed); }
                    result.push(value);
                }
            }
            return result;
        }
        module.exports = baseIntersection;
    }), (function (module, exports, __webpack_require__) {
        var isArrayLikeObject = __webpack_require__(97); function castArrayLikeObject(value) { return isArrayLikeObject(value) ? value : []; }
        module.exports = castArrayLikeObject;
    }), (function (module, exports, __webpack_require__) { "use strict"; module.exports = function () { return ["to", "which", "who", "whom", "that", "whose", "after", "although", "as", "because", "before", "even if", "even though", "how", "if", "in order that", "inasmuch", "lest", "once", "provided", "since", "so that", "than", "though", "till", "unless", "until", "when", "whenever", "where", "whereas", "wherever", "whether", "while", "why", "by the time", "supposing", "no matter", "how", "what", "won't", "do", "does", "–", "and", "but", "or"]; }; }), (function (module, exports, __webpack_require__) { "use strict"; var getParticiples = __webpack_require__(187); var determineSentencePartIsPassive = __webpack_require__(191); module.exports = function (sentencePart, auxiliaries) { var participles = getParticiples(sentencePart, auxiliaries); return determineSentencePartIsPassive(participles); }; }), (function (module, exports, __webpack_require__) {
        "use strict"; var stopwords = __webpack_require__(403)(); var arrayToRegex = __webpack_require__(51); var stripSpaces = __webpack_require__(8); var SentencePart = __webpack_require__(404); var auxiliaries = __webpack_require__(53)().allAuxiliaries; var forEach = __webpack_require__(1); var isEmpty = __webpack_require__(10); var map = __webpack_require__(2); var stopwordRegex = arrayToRegex(stopwords); var auxiliaryRegex = arrayToRegex(auxiliaries); function sanitizeMatches(matches) { return map(matches, function (match) { return stripSpaces(match); }); }
        function splitOnWords(sentence, stopwords) {
            var splitSentences = []; forEach(stopwords, function (stopword) {
                var splitSentence = sentence.split(stopword); if (!isEmpty(splitSentence[0])) { splitSentences.push(splitSentence[0]); }
                var startIndex = sentence.indexOf(stopword); var endIndex = sentence.length; sentence = stripSpaces(sentence.substr(startIndex, endIndex));
            }); splitSentences.push(sentence); return splitSentences;
        }
        function createSentenceParts(sentences) { var sentenceParts = []; forEach(sentences, function (part) { var foundAuxiliaries = sanitizeMatches(part.match(auxiliaryRegex || [])); sentenceParts.push(new SentencePart(part, foundAuxiliaries, "de_DE")); }); return sentenceParts; }
        function splitSentence(sentence) { var stopwords = sentence.match(stopwordRegex) || []; var splitSentences = splitOnWords(sentence, stopwords); return createSentenceParts(splitSentences); }
        module.exports = function (sentence) { return splitSentence(sentence); };
    }), (function (module, exports, __webpack_require__) { "use strict"; module.exports = function () { return [":", "aber", "als", "bevor", "bis", "da", "damit", "daß", "dass", "denn", "doch", "ehe", "falls", "gleichwohl", "indem", "indes", "indessen", "insofern", "insoweit", "nachdem", "nun", "ob", "obgleich", "obschon", "obwohl", "obzwar", "oder", "seitdem", "sobald", "sodass", "sofern", "solange", "sondern", "sooft", "soviel", "soweit", "sowie", "trotz", "und", "ungeachtet", "waehrend", "während", "weil", "welche", "welchem", "welchen", "welcher", "welches", "wem", "wen", "wenn", "wenngleich", "wennschon", "wer", "wes", "wessen", "wie", "wiewohl", "wohingegen", "zumal"]; }; }), (function (module, exports, __webpack_require__) { "use strict"; var SentencePart = __webpack_require__(186); var getParticiples = __webpack_require__(192); var GermanSentencePart = function GermanSentencePart(sentencePartText, auxiliaries) { SentencePart.call(this, sentencePartText, auxiliaries, "de_DE"); }; __webpack_require__(14).inherits(GermanSentencePart, SentencePart); GermanSentencePart.prototype.getParticiples = function () { return getParticiples(this.getSentencePartText(), this.getAuxiliaries()); }; module.exports = GermanSentencePart; }), (function (module, exports, __webpack_require__) { "use strict"; var verbsBeginningWithGeRegex = /^((ge)\S+t($|[ \n\r\t\.,'\(\)\"\+\-;!?:\/»«‹›<>]))/ig; var verbsBeginningWithErVerEntBeZerHerUberRegex = /^(((be|ent|er|her|ver|zer|über|ueber)\S+([^s]t|sst))($|[ \n\r\t\.,'\(\)\"\+\-;!?:\/»«‹›<>]))/ig; var verbsWithGeInMiddleRegex = /(ab|an|auf|aus|vor|wieder|zurück)(ge)\S+t($|[ \n\r\t\.,'\(\)\"\+\-;!?:\/»«‹›<>])/ig; var verbsWithErVerEntBeZerHerUberInMiddleRegex = /((ab|an|auf|aus|vor|wieder|zurück)(be|ent|er|her|ver|zer|über|ueber)\S+([^s]t|sst))($|[ \n\r\t\.,'\(\)\"\+\-;!?:\/»«‹›<>])/ig; var verbsEndingWithIertRegex = /\S+iert($|[ \n\r\t\.,'\(\)\"\+\-;!?:\/»«‹›<>])/ig; var exceptionsRegex = /\S+(apparat|arbeit|dienst|haft|halt|kraft|not|pflicht|schaft|schrift|tät|wert|zeit)($|[ \n\r\t\.,'\(\)\"\+\-;!?:\/»«‹›<>])/ig; var verbsBeginningWithGe = function verbsBeginningWithGe(word) { return word.match(verbsBeginningWithGeRegex) || []; }; var verbsBeginningWithErVerEntBeZerHerUber = function verbsBeginningWithErVerEntBeZerHerUber(word) { return word.match(verbsBeginningWithErVerEntBeZerHerUberRegex) || []; }; var verbsWithGeInMiddle = function verbsWithGeInMiddle(word) { return word.match(verbsWithGeInMiddleRegex) || []; }; var verbsWithErVerEntBeZerHerUberInMiddle = function verbsWithErVerEntBeZerHerUberInMiddle(word) { return word.match(verbsWithErVerEntBeZerHerUberInMiddleRegex) || []; }; var verbsEndingWithIert = function verbsEndingWithIert(word) { return word.match(verbsEndingWithIertRegex) || []; }; var exceptions = function exceptions(word) { return word.match(exceptionsRegex) || []; }; module.exports = function () { return { verbsBeginningWithGe: verbsBeginningWithGe, verbsBeginningWithErVerEntBeZerHerUber: verbsBeginningWithErVerEntBeZerHerUber, verbsWithGeInMiddle: verbsWithGeInMiddle, verbsWithErVerEntBeZerHerUberInMiddle: verbsWithErVerEntBeZerHerUberInMiddle, verbsEndingWithIert: verbsEndingWithIert, exceptions: exceptions }; }; }), (function (module, exports, __webpack_require__) { "use strict"; module.exports = function () { return ["angefangen", "aufgerissen", "ausgesehen", "befohlen", "befunden", "begonnen", "bekommen", "bewiesen", "beworben", "empfohlen", "empfunden", "entschieden", "erschrocken", "erwogen", "gebacken", "gebeten", "gebissen", "geblasen", "geblieben", "gebogen", "geboren", "geborgen", "geboten", "gebraten", "gebrochen", "gebunden", "gediehen", "gedroschen", "gedrungen", "gefahren", "gefallen", "gefangen", "geflogen", "geflohen", "geflossen", "gefressen", "gefroren", "gefunden", "gegangen", "gegeben", "gegessen", "geglichen", "geglitten", "gelungen", "gegolten", "gegoren", "gegossen", "gegraben", "gegriffen", "gehalten", "gehangen", "gehauen", "geheissen", "geheißen", "gehoben", "geholfen", "geklungen", "gekniffen", "gekommen", "gekrochen", "geladen", "gelassen", "gelaufen", "gelegen", "gelesen", "geliehen", "gelitten", "gelogen", "gelungen", "gemessen", "gemieden", "genesen", "genommen", "genossen", "gepfiffen", "gepriesen", "gequollen", "geraten", "gerieben", "gerissen", "geritten", "gerochen", "geronnen", "gerufen", "gerungen", "geschaffen", "geschehen", "geschieden", "geschienen", "geschlafen", "geschlagen", "geschlichen", "geschliffen", "geschlossen", "geschlungen", "geschmissen", "geschmolzen", "geschnitten", "geschoben", "gescholten", "geschoren", "geschossen", "geschrieben", "geschrien", "geschritten", "geschunden", "geschwiegen", "geschwollen", "geschwommen", "geschworen", "geschwunden", "geschwungen", "gesehen", "gesessen", "gesoffen", "gesonnen", "gespien", "gesponnen", "gesprochen", "gesprossen", "gesprungen", "gestanden", "gestiegen", "gestochen", "gestohlen", "gestorben", "gestoßen", "gestossen", "gestrichen", "gestritten", "gesungen", "gesunken", "getan", "getragen", "getreten", "getrieben", "getroffen", "getrogen", "getrunken", "gewachsen", "gewaschen", "gewichen", "gewiesen", "gewoben", "gewogen", "gewonnen", "geworben", "geworfen", "gewrungen", "gezogen", "gezwungen", "misslungen", "überbacken", "ueberbacken", "überbehalten", "ueberbehalten", "überbekommen", "ueberbekommen", "überbelegen", "ueberbelegen", "überbezahlen", "ueberbezahlen", "überboten", "ueberboten", "übergebunden", "uebergebunden", "überbunden", "ueberbunden", "überblasen", "ueberblasen", "überbraten", "ueberbraten", "übergebraten", "uebergebraten", "überbremst", "ueberbremst", "übergeblieben", "uebergeblieben", "übereinandergelegen", "uebereinandergelegen", "übereinandergeschlagen", "uebereinandergeschlagen", "übereinandergesessen", "uebereinandergesessen", "übereinandergestanden", "uebereinandergestanden", "übereingefallen", "uebereingefallen", "übereingekommen", "uebereingekommen", "übereingetroffen", "uebereingetroffen", "übergefallen", "uebergefallen", "übergessen", "uebergessen", "überfahren", "ueberfahren", "übergefahren", "uebergefahren", "überfallen", "ueberfallen", "überfangen", "ueberfangen", "überflogen", "ueberflogen", "überflossen", "ueberflossen", "übergeflossen", "uebergeflossen", "überfressen", "ueberfressen", "überfroren", "ueberfroren", "übergegeben", "uebergegeben", "übergeben", "uebergeben", "übergegangen", "uebergegangen", "übergangen", "uebergangen", "übergangen", "uebergangen", "übergossen", "uebergossen", "übergriffen", "uebergriffen", "übergegriffen", "uebergegriffen", "übergehalten", "uebergehalten", "überhandgenommen", "ueberhandgenommen", "überhangen", "ueberhangen", "übergehangen", "uebergehangen", "übergehoben", "uebergehoben", "überhoben", "ueberhoben", "überkommen", "ueberkommen", "übergekommen", "uebergekommen", "überladen", "ueberladen", "übergeladen", "uebergeladen", "überlassen", "ueberlassen", "übergelassen", "uebergelassen", "überlaufen", "ueberlaufen", "übergelaufen", "uebergelaufen", "überlesen", "ueberlesen", "übergelegen", "uebergelegen", "übergenommen", "uebergenommen", "übernommen", "uebernommen", "übergequollen", "uebergequollen", "überrissen", "ueberrissen", "überritten", "ueberritten", "übergeschossen", "uebergeschossen", "überschlafen", "ueberschlafen", "überschlagen", "ueberschlagen", "übergeschlagen", "uebergeschlagen", "übergeschlossen", "uebergeschlossen", "überschnitten", "ueberschnitten", "überschrieben", "ueberschrieben", "überschrieen", "ueberschrieen", "überschrien", "ueberschrien", "überschritten", "ueberschritten", "überschwungen", "ueberschwungen", "übergesehen", "uebergesehen", "übersehen", "uebersehen", "übergesotten", "uebergesotten", "übergesotten", "uebergesotten", "übersponnen", "uebersponnen", "übersprochen", "uebersprochen", "übersprungen", "uebersprungen", "übergesprungen", "uebergesprungen", "überstochen", "ueberstochen", "übergestochen", "uebergestochen", "überstanden", "ueberstanden", "übergestanden", "uebergestanden", "überstiegen", "ueberstiegen", "übergestiegen", "uebergestiegen", "übergestrichen", "uebergestrichen", "überstrichen", "ueberstrichen", "übertragen", "uebertragen", "übertroffen", "uebertroffen", "übertrieben", "uebertrieben", "übertreten", "uebertreten", "übergetreten", "uebergetreten", "überwachsen", "ueberwachsen", "überwiesen", "ueberwiesen", "überworfen", "ueberworfen", "übergeworfen", "uebergeworfen", "überwogen", "ueberwogen", "überwunden", "ueberwunden", "überzogen", "ueberzogen", "übergezogen", "uebergezogen", "verdorben", "vergessen", "verglichen", "verloren", "verstanden", "verschwunden", "vorgeschlagen"]; }; }), (function (module, exports, __webpack_require__) {
        "use strict"; var Participle = __webpack_require__(188); var getIndices = __webpack_require__(108).getIndicesByWord; var getIndicesOfList = __webpack_require__(108).getIndicesByWordList; var exceptionsParticiplesActive = __webpack_require__(408)(); var auxiliaries = __webpack_require__(53)().participleLike; var exceptionsRegex = /\S+(apparat|arbeit|dienst|haft|halt|keit|kraft|not|pflicht|schaft|schrift|tät|wert|zeit)($|[ \n\r\t\.,'\(\)\"\+\-;!?:\/»«‹›<>])/ig; var includes = __webpack_require__(29); var map = __webpack_require__(2); var GermanParticiple = function GermanParticiple(participle, sentencePart, attributes) { Participle.call(this, participle, sentencePart, attributes); this.setSentencePartPassiveness(this.isPassive()); }; __webpack_require__(14).inherits(GermanParticiple, Participle); GermanParticiple.prototype.isPassive = function () { return !this.hasNounSuffix() && !this.isInExceptionList() && !this.hasHabenSeinException() && !this.isAuxiliary(); }; GermanParticiple.prototype.isInExceptionList = function () { return includes(exceptionsParticiplesActive, this.getParticiple()); }; GermanParticiple.prototype.hasNounSuffix = function () { return this.getParticiple().match(exceptionsRegex) !== null; }; GermanParticiple.prototype.hasHabenSeinException = function () {
            var participleIndices = getIndices(this.getParticiple(), this.getSentencePart()); var habenSeinIndices = getIndicesOfList(["haben", "sein"], this.getSentencePart()); if (participleIndices.length > 0 && habenSeinIndices.length === 0) { return false; }
            habenSeinIndices = map(habenSeinIndices, "index"); var currentParticiple = participleIndices[0]; return includes(habenSeinIndices, currentParticiple.index + currentParticiple.match.length + 1);
        }; GermanParticiple.prototype.isAuxiliary = function () { return includes(auxiliaries, this.getParticiple()); }; module.exports = GermanParticiple;
    }), (function (module, exports, __webpack_require__) { "use strict"; module.exports = function () { return ["geht", "gämsbart", "gemsbart", "geäst", "gebarungsbericht", "geähnelt", "geartet", "gebäudetrakt", "gebet", "gebiet", "gebietsrepräsentant", "gebildbrot", "gebirgsart", "gebirgsgrat", "gebirgskurort", "gebirgsluft", "gebirgsschlucht", "geblüt", "geblütsrecht", "gebohntkraut", "gebot", "gebrauchsgut", "gebrauchstext", "gebrauchsverlust", "gebrauchtgerät", "gebrauchtwagengeschäft", "gebrauchtwagenmarkt", "geburt", "geburtsakt", "geburtsgeschwulst", "geburtsgewicht", "geburtsort", "geburtsrecht", "geburtsstadt", "geburtstagsfest", "geckenart", "gedächtniskonzert", "gedächtniskunst", "gedächtnisverlust", "gedankenarmut", "gedankenexperiment", "gedankenflucht", "gedankengut", "gedankenschritt", "gedankenwelt", "gedenkkonzert", "gedicht", "geest", "gefahrengebiet", "gefahrenmoment", "gefahrenpunkt", "gefahrgut", "gefahrguttransport", "gefährt", "gefälligkeitsakzept", "gefallsucht", "gefangenenanstalt", "gefangenentransport", "gefängnisarzt", "gefängniskluft", "gefäßnaht", "gefecht", "gefechtsabschnitt", "gefechtsbereit", "gefechtsgebiet", "gefechtsgewicht", "gefechtshut", "gefechtsmast", "gefechtsmast", "geflecht", "geflügelaufzucht", "geflügelleberwurst", "geflügelmarkt", "geflügelmast", "geflügelpest", "geflügelsalat", "geflügelwurst", "geflügelzucht", "gefolgsleute", "gefrett", "gefriergerät", "gefriergut", "gefrierobst", "gefrierpunkt", "gefrierschnitt", "gefühlsarmut", "gefühlswelt", "gegenangebot", "gegenansicht", "gegenargument", "gegengeschäft", "gegengewalt", "gegengewicht", "gegenkandidat", "gegenkompliment", "gegenkonzept", "gegenlicht", "gegenmacht", "gegenpapst", "gegenpart", "gegensatzwort", "gegenstandpunkt", "gegenstandsgebiet", "gegenwart", "gegenwartskunst", "gegenwelt", "gegenwort", "gehaart", "gehandicapt", "gehandikapt", "geheimagent", "geheimbericht", "geheimdokument", "geheimfavorit", "geheimkontakt", "geheimkult", "geheimnisverrat", "geheimpolizist", "geheimrat", "geheimrezept", "geheimtext", "gehirnakrobat", "gehirngeschwulst", "gehirnhaut", "gehirnsandgeschwulst", "gehirntot", "gehirntrust", "gehöft", "gehörlosensport", "geigenkonzert", "geißbart", "geißblatt", "geißhirte", "geißhirt", "geist", "geisterfahrt", "geisterstadt", "geisterwelt", "geistesarmut", "geistesart", "geistesfürst", "geistesgegenwart", "geistesgestört", "geistesprodukt", "geistestat", "geistesverwandt", "geisteswelt", "geklüft", "geländefahrt", "geländeritt", "geländesport", "gelangweilt", "gelaut", "geläut", "gelblicht", "gelbrost", "gelbsucht", "gelbwurst", "gelcoat", "geldausgabeautomat", "geldautomat", "geldgeschäft", "geldheirat", "geldinstitut", "geldmarkt", "geldsurrogat", "geldtransport", "geldverlust", "gelehrtenstreit", "gelehrtenwelt", "geleit", "geleitboot", "geleitwort", "gelenkgicht", "gelenkwassersucht", "geleucht", "geltungssucht", "gelüst", "gemächt", "gemeindeamt", "gemeindebürgerrecht", "gemeindegut", "gemeindekirchenrat", "gemeindepräsident", "gemeinderat", "gemeingeist", "gemeingut", "gemeinschaftsgeist", "gemeinschaftsprojekt", "gemeinschaftsunterkunft", "gemengesaat", "gemüseart", "gemüsebeet", "gemüsegeschäft", "gemüsemarkt", "gemüsesaft", "gemüsesalat", "gemüsezucht", "gemüt", "gemütsarmut", "gemütsart", "gemütsathlet", "gemütskalt", "genausogut", "genausooft", "genausoweit", "gendefekt", "generalagent", "generalarzt", "generalat", "generalbassinstrument", "generalbaßinstrument", "generalbundesanwalt", "generalgouvernement", "generalintendant", "generalist", "generalkonsulat", "generalleutnant", "generaloberst", "generalresident", "generalsekretariat", "generalstaaten", "generalstaatsanwalt", "generalsuperintendent", "generalüberholt", "generalvikariat", "generalvollmacht", "generationenkonflikt", "generativist", "genist", "genitivattribut", "genitivobjekt", "genmanipuliert", "gennesaret", "genotzüchtigt", "gent", "genuasamt", "genussgift", "genußgift", "genusssucht", "genuss-sucht", "genußsucht", "genverändert", "geobiont", "geodät", "geografieunterricht", "geographieunterricht", "geokrat", "geophyt", "gepäckfracht", "geradeausfahrt", "geradesogut", "gefälligst", "gerant", "gerät", "gerätewart", "geräuschlaut", "gerbextrakt", "gericht", "gerichtsarzt", "gerichtsort", "gerichtspräsident", "germanisiert", "germanist", "germanistikstudent", "gerodelt", "geröllschicht", "geröllschutt", "geront", "gerontokrat", "gerstenbrot", "gerstensaft", "gerstenschrot", "gerücht", "gerüst", "gesamtansicht", "gesamtaspekt", "gesamtdurchschnitt", "gesamtgewicht", "gesamtgut", "gesamt", "gesamtklassement", "gesamtunterricht", "gesandtschaftsrat", "gesangskunst", "gesangspart", "gesangssolist", "gesangsunterricht", "gesangunterricht", "geschäft", "geschäftsaufsicht", "geschäftsbericht", "geschäftsgeist", "geschäftswelt", "geschenkpaket", "geschichtsunterricht", "geschicklichkeitstest", "geschicklichkeitstest", "geschlecht", "geschlechtsakt", "geschlechtslust", "geschlechtsprodukt", "geschlechtswort", "geschmackstest", "geschwindigkeitslimit", "geschworenengericht", "geschwulst", "gesellschaftsfahrt", "gesellschaftsschicht", "gesetzblatt", "gesetzespaket", "gesetzestext", "gesicht", "gesichtshaut", "gesichtspunkt", "gesichtsschnitt", "gesichtsverlust", "gespenst", "gespensterfurcht", "gespinst", "gespött", "gesprächstherapeut", "gestalt", "gestaltungselement", "gesteinsart", "gesteinschutt", "gesteinsschicht", "gestüt", "gestüthengst", "verantwortungsbewusst", "verantwortungsbewußt", "getast", "getränkeabholmarkt", "getränkeautomat", "getränkemarkt", "getreideart", "getreideaussaat", "getreideexport", "getreideimport", "getreideprodukt", "getreideschnitt", "getreidevorrat", "gewährfrist", "gewalt", "gewaltakt", "gewaltbereit", "gewalttat", "gesprächsbereit", "gewaltverbot", "gewaltverzicht", "gewässerbett", "gewässerwart", "gewebeschicht", "gewebsrest", "gewicht", "gewichtsprozent", "gewichtsverlust", "gewerbeamt", "gewerbearzt", "gewerbeaufsicht", "gewerbeaufsichtsamt", "gewerbegebiet", "gewerberecht", "gewerbsunzucht", "gewerkschaft", "gewerkschaftsjournalist", "gewindestift", "gewinnsucht", "gewinst", "gewissensangst", "gewissenskonflikt", "gewitterfront", "gewitterluft", "gewohnheitsrecht", "gewürzextrakt", "gewürzkraut", "gezücht", "erbbaurecht", "erbfolgerecht", "erbfolgestreit", "erbgut", "erbhofrecht", "erblast", "erbpacht", "erbrecht", "erbschaftsstreit", "erbsenkraut", "erbbedingt", "erbberechtigt", "erblasst", "erblaßt", "erbswurst", "erbverzicht", "erbwort", "erbzinsgut", "erdbebengebiet", "erdbeerjogurt", "erdbeerjoghurt", "erdbeeryoghurt", "erdbeerkompott", "erdbeerrot", "erdbeersaft", "erdbeersekt", "erdengut", "erdenlust", "erdfrucht", "erdgeist", "erdkundeunterricht", "erdlicht", "erdmittelpunkt", "erdnussfett", "erdölprodukt", "erdölproduzent", "erdsatellit", "erdschicht", "erdsicht", "erdtrabant", "erdverhaftet", "eremit", "erfahrungsbericht", "erfahrungshorizont", "erfahrungswelt", "erfindergeist", "erfolgsaussicht", "erfolgsorientiert", "erfolgsrezept", "erfolgsverwöhnt", "erfüllungsort", "erfurt", "ergänzungsheft", "ergänzungssport", "ergänzungstest", "ergostat", "ergotherapeut", "erholungsgebiet", "erholungsort", "erkundungsfahrt", "erlaucht", "erläuterungstext", "erlebnisbericht", "erlebnisorientiert", "erlebniswelt", "ernährungsamt", "ernst", "ernstgemeint", "ernteaussicht", "erntedankfest", "erntefest", "erntemonat", "ernteresultat", "eroberungsabsicht", "eroberungsgeist", "eroberungslust", "eroberungssucht", "eröffnungskonzert", "ersatzgeschwächt", "ersatzgut", "ersatzkandidat", "ersatzobjekt", "ersatzpräparat", "ersatzreservist", "ersatztorwart", "erscheinungsfest", "erscheinungsort", "erscheinungswelt", "erschließungsgebiet", "erst", "erstbundesligist", "erstfahrt", "erstgebot", "erstgeburt", "erstgeburtsrecht", "erstklassbillett", "erstklaßbillett", "erstkommunikant", "erstkonsument", "erstligist", "erstplatziert", "erstplaciert", "erstplaziert", "erstrecht", "ertragsaussicht", "erwartungsangst", "erwartungshorizont", "erwerbseinkünfte", "erythrit", "erythroblast", "erythrozyt", "erzählertalent", "erzählgut", "erzählkunst", "erzähltalent", "erzamt", "erzdemokrat", "erzeugungsschlacht", "erzfaschist", "erziehungsanstalt", "erziehungsberechtigt", "erziehungsinstitut", "erzkommunist", "erzprotestant", "veranlassungswort", "veranschaulicht", "veranschlagt", "verantwortungsbewusst", "verantwortungsbewußt", "veräußerungsverbot", "verbalist", "verbalkontrakt", "verbändestaat", "verbannungsort", "verbildlicht", "verbindungspunkt", "verbindungsstudent", "verbraucherkredit", "verbrauchermarkt", "verbrauchsgut", "verbrechernest", "verbrechersyndikat", "verbrecherwelt", "verbreitungsgebiet", "verbrennungsprodukt", "verdachtsmoment", "verdampfungsgerät", "verdauungstrakt", "verdikt", "veredelungsprodukt", "verehrerpost", "vereinspräsident", "vereinsrecht", "vereinssport", "verfahrensrecht", "verfassungsfahrt", "verfassungsgericht", "verfassungsrecht", "verfassungsstaat", "verfolgungsrecht", "verfremdungseffekt", "verfügungsgewalt", "verfügungsrecht", "verfügungsberechtigt", "verführungskunst", "vergegenständlicht", "vergegenwärtigt", "vergeltungsakt", "vergenossenschaftlicht", "vergissmeinnicht", "vergißmeinnicht", "vergleichsmonat", "vergleichsobjekt", "vergleichspunkt", "vergnügungsetablissement", "vergnügungsfahrt", "vergnügungssucht", "vergrößerungsgerät", "verhaltensgestört", "verhältniswahlrecht", "verhältniswort", "verhandlungsangebot", "verhandlungsbereit", "versandbereit", "verteidigungsbereit", "verhandlungsmandat", "verhandlungsort", "verhandlungspunkt", "verhöramt", "verist", "verjährungsfrist", "verkaufsagent", "verkaufsangebot", "verkaufsargument", "verkaufsautomat", "verkaufsfront", "verkaufshit", "verkaufsobjekt", "verkaufsorientiert", "verkaufspunkt", "verkehrsamt", "verkehrsdelikt", "verkehrsinfarkt", "verkehrsknotenpunkt", "verkehrslicht", "verkehrsnachricht", "verkehrspolizist", "verkehrsrecht", "verkehrsunterricht", "verkehrsverbot", "verklarungsbericht", "verknüpfungspunkt", "verkündungsblatt", "verlagsanstalt", "verlagsprospekt", "verlagsrecht", "verlagsrepräsentant", "verlagssignet", "verlust", "verlustgeschäft", "verlust", "verlustgeschäft", "verlustpunkt", "vermessungsamt", "vermittlungsamt", "vermögensrecht", "vermont", "vermummungsverbot", "verneinungswort", "vernichtungswut", "vernunft", "vernunftheirat", "verordnungsblatt", "verpackungsflut", "verpflichtungsgeschäft", "verrat", "versammlungsort", "versammlungsrecht", "versandgeschäft", "versandgut", "versart", "verschlusslaut", "verschnitt", "verschwendungssucht", "versehrtensport", "versicherungsagent", "versicherungsanstalt", "versicherungsrecht", "verskunst", "versöhnungsfest", "versorgungsamt", "versorgungsberechtigt", "versorgungsgebiet", "versorgungsgut", "versorgungsstaat", "verstakt", "verständigungsbereit", "verstellungskunst", "verstürznaht", "versuchsanstalt", "versuchsobjekt", "versuchsprojekt", "vertebrat", "verteidigungsbudget", "verteidigungsetat", "verteidigungspakt", "verteilungskonflikt", "verteilungszahlwort", "vertikalschnitt", "vertikutiergerät", "vertragsgerecht", "vertragspunkt", "vertragsrecht", "vertragsstaat", "vertragstext", "vertragswerkstatt", "vertrauensanwalt", "vertrauensarzt", "vertrauensverlust", "vertriebsrecht", "vervielfältigungsrecht", "vervielfältigungszahlwort", "verwaltungsakt", "verwaltungsgericht", "verwaltungsrat", "verwaltungsrecht", "verwundetentransport", "verzicht", "verzweiflungsakt", "verzweiflungstat", "entbindungsanstalt", "entdeckungsfahrt", "entenbrust", "entenfett", "entertainment", "enthusiast", "entlastungsmoment", "entlüftungsschacht", "entnazifizierungsgericht", "entoblast", "entoparasit", "entrechat", "entrefilet", "entrepot", "entscheidungsfurcht", "entscheidungsgewalt", "entscheidungsrecht", "entscheidungsschlacht", "entstehungsort", "entsteht", "entwässerungsschacht", "entwicklungsabschnitt", "entwicklungsinstitut", "entwicklungsprojekt", "entwicklungsschritt", "entziehungsanstalt", "zerat", "zerebrallaut", "zerfallsprodukt", "zergliederungskunst", "zerit", "zermatt", "zersetzungsprodukt", "zerstörungslust", "zerstörungswut", "zertifikat", "zerussit", "zervelat", "zervelatwurst", "beamtenrecht", "beamtenschicht", "beamtenstaat", "beat", "beatmungsgerät", "beaufort", "becherfrucht", "beckengurt", "becquereleffekt", "bedarfsgut", "bedenkfrist", "bedienungselement", "bedienungsgerät", "bedienungskomfort", "bedingtgut", "bedürfnisanstalt", "beeinflusst", "beeinflußt", "beerdigungsanstalt", "beerdigungsinstitut", "beerenfrucht", "beerenobst", "beerensaft", "beet", "befasst", "befaßt", "befehlsgewalt", "beförderungsentgelt", "beförderungsrecht", "begabungstest", "begegnungsort", "begleitinstrument", "begleittext", "begleitwort", "begnadigungsrecht", "begräbt", "begrenzungslicht", "begriffswelt", "begriffswort", "begrüßungswort", "behaviorist", "behebungsfrist", "behelfsausfahrt", "behelfsunterkunft", "behindertengerecht", "behindertensport", "behindertentransport", "behmlot", "beiblatt", "beiboot", "beignet", "beiheft", "beikost", "beilast", "beileidswort", "beinamputiert", "beinhaut", "beirat", "beirut", "beistandskredit", "beistandspakt", "beitritt", "beitrittsabsicht", "beitrittsgebiet", "beiwacht", "beiwort", "beizgerät", "bekehrungswut", "bekennergeist", "bekennermut", "bekleidungsamt", "bekommen", "belegarzt", "belegbett", "belegfrist", "belehrungssucht", "belemnit", "belesprit", "beleuchtungseffekt", "beleuchtungsgerät", "belfast", "belkantist", "belcantist", "belletrist", "bellizist", "belt", "benedikt", "benediktenkraut", "benefiziant", "benefiziat", "benefizkonzert", "beneluxstaat", "bentonit", "benzindunst", "beratungspunkt", "bereit", "bereicherungsabsicht", "bereitschaftsarzt", "bergamt", "bergeslast", "bergfahrt", "bergfest", "berggeist", "berggrat", "bergluft", "bergpredigt", "bergsport", "berg-und-Tal-Fahrt", "bergwacht", "bergwelt", "bericht", "berichtsmonat", "beritt", "bermudashort", "bernbiet", "berserkerwut", "berufsaussicht", "berufssoldat", "berufssport", "berufsstart", "berufstracht", "berufsverbot", "berufungsfrist", "berufungsgericht", "berufungsrecht", "berührungsangst", "berührungspunkt", "besanmast", "besatzungsgebiet", "besatzungsmacht", "besatzungsrecht", "besatzungssoldat", "besatzungsstatut", "beschaffungsamt", "beschäftigungstherapeut", "beschlächt", "beschlussrecht", "beschlußrecht", "beschmet", "beschneidungsfest", "beschlächt", "beschlussrecht", "beschlußrecht", "beschmet", "beschneidungsfest", "beschwerdefrist", "beschwerderecht", "beschwörungskunst", "beseitigungsanstalt", "besetzungsgebiet", "besetzungsmacht", "besetzungsstatut", "besichtigungsfahrt", "besitzrecht", "besoldungsrecht", "besprechungspunkt", "besserungsanstalt", "bestattungsinstitut", "bestimmungsort", "bestimmungswort", "bestinformiert", "bestqualifiziert", "bestrahlungsgerät", "bestrenommiert", "bestsituiert", "bestverkauft", "besucherrat", "besuchsrecht", "betpult", "betracht", "betreibungsamt", "betriebsarzt", "betriebsfest", "betriebsrat", "betriebswirt", "bett", "bettelmusikant", "bettelvogt", "bettstatt", "bettwurst", "beulenpest", "beutegut", "beutekunst", "beuterecht", "bevölkerungsschicht", "bewahranstalt", "bewährungsfrist", "bewegungsarmut", "beweislast", "bewußt", "bewusst", "beziehungsgeflecht", "bezirksamt", "bezirksarzt", "bezirksgericht", "bezirkskabinett", "bezirksschulrat", "bezirksstadt", "bezugspunkt", "bezugsrecht", "heraklit", "herat", "herbalist", "herbst", "herbstmonat", "herbstpunkt", "herdbuchzucht", "herdeninstinkt", "herfahrt", "heringsfilet", "heringssalat", "herkuleskraut", "herkunft", "herkunftsort", "hermaphrodit", "heroenkult", "heroinsucht", "heroldsamt", "heroldskunst", "herostrat", "herrenabfahrt", "herrenbrot", "herrendienst", "herrenfest", "herrenhut", "herrenrecht", "herrenschnitt", "herrenwelt", "herrgott", "herrnhut", "herrschaftsgebiet", "herrschaftsgewalt", "herrschaftsinstrument", "herrschergeschlecht", "herrscherkult", "herrschsucht", "herstellungsart", "herzacht", "herzangst", "herzblatt", "herzblut", "herzensangst", "herzensgut", "herzenslust", "herzenstrost", "herzgeliebt", "herzinfarkt", "herzinnenhaut", "herzklappendefekt", "herzogshut", "herzlichst", "herzpatient", "herzpunkt", "herzspezialist", "überbackt", "ueberbackt", "überbacktet", "ueberbacktet", "überbietet", "ueberbietet", "überbot", "ueberbot", "überbotet", "ueberbotet", "überbindet", "ueberbindet", "überbandet", "ueberbandet", "überbläst", "ueberblaest", "überbliest", "ueberbliest", "überbrät", "ueberbraet", "überbratet", "ueberbratet", "überbriet", "ueberbriet", "überbrietet", "ueberbrietet", "überbringt", "ueberbringt", "überbrachtet", "ueberbrachtet", "überbrücktet", "ueberbruecktet", "überbrühtet", "ueberbrühtet", "überbrülltet", "ueberbruelltet", "überbuchtet", "ueberbuchtet", "überbürdetet", "ueberbuerdetet", "überdecktet", "ueberdecktet", "überdehntet", "ueberdehntet", "überdenkt", "ueberdenkt", "überdachtet", "ueberdachtet", "überdosiertet", "ueberdosiertet", "überdrehtet", "ueberdrehtet", "überdrucktet", "ueberdrucktet", "überdüngtet", "ueberdüngtet", "übereignetet", "uebereignetet", "übereiltet", "uebereiltet", "übererfülltet", "uebererfuelltet", "überißt", "ueberisst", "ueberißt", "überisst", "überesst", "ueberesst", "übereßt", "uebereßt", "überaßt", "ueberaßt", "überesset", "ueberesset", "überäßet", "ueberaesset", "überfährt", "ueberfaehrt", "überfahrt", "ueberfahrt", "überfuhrt", "ueberfuhrt", "überfällt", "ueberfaellt", "überfallet", "ueberfallet", "überfielt", "ueberfielt", "überfielet", "ueberfielet", "überfängt", "ueberfaengt", "überfingt", "ueberfingt", "überfinget", "ueberfinget", "überfärbet", "ueberfaerbet", "überfettetet", "ueberfettetet", "überfirnisset", "ueberfirnisset", "überfirnißtet", "ueberfirnisstet", "überfischet", "ueberfischet", "überfischtet", "ueberfischtet", "überflanktet", "ueberflanktet", "überflanktet", "ueberflanktet", "überfliegt", "ueberfliegt", "überflieget", "ueberflieget", "überflöget", "ueberflöget", "überflösset", "ueberfloesset", "überflosst", "ueberflosst", "überfloßt", "ueberflosst", "überfließt", "ueberfliesst", "überflutetet", "ueberflutetet", "überformet", "ueberformet", "überformtet", "ueberformtet", "überfrachtetet", "ueberfrachtetet", "überfracht", "ueberfracht", "überfraget", "ueberfraget", "überfragtet", "ueberfragtet", "überfremdetet", "ueberfremdetet", "überfrisst", "ueberfrisst", "überfrißt", "ueberfrißt", "überfresst", "ueberfresst", "überfreßt", "ueberfreßt", "überfresset", "ueberfresset", "überfraßt", "ueberfraßt", "ueberfrasst", "überfräßet", "ueberfraesset", "überfriert", "ueberfriert", "überfrieret", "ueberfrieret", "überfrort", "ueberfrort", "überfröret", "ueberfroeret", "überfrört", "ueberfroert", "überführet", "ueberfuehret", "überführtet", "ueberfuehrtet", "überfüllet", "ueberfuellet", "übergibt", "uebergibt", "übergebt", "uebergebt", "übergebet", "uebergebet", "übergabt", "uebergabt", "übergäbet", "uebergaebet", "übergäbt", "uebergaebt", "übergeht", "uebergeht", "übergehet", "uebergehet", "übergingt", "uebergingt", "übergewichtetet", "uebergewichtetet", "übergießet", "uebergiesset", "übergießt", "uebergiesst", "übergösset", "uebergoesset", "übergosst", "uebergosst", "uebergoßt", "übergipset", "uebergipset", "übergipstet", "uebergipstet", "übergipset", "uebergipset", "übergipstet", "uebergipstet", "überglänzet", "ueberglaenzet", "überglänztet", "ueberglaenztet", "überglaset", "ueberglaset", "überglastet", "ueberglastet", "überglühet", "uebergluehet", "überglühtet", "uebergluehtet", "übergoldetet", "uebergoldetet", "übergraset", "uebergraset", "übergrastet", "uebergrastet", "übergrätschet", "uebergraetschet", "übergrätschtet", "uebergraetschtet", "übergreift", "uebergreift", "übergreifet", "uebergreifet", "übergrifft", "uebergrifft", "übergriffet", "uebergriffet", "übergreift", "uebergreift", "übergreifet", "uebergreifet", "übergriffet", "uebergriffet", "übergrifft", "uebergrifft", "übergrünet", "uebergruenet", "übergrüntet", "uebergruentet", "überhat", "ueberhat", "überhabt", "ueberhabt", "überhabet", "ueberhabet", "überhattet", "ueberhattet", "überhättet", "ueberhaettet", "überhält", "ueberhaelt", "überhaltet", "ueberhaltet", "überhielt", "ueberhielt", "überhieltet", "ueberhieltet", "überhändiget", "ueberhaendiget", "überhändigtet", "ueberhaendigtet", "überhängt", "ueberhaengt", "überhänget", "ueberhaenget", "überhingt", "ueberhingt", "überhinget", "ueberhinget", "überhängt", "ueberhaengt", "überhänget", "ueberhaenget", "überhängtet", "ueberhaengtet", "überhänget", "ueberhaenget", "überhängtet", "ueberhaengtet", "überhängt", "ueberhaengt", "überhänget", "ueberhaenget", "überhingt", "ueberhingt", "überhinget", "ueberhinget", "überhastetet", "ueberhastetet", "überhäufet", "ueberhaeufet", "überhäuftet", "ueberhaeuftet", "überhebt", "ueberhebt", "überhebet", "ueberhebet", "überhobt", "ueberhobt", "überhöbet", "ueberhoebet", "überhebt", "ueberhebt", "überhebet", "ueberhebet", "überhobt", "ueberhobt", "überheiztet", "ueberheiztet", "überheizet", "ueberheizet", "überhöhet", "ueberhoehet", "überhöhtet", "ueberhoehtet", "überhitzet", "ueberhitzet", "überhitztet", "ueberhitztet", "überholet", "ueberholet", "überholtet", "ueberholtet", "überhöret", "ueberhoeret", "überhörtet", "ueberhoertet", "überinterpretieret", "ueberinterpretieret", "überinterpretiertet", "ueberinterpretiertet", "überinterpretieret", "ueberinterpretieret", "überinterpretiertet", "ueberinterpretiertet", "überklebet", "ueberklebet", "überklebtet", "ueberklebtet", "überkleidetet", "ueberkleidetet", "überkochet", "ueberkochet", "überkochtet", "ueberkochtet", "überkommet", "ueberkommet", "überkamt", "ueberkamt", "überkämet", "ueberkaemet", "überkämt", "ueberkaemt", "überkompensieret", "ueberkompensieret", "überkompensiertet", "ueberkompensiertet", "überkreuzet", "ueberkreuzet", "überkreuztet", "ueberkreuztet", "überkronet", "ueberkronet", "überkrontet", "ueberkrontet", "überkrustetet", "ueberkrustetet", "überladet", "ueberladet", "überludet", "ueberludet", "überlüdet", "ueberluedet", "überlappet", "ueberlappet", "überlapptet", "ueberlapptet", "überlasset", "ueberlasset", "überlaßt", "ueberlaßt", "ueberlasst", "ueberlasst", "überlässt", "ueberlaesst", "überließt", "ueberließt", "ueberliesst", "überließet", "ueberließet", "ueberliesset", "überlastet", "ueberlastet", "überlastetet", "ueberlastetet", "überläuft", "ueberlaeuft", "überlaufet", "ueberlaufet", "überlieft", "ueberlieft", "überliefet", "ueberliefet", "überlebet", "ueberlebet", "überlebtet", "ueberlebtet", "überleget", "ueberleget", "überlegtet", "ueberlegtet", "überlegt", "ueberlegt", "überleget", "ueberleget", "überlegtet", "ueberlegtet", "überleitet", "ueberleitet", "überleitetet", "ueberleitetet", "überleset", "ueberleset", "überlast", "ueberlast", "überläset", "ueberlaeset", "überliegt", "ueberliegt", "überlieget", "ueberlieget", "überlagt", "ueberlagt", "überläget", "ueberlaeget", "überlägt", "ueberlaegt", "überlistetet", "ueberlistetet", "übermachet", "uebermachet", "übermachtet", "uebermachtet", "übermalet", "uebermalet", "übermaltet", "uebermaltet", "übermalet", "uebermalet", "übermaltet", "uebermaltet", "übermannet", "uebermannet", "übermanntet", "uebermanntet", "übermarchtet", "uebermarchtet", "übermarchet", "uebermarchet", "übermästetet", "uebermaestetet", "übermüdetet", "uebermuedetet", "übernächtiget", "uebernaechtiget", "übernächtigtet", "uebernaechtigtet", "übernimmt", "uebernimmt", "übernehmt", "uebernehmt", "übernehmet", "uebernehmet", "übernahmt", "uebernahmt", "übernähmet", "uebernaehmet", "übernähmt", "uebernaehmt", "übernutzet", "uebernutzet", "übernutztet", "uebernutztet", "überpflanzt", "ueberpflanzt", "überpflanzet", "ueberpflanzet", "überpflanztet", "ueberpflanztet", "überplanet", "ueberplanet", "überplantet", "ueberplantet", "überprüfet", "ueberpruefet", "überprüftet", "ueberprueftet", "überquillt", "ueberquillt", "überquellt", "ueberquellt", "überquellet", "ueberquellet", "überquollt", "ueberquollt", "überquöllet", "ueberquoellet", "ueberquöllt", "ueberquoellt", "überqueret", "ueberqueret", "überquertet", "ueberquertet", "überraget", "ueberraget", "überragtet", "ueberragtet", "überragt", "ueberragt", "überraget", "ueberraget", "überragtet", "ueberragtet", "überraschet", "ueberraschet", "überraschtet", "ueberraschtet", "überreagieret", "ueberreagieret", "überreagiertet", "ueberreagiertet", "überrechnetet", "ueberrechnetet", "überredetet", "ueberredetet", "überreglementieret", "ueberreglementieret", "überreglementiertet", "ueberreglementiertet", "überregulieret", "ueberregulieret", "überreguliertet", "ueberreguliertet", "überreichet", "ueberreichet", "überreichtet", "ueberreichtet", "überreißet", "ueberreisset", "überrisset", "ueberrisset", "überreitet", "ueberreitet", "überrittet", "ueberrittet", "überreizet", "ueberreizet", "überreiztet", "ueberreiztet", "überrennet", "ueberrennet", "überrenntet", "ueberrenntet", "überrollet", "ueberrollet", "überrolltet", "ueberrolltet", "überrundetet", "ueberrundetet", "übersäet", "uebersaeet", "übersätet", "uebersaetet", "übersättiget", "uebersaettiget", "uebersaettigtet", "übersättigtet", "überschattetet", "ueberschattetet", "überschätzet", "ueberschaetzet", "überschätztet", "ueberschaetztet", "überschauet", "ueberschauet", "überschautet", "ueberschautet", "überschäumt", "ueberschaeumt", "überschäumet", "ueberschaeumet", "überschäumtet", "ueberschaeumtet", "überschießt", "ueberschießt", "ueberschiesst", "überschießet", "ueberschiesset", "ueberschießet", "überschosst", "ueberschosst", "überschosst", "ueberschosst", "überschoßt", "ueberschoßt", "überschösset", "ueberschoesset", "überschlafet", "ueberschlafet", "überschliefet", "ueberschliefet", "überschlieft", "ueberschlieft", "überschlaget", "ueberschlaget", "überschlüget", "ueberschlueget", "überschlügt", "ueberschluegt", "überschlägt", "ueberschlaegt", "überschlagt", "ueberschlagt", "überschlaget", "ueberschlaget", "überschlugt", "ueberschlugt", "überschlüget", "ueberschlueget", "überschlügt", "ueberschluegt", "überschlägt", "ueberschlaegt", "überschlagt", "ueberschlagt", "überschlaget", "ueberschlaget", "überschlugt", "ueberschlugt", "überschlüget", "ueberschlueget", "ueberschluegt", "überschlügt", "überschließt", "ueberschließt", "ueberschliesst", "überschließet", "ueberschliesset", "überschlosst", "ueberschlosst", "überschloßt", "ueberschlosst", "überschlösset", "ueberschloesset", "überschmieret", "ueberschmieret", "überschmiertet", "ueberschmiertet", "überschminket", "ueberschminket", "überschminktet", "ueberschminktet", "überschnappt", "ueberschnappt", "überschnappet", "ueberschnappet", "überschnapptet", "ueberschnapptet", "überschneidet", "ueberschneidet", "überschnittet", "ueberschnittet", "überschneiet", "ueberschneiet", "überschneitet", "ueberschneitet", "überschreibet", "ueberschreibet", "überschriebet", "ueberschriebet", "überschriebt", "ueberschriebt", "überschreiet", "ueberschreiet", "überschrieet", "ueberschrieet", "überschriet", "ueberschriet", "überschriet", "ueberschriet", "überschreitet", "ueberschreitet", "überschritt", "ueberschritt", "überschrittet", "ueberschrittet", "überschuldetet", "ueberschuldetet", "überschüttet", "ueberschüttet", "überschüttetet", "ueberschüttetet", "überschüttetet", "ueberschuettetet", "überschwappt", "ueberschwappt", "überschwappet", "ueberschwappet", "überschwapptet", "ueberschwapptet", "überschwemmet", "ueberschwemmet", "überschwemmtet", "ueberschwemmtet", "überschwinget", "ueberschwinget", "überschwangt", "ueberschwangt", "überschwänget", "ueberschwaenget", "überschwängt", "ueberschwaengt", "übersieht", "uebersieht", "überseht", "ueberseht", "übersehet", "uebersehet", "übersaht", "uebersaht", "übersähet", "uebersaehet", "übersäht", "uebersaeht", "übersähet", "uebersaehet", "übersäht", "uebersaeht", "übersandtet", "uebersandtet", "übersendetet", "uebersendetet", "übersensibilisieret", "uebersensibilisieret", "übersensibilisiertet", "uebersensibilisiertet", "übersetzt", "uebersetzt", "übersetzet", "uebersetzet", "übersetztet", "uebersetztet", "übersetzet", "uebersetzet", "übersetztet", "uebersetztet", "übersiedet", "uebersiedet", "übersiedetet", "uebersiedetet", "übersott", "uebersott", "übersottet", "uebersottet", "übersöttet", "uebersoettet", "übersiedet", "uebersiedet", "übersiedetet", "uebersiedetet", "übersott", "uebersott", "übersottet", "uebersottet", "übersöttet", "uebersoettet", "überspannet", "ueberspannet", "überspanntet", "ueberspanntet", "überspielet", "ueberspielet", "überspieltet", "ueberspieltet", "überspinnet", "ueberspinnet", "überspännet", "ueberspaennet", "überspännt", "ueberspaennt", "überspönnet", "ueberspoennet", "überspönnt", "ueberspoennt", "überspitzet", "ueberspitzet", "überspitztet", "ueberspitztet", "übersprechet", "uebersprechet", "überspracht", "ueberspracht", "übersprächet", "ueberspraechet", "übersprächt", "ueberspraecht", "überspringt", "ueberspringt", "überspringet", "ueberspringet", "überspränget", "ueberspraenget", "übersprängt", "ueberspraengt", "überspringt", "ueberspringt", "überspringet", "ueberspringet", "übersprangt", "uebersprangt", "überspränget", "ueberspraenget", "übersprängt", "ueberspraengt", "übersprühet", "ueberspruehet", "übersprühtet", "ueberspruehtet", "übersprühet", "ueberspruehet", "übersprühtet", "ueberspruehtet", "überspület", "ueberspuelet", "überspültet", "überspueltet", "übersticht", "uebersticht", "überstecht", "ueberstecht", "überstechet", "ueberstechet", "überstacht", "ueberstacht", "überstächet", "ueberstaechet", "überstächt", "ueberstaecht", "übersticht", "uebersticht", "überstecht", "ueberstecht", "überstechet", "ueberstechet", "überstacht", "ueberstacht", "überstächet", "ueberstaechet", "überstächt", "ueberstaecht", "überstehet", "ueberstehet", "überstandet", "überstandet", "überständet", "überstaendet", "überstündet", "überstuendet", "übersteht", "uebersteht", "überstehet", "ueberstehet", "überstandet", "ueberstandet", "überständet", "ueberstaendet", "überstündet", "ueberstuendet", "übersteiget", "uebersteiget", "überstieget", "ueberstieget", "überstiegt", "ueberstiegt", "übersteigt", "uebersteigt", "übersteiget", "uebersteiget", "überstiegt", "ueberstiegt", "überstieget", "ueberstieget", "überstellet", "ueberstellet", "überstilisieret", "ueberstilisieret", "überstimmet", "ueberstimmet", "überstimmtet", "ueberstimmtet", "überstrahlet", "ueberstrahlet", "überstrahltet", "ueberstrahltet", "überstrapazieret", "ueberstrapazieret", "überstrapaziertet", "ueberstrapaziertet", "überstreicht", "ueberstreicht", "überstreichet", "ueberstreichet", "überstricht", "ueberstricht", "überstrichet", "ueberstrichet", "überstreichet", "ueberstreichet", "überstrichet", "ueberstrichet", "überstricht", "ueberstricht", "überstreift", "ueberstreift", "überstreifet", "ueberstreifet", "überstreiftet", "ueberstreiftet", "überstreuet", "ueberstreuet", "überstreutet", "ueberstreutet", "überströmet", "ueberstroemet", "überströmtet", "überstroemtet", "überstülpt", "überstuelpt", "ueberstuelpet", "überstülpet", "überstülptet", "ueberstuelptet", "überstürzet", "ueberstuerzet", "überstürztet", "ueberstuerztet", "übertäubet", "uebertaeubet", "übertäubtet", "uebertaeubtet", "übertauchet", "uebertauchet", "übertauchtet", "uebertauchtet", "übertippet", "uebertippet", "übertipptet", "uebertipptet", "übertönet", "uebertoenet", "übertöntet", "uebertoentet", "übertouret", "uebertouret", "übertourtet", "uebertourtet", "überträgt", "uebertraegt", "übertragt", "uebertragt", "übertraget", "uebertraget", "übertrugt", "uebertrugt", "übertrüget", "uebertrueget", "übertrügt", "uebertruegt", "übertrainieret", "uebertrainieret", "übertrainiertet", "uebertrainiertet", "übertreffet", "uebertreffet", "übertraft", "uebertraft", "überträfet", "uebertraefet", "überträft", "uebertraeft", "übertreibt", "uebertreibt", "übertreibet", "uebertreibet", "übertriebet", "uebertriebet", "übertriebt", "uebertriebt", "übertritt", "uebertritt", "übertretet", "uebertretet", "übertrat", "uebertrat", "übertratet", "uebertratet", "überträtet", "uebertraetet", "übertritt", "uebertritt", "übertretet", "uebertretet", "übertrat", "uebertrat", "übertratet", "uebertratet", "überträtet", "uebertraetet", "übertrumpfet", "uebertrumpfet", "übertrumpftet", "uebertrumpftet", "übertünchet", "uebertuenchet", "übertünchtet", "überversorget", "ueberversorget", "überversorgtet", "ueberversorgtet", "übervorteilet", "uebervorteilet", "übervorteiltet", "uebervorteiltet", "überwachet", "ueberwachet", "überwachtet", "ueberwachtet", "überwachset", "ueberwachset", "überwüchset", "ueberwuechset", "überwallt", "ueberwallt", "überwallet", "ueberwallet", "überwalltet", "ueberwalltet", "überwallet", "ueberwallet", "überwalltet", "ueberwalltet", "überwältiget", "ueberwaeltiget", "überwältigtet", "ueberwaeltigtet", "überwalzet", "ueberwalzet", "überwalztet", "ueberwalztet", "überwälzet", "ueberwaelzet", "überwälztet", "ueberwaelztet", "überwechtetet", "ueberwechtetet", "überwächtetet", "ueberwaechtetet", "überwehet", "ueberwehet", "überwehtet", "ueberwehtet", "überweidetet", "ueberweidetet", "überweist", "ueberweist", "überweiset", "ueberweiset", "überwiest", "ueberwiest", "überwieset", "ueberwieset", "überweißet", "ueberweisset", "überweißtet", "ueberweisstet", "überwirft", "ueberwirft", "überwerft", "ueberwerft", "überwerfet", "ueberwerfet", "überwarft", "ueberwarft", "überwürfet", "ueberwuerfet", "überwürft", "ueberwuerft", "überwirft", "ueberwirft", "überwerft", "ueberwerft", "überwerfet", "ueberwerfet", "überwarft", "ueberwarft", "überwürfet", "ueberwuerfet", "überwürft", "ueberwuerft", "überwertetet", "ueberwertetet", "überwiegt", "ueberwiegt", "überwieget", "ueberwieget", "überwogt", "ueberwogt", "überwöget", "ueberwoeget", "überwögt", "ueberwoegt", "überwindet", "ueberwindet", "überwandet", "ueberwandet", "überwändet", "ueberwaendet", "überwölbet", "ueberwoelbet", "überwölbtet", "ueberwoelbtet", "ueberwuerzet", "ueberwuerzet", "überwürztet", "ueberwuerztet", "überzahlet", "ueberzahlet", "überzahltet", "ueberzahltet", "überzahltet", "ueberzahltet", "überzeichnetet", "ueberzeichnetet", "überzeuget", "ueberzeuget", "überzeugtet", "ueberzeugtet", "überzieht", "ueberzieht", "überziehet", "ueberziehet", "überzogt", "ueberzogt", "überzöget", "ueberzoeget", "überzögt", "ueberzoegt", "überzüchtetet", "ueberzuechtetet", "überangebot", "ueberangebot", "überbrückungskredit", "ueberbrückungskredit", "übereinkunft", "uebereinkunft", "überfahrt", "ueberfahrt", "überflugverbot", "ueberflugverbot", "überflutungsgebiet", "ueberflutungsgebiet", "überfracht", "ueberfracht", "überfrucht", "ueberfrucht", "übergangslaut", "uebergangslaut", "übergebot", "uebergebot", "übergewicht", "uebergewicht", "überhangmandat", "ueberhangmandat", "überhangsrecht", "ueberhangsrecht", "überholverbot", "ueberholverbot", "überladenheit", "ueberladenheit", "überlandfahrt", "ueberlandfahrt", "überlast", "ueberlast", "überlegenheit", "ueberlegenheit", "übermacht", "uebermacht", "übermaßverbot", "uebermassverbot", "übermut", "uebermut", "überraschungseffekt", "ueberraschungseffekt", "überraschungsgast", "ueberraschungsgast", "überraschungsmoment", "ueberraschungsmoment", "überredungskunst", "ueberredungskunst", "überreiztheit", "ueberreiztheit", "überrest", "ueberrest", "überschicht", "ueberschicht", "überschnitt", "ueberschnitt", "überschrift", "ueberschrift", "überschwemmungsgebiet", "ueberschwemmungsgebiet", "überseegebiet", "ueberseegebiet", "überseegeschäft", "ueberseegeschaeft", "übersicht", "uebersicht", "überspanntheit", "ueberspanntheit", "überspitztheit", "ueberspitztheit", "übertragungsrecht", "uebertragungsrecht", "übertriebenheit", "uebertriebenheit", "übertritt", "uebertritt", "überwachungsdienst", "ueberwachungsdienst", "überwachungsstaat", "ueberwachungsstaat", "überwelt", "ueberwelt", "überwinterungsgebiet", "ueberwinterungsgebiet", "überzeugtheit", "ueberzeugtheit", "überzeugungstat", "ueberzeugungstat", "überziehungskredit", "ueberziehungskredit"]; }; }), (function (module, exports, __webpack_require__) {
        "use strict"; var arrayToRegex = __webpack_require__(51); var auxiliaries = __webpack_require__(53)().allAuxiliaries; var getParticiples = __webpack_require__(192); var determineSentencePartIsPassive = __webpack_require__(191); var auxiliaryRegex = arrayToRegex(auxiliaries); module.exports = function (sentencePartText, auxiliaries) {
            var passive = false; var auxiliaryMatches = sentencePartText.match(auxiliaryRegex); if (auxiliaryMatches === null) { return passive; }
            var participles = getParticiples(sentencePartText, auxiliaries); return determineSentencePartIsPassive(participles);
        };
    }), (function (module, exports, __webpack_require__) {
        "use strict"; var getWords = __webpack_require__(27); var stripSpaces = __webpack_require__(8); var stripTags = __webpack_require__(7).stripFullTags; var getFirstWordExceptions = __webpack_require__(411); var isEmpty = __webpack_require__(10); var forEach = __webpack_require__(1); var filter = __webpack_require__(6); var startsWithSameWord = function startsWithSameWord(currentSentenceBeginning, nextSentenceBeginning) {
            if (!isEmpty(currentSentenceBeginning) && currentSentenceBeginning === nextSentenceBeginning) { return true; }
            return false;
        }; var compareFirstWords = function compareFirstWords(sentenceBeginnings, sentences) { var consecutiveFirstWords = []; var foundSentences = []; var sameBeginnings = 1; forEach(sentenceBeginnings, function (beginning, i) { var currentSentenceBeginning = beginning; var nextSentenceBeginning = sentenceBeginnings[i + 1]; foundSentences.push(sentences[i]); if (startsWithSameWord(currentSentenceBeginning, nextSentenceBeginning)) { sameBeginnings++; } else { consecutiveFirstWords.push({ word: currentSentenceBeginning, count: sameBeginnings, sentences: foundSentences }); sameBeginnings = 1; foundSentences = []; } }); return consecutiveFirstWords; }; function sanitizeSentence(sentence) { sentence = stripTags(sentence); sentence = sentence.replace(/^[^A-Za-z0-9]/, ""); return sentence; }
        function getSentenceBeginning(sentence, firstWordExceptions) {
            sentence = sanitizeSentence(sentence); var words = getWords(stripSpaces(sentence)); if (words.length === 0) { return ""; }
            var firstWord = words[0].toLocaleLowerCase(); if (firstWordExceptions.indexOf(firstWord) > -1 && words.length > 1) { firstWord += " " + words[1]; }
            return firstWord;
        }
        module.exports = function (paper, researcher) { var sentences = researcher.getResearch("sentences"); var firstWordExceptions = getFirstWordExceptions(paper.getLocale())(); var sentenceBeginnings = sentences.map(function (sentence) { return getSentenceBeginning(sentence, firstWordExceptions); }); sentences = sentences.filter(function (sentence) { return getWords(stripSpaces(sentence)).length > 0; }); sentenceBeginnings = filter(sentenceBeginnings); return compareFirstWords(sentenceBeginnings, sentences); };
    }), (function (module, exports, __webpack_require__) { "use strict"; var firstWordExceptionsEnglish = __webpack_require__(412); var firstWordExceptionsGerman = __webpack_require__(413); var firstWordExceptionsSpanish = __webpack_require__(414); var firstWordExceptionsFrench = __webpack_require__(415); var firstWordExceptionsDutch = __webpack_require__(416); var firstWordExceptionsItalian = __webpack_require__(417); var getLanguage = __webpack_require__(20); module.exports = function (locale) { switch (getLanguage(locale)) { case "de": return firstWordExceptionsGerman; case "fr": return firstWordExceptionsFrench; case "es": return firstWordExceptionsSpanish; case "nl": return firstWordExceptionsDutch; case "it": return firstWordExceptionsItalian; default: case "en": return firstWordExceptionsEnglish; } }; }), (function (module, exports, __webpack_require__) { "use strict"; module.exports = function () { return ["the", "a", "an", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine", "ten", "this", "that", "these", "those"]; }; }), (function (module, exports, __webpack_require__) { "use strict"; module.exports = function () { return ["das", "dem", "den", "der", "des", "die", "ein", "eine", "einem", "einen", "einer", "eines", "eins", "zwei", "drei", "vier", "fünf", "sechs", "sieben", "acht", "neun", "zehn", "denen", "deren", "derer", "dessen", "diese", "diesem", "diesen", "dieser", "dieses", "jene", "jenem", "jenen", "jener", "jenes", "welch", "welcher", "welches"]; }; }), (function (module, exports, __webpack_require__) { "use strict"; module.exports = function () { return ["el", "los", "la", "las", "un", "una", "unas", "unos", "uno", "dos", "tres", "cuatro", "cinco", "seis", "siete", "ocho", "nueve", "diez", "este", "estos", "esta", "estas", "ese", "esos", "esa", "esas", "aquel", "aquellos", "aquella", "aquellas", "esto", "eso", "aquello"]; }; }), (function (module, exports, __webpack_require__) { "use strict"; module.exports = function () { return ["le", "la", "les", "un", "une", "deux", "trois", "quatre", "cinq", "six", "sept", "huit", "neuf", "dix", "celui", "celle", "ceux", "celles", "celui-ci", "celle-là", "celui-là", "celle-ci"]; }; }), (function (module, exports, __webpack_require__) { "use strict"; module.exports = function () { return ["de", "het", "een", "één", "eén", "twee", "drie", "vier", "vijf", "zes", "zeven", "acht", "negen", "tien", "dit", "dat", "die", "deze"]; }; }), (function (module, exports, __webpack_require__) { "use strict"; module.exports = function () { return ["il", "lo", "la", "i", "gli", "le", "uno", "un", "una", "due", "tre", "quattro", "cinque", "sei", "sette", "otto", "nove", "dieci", "questo", "questa", "quello", "quella", "questi", "queste", "quelli", "quelle", "codesto", "codesti", "codesta", "codeste"]; }; }), (function (module, exports, __webpack_require__) {
        "use strict"; var getRelevantWords = __webpack_require__(419).getRelevantWords; function relevantWords(paper) { return getRelevantWords(paper.getText(), paper.getLocale()); }
        module.exports = relevantWords;
    }), (function (module, exports, __webpack_require__) {
        "use strict"; var getWords = __webpack_require__(27); var getSentences = __webpack_require__(22); var WordCombination = __webpack_require__(420); var normalizeQuotes = __webpack_require__(74).normalize; var germanFunctionWords = __webpack_require__(422); var englishFunctionWords = __webpack_require__(111); var dutchFunctionWords = __webpack_require__(423); var spanishFunctionWords = __webpack_require__(424); var italianFunctionWords = __webpack_require__(425); var frenchFunctionWords = __webpack_require__(426); var getLanguage = __webpack_require__(20); var filter = __webpack_require__(6); var map = __webpack_require__(2); var forEach = __webpack_require__(1); var has = __webpack_require__(193); var flatMap = __webpack_require__(72); var values = __webpack_require__(185); var take = __webpack_require__(427); var includes = __webpack_require__(29); var intersection = __webpack_require__(190); var isEmpty = __webpack_require__(10); var densityLowerLimit = 0; var densityUpperLimit = 0.03; var relevantWordLimit = 100; var wordCountLowerLimit = 200; var specialCharacters = ["–", "—", "-", "\xA9", "#", "%", "/", "\\", "$", "€", "£", "*", "•", "|", "→", "←", "}", "{", "//", "||", "\u200B"]; function getWordCombinations(text, combinationSize, functionWords) {
            var sentences = getSentences(text); var words = void 0, combination = void 0; return flatMap(sentences, function (sentence) {
                sentence = sentence.toLocaleLowerCase(); sentence = normalizeQuotes(sentence); words = getWords(sentence); return filter(map(words, function (word, i) {
                    if (i + combinationSize - 1 < words.length) { combination = words.slice(i, i + combinationSize); return new WordCombination(combination, 0, functionWords); }
                    return false;
                }));
            });
        }
        function calculateOccurrences(wordCombinations) {
            var occurrences = {}; forEach(wordCombinations, function (wordCombination) {
                var combination = wordCombination.getCombination(); if (!has(occurrences, combination)) { occurrences[combination] = wordCombination; }
                occurrences[combination].incrementOccurrences();
            }); return values(occurrences);
        }
        function getRelevantCombinations(wordCombinations) { wordCombinations = wordCombinations.filter(function (combination) { return combination.getOccurrences() !== 1 && combination.getRelevance() !== 0; }); return wordCombinations; }
        function sortCombinations(wordCombinations) {
            wordCombinations.sort(function (combinationA, combinationB) {
                var difference = combinationB.getRelevance() - combinationA.getRelevance(); if (difference !== 0) { return difference; }
                return combinationB.getLength() - combinationA.getLength();
            });
        }
        function filterOneCharacterWordCombinations(wordCombinations) { return wordCombinations.filter(function (combination) { return !(combination.getLength() === 1 && combination.getWords()[0].length <= 1); }); }
        function filterFunctionWordsAnywhere(wordCombinations, functionWords) { return wordCombinations.filter(function (combination) { return isEmpty(intersection(functionWords, combination.getWords())); }); }
        function filterFunctionWordsAtBeginning(wordCombinations, functionWords) { return wordCombinations.filter(function (combination) { return !includes(functionWords, combination.getWords()[0]); }); }
        function filterFunctionWordsAtEnding(wordCombinations, functionWords) { return wordCombinations.filter(function (combination) { var words = combination.getWords(); var lastWordIndex = words.length - 1; return !includes(functionWords, words[lastWordIndex]); }); }
        function filterFunctionWordsAtBeginningAndEnding(wordCombinations, functionWords) { wordCombinations = filterFunctionWordsAtBeginning(wordCombinations, functionWords); wordCombinations = filterFunctionWordsAtEnding(wordCombinations, functionWords); return wordCombinations; }
        function filterOnDensity(wordCombinations, wordCount, densityLowerLimit, densityUpperLimit) { return wordCombinations.filter(function (combination) { return combination.getDensity(wordCount) >= densityLowerLimit && combination.getDensity(wordCount) < densityUpperLimit; }); }
        function filterFunctionWords(combinations, functionWords) { combinations = filterFunctionWordsAnywhere(combinations, functionWords().filteredAnywhere); combinations = filterFunctionWordsAtBeginningAndEnding(combinations, functionWords().filteredAtBeginningAndEnding); combinations = filterFunctionWordsAtEnding(combinations, functionWords().filteredAtEnding); combinations = filterFunctionWordsAtBeginning(combinations, functionWords().filteredAtBeginning); return combinations; }
        function filterCombinations(combinations, functionWords) { combinations = filterFunctionWordsAnywhere(combinations, specialCharacters); combinations = filterOneCharacterWordCombinations(combinations); combinations = filterFunctionWords(combinations, functionWords); return combinations; }
        function getRelevantWords(text, locale) {
            var functionWords = void 0; switch (getLanguage(locale)) { case "de": functionWords = germanFunctionWords; break; case "nl": functionWords = dutchFunctionWords; break; case "fr": functionWords = frenchFunctionWords; break; case "es": functionWords = spanishFunctionWords; break; case "it": functionWords = italianFunctionWords; break; default: case "en": functionWords = englishFunctionWords; break; }
            var words = getWordCombinations(text, 1, functionWords().all); var wordCount = words.length; var oneWordCombinations = getRelevantCombinations(calculateOccurrences(words)); sortCombinations(oneWordCombinations); oneWordCombinations = take(oneWordCombinations, 100); var oneWordRelevanceMap = {}; forEach(oneWordCombinations, function (combination) { oneWordRelevanceMap[combination.getCombination()] = combination.getRelevance(functionWords); }); var twoWordCombinations = calculateOccurrences(getWordCombinations(text, 2, functionWords().all)); var threeWordCombinations = calculateOccurrences(getWordCombinations(text, 3, functionWords().all)); var fourWordCombinations = calculateOccurrences(getWordCombinations(text, 4, functionWords().all)); var fiveWordCombinations = calculateOccurrences(getWordCombinations(text, 5, functionWords().all)); var combinations = oneWordCombinations.concat(twoWordCombinations, threeWordCombinations, fourWordCombinations, fiveWordCombinations); combinations = filterCombinations(combinations, functionWords); forEach(combinations, function (combination) { combination.setRelevantWords(oneWordRelevanceMap); }); combinations = getRelevantCombinations(combinations, wordCount); sortCombinations(combinations); if (wordCount >= wordCountLowerLimit) { combinations = filterOnDensity(combinations, wordCount, densityLowerLimit, densityUpperLimit); }
            return take(combinations, relevantWordLimit);
        }
        module.exports = { getWordCombinations: getWordCombinations, getRelevantWords: getRelevantWords, calculateOccurrences: calculateOccurrences, getRelevantCombinations: getRelevantCombinations, sortCombinations: sortCombinations, filterFunctionWordsAtEnding: filterFunctionWordsAtEnding, filterFunctionWordsAtBeginning: filterFunctionWordsAtBeginning, filterFunctionWords: filterFunctionWordsAtBeginningAndEnding, filterFunctionWordsAnywhere: filterFunctionWordsAnywhere, filterOnDensity: filterOnDensity, filterOneCharacterWordCombinations: filterOneCharacterWordCombinations };
    }), (function (module, exports, __webpack_require__) {
        "use strict"; var forEach = __webpack_require__(1); var has = __webpack_require__(193); function isFunctionWord(word, functionWords) { return -1 !== functionWords.indexOf(word.toLocaleLowerCase()); }
        function WordCombination(words, occurrences, functionWords) { this._words = words; this._length = words.length; this._occurrences = occurrences || 0; this._functionWords = functionWords; }
        WordCombination.lengthBonus = { 2: 3, 3: 7, 4: 12, 5: 18 }; WordCombination.prototype.getLengthBonus = function () {
            if (has(WordCombination.lengthBonus, this._length)) { return WordCombination.lengthBonus[this._length]; }
            return 0;
        }; WordCombination.prototype.getWords = function () { return this._words; }; WordCombination.prototype.getLength = function () { return this._length; }; WordCombination.prototype.getCombination = function () { return this._words.join(" "); }; WordCombination.prototype.getOccurrences = function () { return this._occurrences; }; WordCombination.prototype.incrementOccurrences = function () { this._occurrences += 1; }; WordCombination.prototype.getMultiplier = function (relevantWordPercentage) { var lengthBonus = this.getLengthBonus(); return 1 + relevantWordPercentage * lengthBonus; }; WordCombination.prototype.isRelevantWord = function (word) { return has(this._relevantWords, word); }; WordCombination.prototype.getRelevantWordPercentage = function () {
            var relevantWordCount = 0, wordRelevance = 1; if (this._length > 1) { forEach(this._words, function (word) { if (this.isRelevantWord(word)) { relevantWordCount += 1; } }.bind(this)); wordRelevance = relevantWordCount / this._length; }
            return wordRelevance;
        }; WordCombination.prototype.getRelevance = function () {
            if (this._words.length === 1 && isFunctionWord(this._words[0], this._functionWords)) { return 0; }
            var wordRelevance = this.getRelevantWordPercentage(); if (wordRelevance === 0) { return 0; }
            return this.getMultiplier(wordRelevance) * this._occurrences;
        }; WordCombination.prototype.setRelevantWords = function (relevantWords) { this._relevantWords = relevantWords; }; WordCombination.prototype.getDensity = function (wordCount) { return this._occurrences / wordCount; }; module.exports = WordCombination;
    }), (function (module, exports) {
        var objectProto = Object.prototype; var hasOwnProperty = objectProto.hasOwnProperty; function baseHas(object, key) { return object != null && hasOwnProperty.call(object, key); }
        module.exports = baseHas;
    }), (function (module, exports, __webpack_require__) { "use strict"; var filteredPassiveAuxiliaries = __webpack_require__(53)().filteredAuxiliaries; var passiveAuxiliariesInfinitive = __webpack_require__(53)().infinitiveAuxiliaries; var transitionWords = __webpack_require__(180)().singleWords; var articles = ["das", "dem", "den", "der", "des", "die", "ein", "eine", "einem", "einen", "einer", "eines"]; var cardinalNumerals = ["eins", "zwei", "drei", "vier", "fünf", "sechs", "sieben", "acht", "neun", "zehn", "elf", "zwölf", "zwoelf", "dreizehn", "vierzehn", "fünfzehn", "fuenfzehn", "sechzehn", "siebzehn", "achtzehn", "neunzehn", "zwanzig", "hundert", "einhundert", "zweihundert", "dreihundert", "vierhundert", "fünfhundert", "fuenfhundert", "sechshundert", "siebenhundert", "achthundert", "neunhundert", "tausend", "million", "milliarde", "billion", "billiarde"]; var ordinalNumerals = ["erste", "erster", "ersten", "erstem", "erstes", "zweite", "zweites", "zweiter", "zweitem", "zweiten", "dritte", "dritter", "drittes", "dritten", "drittem", "vierter", "vierten", "viertem", "viertes", "vierte", "fünfte", "fünfter", "fünftes", "fünften", "fünftem", "fuenfte", "fuenfter", "fuenftem", "fuenften", "fuenftes", "sechste", "sechster", "sechstes", "sechsten", "sechstem", "siebte", "siebter", "siebten", "siebtem", "siebtes", "achte", "achter", "achten", "achtem", "achtes", "neunte", "neunter", "neuntes", "neunten", "neuntem", "zehnte", "zehnter", "zehnten", "zehntem", "zehntes", "elfte", "elfter", "elftes", "elften", "elftem", "zwölfte", "zwölfter", "zwölften", "zwölftem", "zwölftes", "zwoelfte", "zwoelfter", "zwoelften", "zwoelftem", "zwoelftes", "dreizehnte", "dreizehnter", "dreizehntes", "dreizehnten", "dreizehntem", "vierzehnte", "vierzehnter", "vierzehntes", "vierzehnten", "vierzehntem", "fünfzehnte", "fünfzehnten", "fünfzehntem", "fünfzehnter", "fünfzehntes", "fuenfzehnte", "fuenfzehnten", "fuenfzehntem", "fuenfzehnter", "fuenfzehntes", "sechzehnte", "sechzehnter", "sechzehnten", "sechzehntes", "sechzehntem", "siebzehnte", "siebzehnter", "siebzehntes", "siebzehntem", "siebzehnten", "achtzehnter", "achtzehnten", "achtzehntem", "achtzehntes", "achtzehnte", "nehnzehnte", "nehnzehnter", "nehnzehntem", "nehnzehnten", "nehnzehntes", "zwanzigste", "zwanzigster", "zwanzigstem", "zwanzigsten", "zwanzigstes"]; var personalPronounsNominative = ["ich", "du", "er", "sie", "es", "wir", "ihr"]; var personalPronounsAccusative = ["mich", "dich", "ihn", "uns", "euch"]; var personalPronounsDative = ["mir", "dir", "ihm", "ihnen"]; var demonstrativePronouns = ["denen", "deren", "derer", "dessen", "diese", "diesem", "diesen", "dieser", "dieses", "jene", "jenem", "jenen", "jener", "jenes", "welch", "welcher", "welches", "derjenige", "desjenigen", "demjenigen", "denjenigen", "diejenige", "derjenigen", "dasjenige", "diejenigen"]; var possessivePronouns = ["mein", "meine", "meinem", "meiner", "meines", "meinen", "dein", "deine", "deinem", "deiner", "deines", "deinen", "sein", "seine", "seinem", "seiner", "seines", "ihre", "ihrem", "ihren", "ihrer", "ihres", "unser", "unsere", "unserem", "unseren", "unserer", "unseres", "euer", "eure", "eurem", "euren", "eurer", "eures", "einanders"]; var quantifiers = ["manche", "manch", "viele", "viel", "vieler", "vielen", "vielem", "all", "alle", "aller", "alles", "allen", "allem", "allerlei", "solcherlei", "einige", "etliche", "wenige", "weniger", "wenigen", "wenigem", "weniges", "wenig", "wenigerer", "wenigeren", "wenigerem", "wenigere", "wenigeres", "wenig", "bisschen", "paar", "kein", "keines", "keinem", "keinen", "keine", "mehr", "genug", "mehrere", "mehrerer", "mehreren", "mehrerem", "mehreres", "verschiedene", "verschiedener", "verschiedenen", "verschiedenem", "verschiedenes", "verschiedne", "verschiedner", "verschiednen", "verschiednem", "verschiednes", "art", "arten", "sorte", "sorten"]; var reflexivePronouns = ["sich"]; var reciprocalPronouns = ["einander"]; var indefinitePronouns = ["andere", "anderer", "anderem", "anderen", "anderes", "andren", "andern", "andrem", "anderm", "andre", "andrer", "andres", "beide", "beides", "beidem", "beider", "beiden", "etwas", "irgendetwas", "irgendein", "irgendeinen", "irgendeinem", "irgendeines", "irgendeine", "irgendeiner", "irgendwas", "irgendwessen", "irgendwer", "irgendwen", "irgendwem", "irgendwelche", "irgendwelcher", "irgendwelchem", "irgendwelchen", "irgendwelches", "irgendjemand", "irgendjemanden", "irgendjemandem", "irgendjemandes", "irgendwie", "wer", "wen", "wem", "wessen", "was", "welchen", "welchem", "welche", "jeder", "jedes", "jedem", "jeden", "jede", "jedweder", "jedweden", "jedwedem", "jedwedes", "jedwede", "jeglicher", "jeglichen", "jeglichem", "jegliches", "jegliche", "jedermann", "jedermanns", "jemand", "jemanden", "jemandem", "jemands", "jemandes", "man", "meinesgleichen", "sämtlich", "saemtlich", "sämtlicher", "saemtlicher", "sämtlichen", "saemtlichen", "sämtlichem", "saemtlichem", "sämtliches", "saemtliches", "sämtliche", "saemtliche", "solche", "solcher", "solchen", "solchem", "solches", "niemand", "niemanden", "niemandem", "niemandes", "niemands", "nichts", "zweiter"]; var interrogativeProAdverbs = ["warum", "wie", "wo", "woher", "wohin", "wann"]; var pronominalAdverbs = ["dahinter", "damit", "daneben", "daran", "daraus", "darin", "darunter", "darüber", "darueber", "davon", "dazwischen", "hieran", "hierauf", "hieraus", "hierbei", "hierfuer", "hierfür", "hiergegen", "hierhinter", "hierin", "hiermit", "hiernach", "hierum", "hierunter", "hierueber", "hierüber", "hiervor", "hierzwischen", "hierneben", "hiervon", "wodurch", "wofür", "wofuer", "wogegen", "wohinter", "womit", "wonach", "woneben", "woran", "worauf", "woraus", "worin", "worum", "worunter", "worüber", "worueber", "wovon", "wovor", "wozu", "wozwischen"]; var locativeAdverbs = ["hier", "dorthin", "hierher", "dorther"]; var adverbialGenitives = ["allenfalls", "keinesfalls", "anderenfalls", "andernfalls", "andrenfalls", "äußerstenfalls", "bejahendenfalls", "bestenfalls", "eintretendenfalls", "entgegengesetztenfalls", "erforderlichenfalls", "gegebenenfalls", "geringstenfalls", "gleichfalls", "günstigenfalls", "günstigstenfalls", "höchstenfalls", "möglichenfalls", "notfalls", "nötigenfalls", "notwendigenfalls", "schlimmstenfalls", "vorkommendenfalls", "zutreffendenfalls", "keineswegs", "durchwegs", "geradenwegs", "geradeswegs", "geradewegs", "gradenwegs", "halbwegs", "mittwegs", "unterwegs"]; var otherAuxiliaries = ["habe", "hast", "hat", "habt", "habest", "habet", "hatte", "hattest", "hatten", "hätte", "haette", "hättest", "haettest", "hätten", "haetten", "haettet", "hättet", "hab", "bin", "bist", "ist", "sind", "sei", "seiest", "seien", "seiet", "war", "warst", "waren", "wart", "wäre", "waere", "wärest", "waerest", "wärst", "waerst", "wären", "waeren", "wäret", "waeret", "wärt", "waert", "seid", "darf", "darfst", "dürft", "duerft", "dürfe", "duerfe", "dürfest", "duerfest", "dürfet", "duerfet", "durfte", "durftest", "durften", "durftet", "dürfte", "duerfte", "dürftest", "duerftest", "dürften", "duerften", "dürftet", "duerftet", "kann", "kannst", "könnt", "koennt", "könne", "koenne", "könnest", "koennest", "könnet", "koennet", "konnte", "konntest", "konnten", "konntet", "könnte", "koennte", "könntest", "koenntest", "könnten", "koennten", "könntet", "koenntet", "mag", "magst", "mögt", "moegt", "möge", "moege", "mögest", "moegest", "möget", "moeget", "mochte", "mochtest", "mochten", "mochtet", "möchte", "moechte", "möchtest", "moechtest", "möchten", "moechten", "möchtet", "moechtet", "muss", "muß", "musst", "mußt", "müsst", "muesst", "müßt", "mueßt", "müsse", "muesse", "müssest", "muessest", "müsset", "muesset", "musste", "mußte", "musstest", "mußtest", "mussten", "mußten", "musstet", "mußtet", "müsste", "muesste", "müßte", "mueßte", "müsstest", "muesstest", "müßtest", "mueßtest", "müssten", "muessten", "müßten", "mueßten", "müsstet", "muesstet", "müßtet", "mueßtet", "soll", "sollst", "sollt", "solle", "sollest", "sollet", "sollte", "solltest", "sollten", "solltet", "will", "willst", "wollt", "wolle", "wollest", "wollet", "wollte", "wolltest", "wollten", "wolltet", "lasse", "lässt", "laesst", "läßt", "laeßt", "lasst", "laßt", "lassest", "lasset", "ließ", "ließest", "ließt", "ließen", "ließe", "ließet", "liess", "liessest", "liesst", "liessen", "liesse", "liesset"]; var otherAuxiliariesInfinitive = ["haben", "dürfen", "duerfen", "können", "koennen", "mögen", "moegen", "müssen", "muessen", "sollen", "wollen", "lassen"]; var copula = ["bleibe", "bleibst", "bleibt", "bleibest", "bleibet", "blieb", "bliebst", "bliebt", "blieben", "bliebe", "bliebest", "bliebet", "heiße", "heißt", "heißest", "heißet", "heisse", "heisst", "heissest", "heisset", "hieß", "hießest", "hießt", "hießen", "hieße", "hießet", "hiess", "hiessest", "hiesst", "hiessen", "hiesse", "hiesset", "giltst", "gilt", "geltet", "gelte", "geltest", "galt", "galtest", "galtst", "galten", "galtet", "gälte", "gaelte", "gölte", "goelte", "gältest", "gaeltest", "göltest", "goeltest", "gälten", "gaelten", "gölten", "goelten", "gältet", "gaeltet", "göltet", "goeltet", "aussehe", "aussiehst", "aussieht", "ausseht", "aussehest", "aussehet", "aussah", "aussahst", "aussahen", "aussaht", "aussähe", "aussaehe", "aussähest", "aussaehest", "aussähst", "aussaehst", "aussähet", "aussaehet", "aussäht", "aussaeht", "aussähen", "aussaehen", "scheine", "scheinst", "scheint", "scheinest", "scheinet", "schien", "schienst", "schienen", "schient", "schiene", "schienest", "schienet", "erscheine", "erscheinst", "erscheint", "erscheinest", "erscheinet", "erschien", "erschienst", "erschienen", "erschient", "erschiene", "erschienest", "erschienet"]; var copulaInfinitive = ["bleiben", "heißen", "heissen", "gelten", "aussehen", "scheinen", "erscheinen"]; var prepositions = ["a", "à", "ab", "abseits", "abzüglich", "abzueglich", "als", "am", "an", "angelegentlich", "angesichts", "anhand", "anlässlich", "anlaesslich", "ans", "anstatt", "anstelle", "auf", "aufs", "aufseiten", "aus", "ausgangs", "ausschließlich", "ausschliesslich", "außerhalb", "ausserhalb", "ausweislich", "bar", "behufs", "bei", "beidseits", "beiderseits", "beim", "betreffs", "bezüglich", "bezueglich", "binnen", "bis", "contra", "dank", "diesseits", "durch", "einbezüglich", "einbezueglich", "eingangs", "eingedenk", "einschließlich", "einschliesslich", "entgegen", "entlang", "exklusive", "fern", "fernab", "fuer", "für", "fuers", "fürs", "gegen", "gegenüber", "gegenueber", "gelegentlich", "gemäß", "gemaeß", "gen", "getreu", "gleich", "halber", "hinsichtlich", "hinter", "hinterm", "hinters", "im", "in", "inklusive", "inmitten", "innerhalb", "innert", "ins", "je", "jenseits", "kontra", "kraft", "längs", "laengs", "längsseits", "laengsseits", "laut", "links", "mangels", "minus", "mit", "mithilfe", "mitsamt", "mittels", "nach", "nächst", "naechst", "nah", "namens", "neben", "nebst", "nördlich", "noerdlich", "nordöstlich", "nordoestlich", "nordwestlich", "oberhalb", "ohne", "östlich", "oestlich", "per", "plus", "pro", "quer", "rechts", "rücksichtlich", "ruecksichtlich", "samt", "seitens", "seitlich", "seitwärts", "seitwaerts", "südlich", "suedlich", "südöstlich", "suedoestlich", "südwestlich", "suedwestlich", "über", "ueber", "überm", "ueberm", "übern", "uebern", "übers", "uebers", "um", "ums", "unbeschadet", "unerachtet", "unfern", "unter", "unterhalb", "unterm", "untern", "unters", "unweit", "vermittels", "vermittelst", "vermöge", "vermoege", "via", "vom", "von", "vonseiten", "vor", "vorbehaltlich", "wegen", "wider", "zeit", "zu", "zugunsten", "zulieb", "zuliebe", "zum", "zur", "zusätzlich", "zusaetzlich", "zuungunsten", "zuwider", "zuzüglich", "zuzueglich", "zwecks", "zwischen"]; var coordinatingConjunctions = ["und", "oder", "umso"]; var correlativeConjunctions = ["auch", "noch", "nur"]; var subordinatingConjunctions = ["nun", "so", "gleichwohl"]; var interviewVerbs = ["sage", "sagst", "sagt", "sagest", "saget", "sagte", "sagtest", "sagten", "sagtet", "gesagt", "fragst", "fragt", "fragest", "fraget", "fragte", "fragtest", "fragten", "fragtet", "gefragt", "erkläre", "erklärst", "erklärt", "erklaere", "erklaerst", "erklaert", "erklärte", "erklärtest", "erklärtet", "erklärten", "erklaerte", "erklaertest", "erklaertet", "erklaerten", "denke", "denkst", "denkt", "denkest", "denket", "dachte", "dachtest", "dachten", "dachtet", "dächte", "dächtest", "dächten", "dächtet", "daechte", "daechtest", "daechten", "daechtet", "finde", "findest", "findet", "gefunden"]; var interviewVerbsInfinitive = ["sagen", "erklären", "erklaeren", "denken", "finden"]; var additionalTransitionWords = ["etwa", "absolut", "unbedingt", "wieder", "definitiv", "bestimmt", "immer", "äußerst", "aeußerst", "höchst", "hoechst", "sofort", "augenblicklich", "umgehend", "direkt", "unmittelbar", "nämlich", "naemlich", "natürlich", "natuerlich", "besonders", "hauptsächlich", "hauptsaechlich", "jetzt", "eben", "heutzutage", "eindeutig", "wirklich", "echt", "wahrhaft", "ehrlich", "aufrichtig", "wahrheitsgemäß", "letztlich", "einmalig", "unübertrefflich", "normalerweise", "gewöhnlich", "gewoehnlich", "üblicherweise", "ueblicherweise", "sonst", "fast", "nahezu", "beinahe", "knapp", "annähernd", "annaehernd", "geradezu", "bald", "vielleicht", "wahrscheinlich", "wohl", "voraussichtlich", "zugegeben", "ursprünglich", "insgesamt", "tatsächlich", "eigentlich", "wahrhaftig", "bereits", "schon", "oft", "häufig", "haeufig", "regelmäßig", "regelmaeßig", "gleichmäßig", "gleichmaeßig", "einfach", "lediglich", "bloß", "bloss", "halt", "wahlweise", "eventuell", "manchmal", "teilweise", "nie", "niemals", "nimmer", "jemals", "allzeit", "irgendeinmal", "anders", "momentan", "gegenwärtig", "gegenwaertig", "nebenbei", "anderswo", "woanders", "anderswohin", "anderorts", "insbesondere", "namentlich", "sonderlich", "ausdrücklich", "ausdruecklich", "vollends", "kürzlich", "kuerzlich", "jüngst", "juengst", "unlängst", "unlaengst", "neuerdings", "neulich", "letztens", "neuerlich", "verhältnismäßig", "verhaeltnismaessig", "deutlich", "klar", "offenbar", "anscheinend", "genau", "u.a", "damals", "zumindest"]; var intensifiers = ["sehr", "recht", "überaus", "ueberaus", "ungemein", "weitaus", "einigermaßen", "einigermassen", "ganz", "schwer", "tierisch", "ungleich", "ziemlich", "übelst", "uebelst", "stark", "volkommen", "durchaus", "gar"]; var delexicalizedVerbs = ["geschienen", "meinst", "meint", "meinest", "meinet", "meinte", "meintest", "meinten", "meintet", "gemeint", "stehe", "stehst", "steht", "gehe", "gehst", "geht", "gegangen", "ging", "gingst", "gingen", "gingt"]; var delexicalizedVerbsInfinitive = ["tun", "machen", "stehen", "wissen", "gehen", "kommen"]; var generalAdjectivesAdverbs = ["einerlei", "egal", "neu", "neue", "neuer", "neuen", "neues", "neuem", "neuerer", "neueren", "neuerem", "neueres", "neuere", "neuester", "neuster", "neuesten", "neusten", "neuestem", "neustem", "neuestes", "neustes", "neueste", "neuste", "alt", "alter", "alten", "altem", "altes", "alte", "ältere", "älteren", "älterer", "älteres", "ältester", "ältesten", "ältestem", "ältestes", "älteste", "aeltere", "aelteren", "aelterer", "aelteres", "aeltester", "aeltesten", "aeltestem", "aeltestes", "aelteste", "gut", "guter", "gutem", "guten", "gutes", "gute", "besser", "besserer", "besseren", "besserem", "besseres", "bester", "besten", "bestem", "bestes", "beste", "größte", "grösste", "groß", "großer", "großen", "großem", "großes", "große", "großerer", "großerem", "großeren", "großeres", "großere", "großter", "großten", "großtem", "großtes", "großte", "gross", "grosser", "grossen", "grossem", "grosses", "grosse", "grosserer", "grosserem", "grosseren", "grosseres", "grossere", "grosster", "grossten", "grosstem", "grosstes", "grosste", "einfacher", "einfachen", "einfachem", "einfaches", "einfache", "einfacherer", "einfacheren", "einfacherem", "einfacheres", "einfachere", "einfachste", "einfachster", "einfachsten", "einfachstes", "einfachstem", "schnell", "schneller", "schnellen", "schnellem", "schnelles", "schnelle", "schnellere", "schnellerer", "schnelleren", "schnelleres", "schnellerem", "schnellster", "schnellste", "schnellsten", "schnellstem", "schnellstes", "weit", "weiten", "weitem", "weites", "weiterer", "weiteren", "weiterem", "weiteres", "weitere", "weitester", "weitesten", "weitestem", "weitestes", "weiteste", "eigen", "eigener", "eigenen", "eigenes", "eigenem", "eigene", "eigenerer", "eignerer", "eigeneren", "eigneren", "eigenerem", "eignerem", "eigeneres", "eigneres", "eigenere", "eignere", "eigenster", "eigensten", "eigenstem", "eigenstes", "eigenste", "wenigster", "wenigsten", "wenigstem", "wenigstes", "wenigste", "minderer", "minderen", "minderem", "mindere", "minderes", "mindester", "mindesten", "mindestes", "mindestem", "mindeste", "lang", "langer", "langen", "langem", "langes", "längerer", "längeren", "längerem", "längeres", "längere", "längster", "längsten", "längstem", "längstes", "längste", "laengerer", "laengeren", "laengerem", "laengeres", "laengere", "laengster", "laengsten", "laengstem", "laengstes", "laengste", "tief", "tiefer", "tiefen", "tiefem", "tiefes", "tiefe", "tieferer", "tieferen", "tieferem", "tieferes", "tiefere", "tiefster", "tiefsten", "tiefstem", "tiefste", "tiefstes", "hoch", "hoher", "hohen", "hohem", "hohes", "hohe", "höherer", "höhere", "höheren", "höherem", "höheres", "hoeherer", "hoehere", "hoeheren", "hoeherem", "hoeheres", "höchster", "höchste", "höchsten", "höchstem", "höchstes", "hoechster", "hoechste", "hoechsten", "hoechstem", "hoechstes", "regulär", "regulärer", "regulären", "regulärem", "reguläres", "reguläre", "regulaer", "regulaerer", "regulaeren", "regulaerem", "regulaeres", "regulaere", "regulärerer", "reguläreren", "regulärerem", "reguläreres", "regulärere", "regulaererer", "regulaereren", "regulaererem", "regulaereres", "regulaerere", "regulärster", "regulärsten", "regulärstem", "regulärstes", "regulärste", "regulaerster", "regulaersten", "regulaerstem", "regulaerstes", "regulaerste", "normal", "normaler", "normalen", "normalem", "normales", "normale", "normalerer", "normaleren", "normalerem", "normaleres", "normalere", "normalster", "normalsten", "normalstem", "normalstes", "normalste", "klein", "kleiner", "kleinen", "kleinem", "kleines", "kleine", "kleinerer", "kleineres", "kleineren", "kleinerem", "kleinere", "kleinster", "kleinsten", "kleinstem", "kleinstes", "kleinste", "winzig", "winziger", "winzigen", "winzigem", "winziges", "winzigerer", "winzigeren", "winzigerem", "winzigeres", "winzigere", "winzigster", "winzigsten", "winzigstem", "winzigste", "winzigstes", "sogenannt", "sogenannter", "sogenannten", "sogenanntem", "sogenanntes", "sogenannte", "kurz", "kurzer", "kurzen", "kurzem", "kurzes", "kurze", "kürzerer", "kürzeres", "kürzeren", "kürzerem", "kürzere", "kuerzerer", "kuerzeres", "kuerzeren", "kuerzerem", "kuerzere", "kürzester", "kürzesten", "kürzestem", "kürzestes", "kürzeste", "kuerzester", "kuerzesten", "kuerzestem", "kuerzestes", "kuerzeste", "wirklicher", "wirklichen", "wirklichem", "wirkliches", "wirkliche", "wirklicherer", "wirklicheren", "wirklicherem", "wirklicheres", "wirklichere", "wirklichster", "wirklichsten", "wirklichstes", "wirklichstem", "wirklichste", "eigentlicher", "eigentlichen", "eigentlichem", "eigentliches", "eigentliche", "schön", "schöner", "schönen", "schönem", "schönes", "schöne", "schönerer", "schöneren", "schönerem", "schöneres", "schönere", "schönster", "schönsten", "schönstem", "schönstes", "schönste", "real", "realer", "realen", "realem", "reales", "realerer", "realeren", "realerem", "realeres", "realere", "realster", "realsten", "realstem", "realstes", "realste", "derselbe", "denselben", "demselben", "desselben", "dasselbe", "dieselbe", "derselben", "dieselben", "gleicher", "gleichen", "gleichem", "gleiches", "gleiche", "gleicherer", "gleicheren", "gleicherem", "gleicheres", "gleichere", "gleichster", "gleichsten", "gleichstem", "gleichstes", "gleichste", "bestimmter", "bestimmten", "bestimmtem", "bestimmtes", "bestimmte", "bestimmtere", "bestimmterer", "bestimmterem", "bestimmteren", "bestimmteres", "bestimmtester", "bestimmtesten", "bestimmtestem", "bestimmtestes", "bestimmteste", "überwiegend", "ueberwiegend", "zumeist", "meistens", "meisten", "großenteils", "grossenteils", "meistenteils", "weithin", "ständig", "staendig", "laufend", "dauernd", "andauernd", "immerfort", "irgendwo", "irgendwann", "ähnlicher", "ähnlichen", "ähnlichem", "ähnliches", "ähnliche", "ähnlich", "ähnlicherer", "ähnlicheren", "ähnlicherem", "ähnlicheres", "ähnlichere", "ähnlichster", "ähnlichsten", "ähnlichstem", "ähnlichstes", "ähnlichste", "schlecht", "schlechter", "schlechten", "schlechtem", "schlechtes", "schlechte", "schlechterer", "schlechteren", "schlechterem", "schlechteres", "schlechtere", "schlechtester", "schlechtesten", "schlechtestem", "schlechtestes", "schlechteste", "schlimm", "schlimmer", "schlimmen", "schlimmem", "schlimmes", "schlimme", "schlimmerer", "schlimmeren", "schlimmerem", "schlimmeres", "schlimmere", "schlimmster", "schlimmsten", "schlimmstem", "schlimmstes", "schlimmste", "toll", "toller", "tollen", "tollem", "tolles", "tolle", "tollerer", "tolleren", "tollerem", "tollere", "tolleres", "tollster", "tollsten", "tollstem", "tollstes", "tollste", "super", "mögliche", "möglicher", "mögliches", "möglichen", "möglichem", "möglich", "moegliche", "moeglicher", "moegliches", "moeglichen", "moeglichem", "moeglich", "nächsten", "naechsten", "voll", "voller", "vollen", "vollem", "volle", "volles", "vollerer", "volleren", "vollerem", "vollere", "volleres", "vollster", "vollsten", "vollstem", "vollste", "vollstes", "außen", "ganzer", "ganzen", "ganzem", "ganze", "ganzes", "gerne", "oben", "unten", "zurück", "zurueck", "nicht"]; var interjections = ["ach", "aha", "oh", "au", "bäh", "baeh", "igitt", "huch", "hurra", "hoppla", "nanu", "oha", "olala", "pfui", "tja", "uups", "wow", "grr", "äh", "aeh", "ähm", "aehm", "öhm", "oehm", "hm", "mei", "mhm", "okay", "richtig", "eijeijeijei"]; var recipeWords = ["g", "el", "tl", "wg", "be", "bd", "cl", "dl", "dag", "do", "gl", "gr", "kg", "kl", "cb", "ccm", "l", "ms", "mg", "ml", "mi", "pk", "pr", "pp", "sc", "sp", "st", "sk", "ta", "tr", "cm", "mass"]; var timeWords = ["sekunde", "sekunden", "minute", "minuten", "stunde", "stunden", "uhr", "tag", "tages", "tags", "tage", "tagen", "woche", "wochen", "monat", "monate", "monates", "monats", "monaten", "jahr", "jahres", "jahrs", "jahre", "jahren", "morgens", "mittags", "abends", "nachts", "heute", "gestern", "morgen", "vorgestern", "übermorgen", "uebermorgen"]; var vagueNouns = ["ding", "dinge", "dinges", "dinger", "dingern", "dingen", "sache", "sachen", "weise", "weisen", "wahrscheinlichkeit", "zeug", "zeuge", "zeuges", "zeugen", "mal", "einmal", "teil", "teile", "teiles", "teilen", "prozent", "prozents", "prozentes", "prozente", "prozenten", "beispiel", "beispiele", "beispieles", "beispiels", "beispielen", "aspekt", "aspekte", "aspektes", "aspekts", "aspekten", "idee", "ideen", "ahnung", "ahnungen", "thema", "themas", "themata", "themen", "fall", "falle", "falles", "fälle", "fällen", "faelle", "faellen", "mensch", "menschen", "leute"]; var miscellaneous = ["nix", "nixe", "nixes", "nixen", "usw.", "amen", "ja", "nein", "euro"]; var titlesPreceding = ["fr", "hr", "dr", "prof"]; var titlesFollowing = ["jr", "jun", "sen", "sr"]; module.exports = function () { return { filteredAtBeginning: [].concat(otherAuxiliariesInfinitive, passiveAuxiliariesInfinitive, delexicalizedVerbsInfinitive, copulaInfinitive, interviewVerbsInfinitive), filteredAtEnding: [].concat(ordinalNumerals, generalAdjectivesAdverbs), filteredAtBeginningAndEnding: [].concat(articles, prepositions, coordinatingConjunctions, demonstrativePronouns, intensifiers, quantifiers), filteredAnywhere: [].concat(transitionWords, adverbialGenitives, personalPronounsNominative, personalPronounsAccusative, personalPronounsDative, reflexivePronouns, interjections, cardinalNumerals, copula, interviewVerbs, otherAuxiliaries, filteredPassiveAuxiliaries, delexicalizedVerbs, indefinitePronouns, correlativeConjunctions, subordinatingConjunctions, interrogativeProAdverbs, locativeAdverbs, miscellaneous, pronominalAdverbs, recipeWords, timeWords, vagueNouns, reciprocalPronouns, possessivePronouns), all: [].concat(articles, cardinalNumerals, ordinalNumerals, demonstrativePronouns, possessivePronouns, reflexivePronouns, reciprocalPronouns, personalPronounsNominative, personalPronounsAccusative, quantifiers, indefinitePronouns, interrogativeProAdverbs, pronominalAdverbs, locativeAdverbs, adverbialGenitives, filteredPassiveAuxiliaries, passiveAuxiliariesInfinitive, otherAuxiliaries, otherAuxiliariesInfinitive, copula, copulaInfinitive, prepositions, coordinatingConjunctions, correlativeConjunctions, subordinatingConjunctions, interviewVerbs, interviewVerbsInfinitive, transitionWords, additionalTransitionWords, intensifiers, delexicalizedVerbs, delexicalizedVerbsInfinitive, interjections, generalAdjectivesAdverbs, recipeWords, vagueNouns, miscellaneous, timeWords, titlesPreceding, titlesFollowing) }; }; }), (function (module, exports, __webpack_require__) { "use strict"; var transitionWords = __webpack_require__(183)().singleWords; var articles = ["de", "het", "een", "der", "des", "den"]; var cardinalNumerals = ["eén", "één", "twee", "drie", "vier", "vijf", "zes", "zeven", "acht", "negen", "tien", "elf", "twaalf", "dertien", "veertien", "vijftien", "zestien", "zeventien", "achttien", "negentien", "twintig", "honderd", "honderden", "duizend", "duizenden", "miljoen", "miljoenen", "biljoen", "biljoenen"]; var ordinalNumerals = ["eerste", "tweede", "derde", "vierde", "vijfde", "zesde", "zevende", "achtste", "negende", "tiende", "elfde", "twaalfde", "dertiende", "veertiende", "vijftiende", "zestiende", "zeventiende", "achttiende", "negentiende", "twinstigste"]; var personalPronounsNominative = ["ik", "je", "jij", "hij", "ze", "we", "wij", "jullie", "zij", "u", "ge", "gij", "men"]; var personalPronounsAccusative = ["mij", "jou", "hem", "haar", "hen", "hun", "uw"]; var demonstrativePronouns = ["dit", "dat", "deze", "die", "zelf"]; var possessivePronouns = ["mijn", "mijne", "jouw", "jouwe", "zijne", "hare", "ons", "onze", "hunne", "uwe", "elkaars", "elkanders"]; var quantifiers = ["alle", "sommige", "sommigen", "weinig", "weinige", "weinigen", "veel", "vele", "velen", "geen", "beetje", "elke", "elk", "genoeg", "meer", "meest", "meeste", "meesten", "paar", "zoveel", "enkele", "enkelen", "zoveelste", "hoeveelste", "laatste", "laatsten", "iedere", "allemaal", "zekere", "ander", "andere", "gene", "enig", "enige", "verscheidene", "verschillende", "voldoende", "allerlei", "allerhande", "enerlei", "enerhande", "beiderlei", "beiderhande", "tweeërlei", "tweeërhande", "drieërlei", "drieërhande", "velerlei", "velerhande", "menigerlei", "menigerhande", "enigerlei", "enigerhande", "generlei", "generhande"]; var reflexivePronouns = ["mezelf", "mijzelf", "jezelf", "jouzelf", "zichzelf", "haarzelf", "hemzelf", "onszelf", "julliezelf", "henzelf", "hunzelf", "uzelf", "zich"]; var reciprocalPronouns = ["mekaar", "elkaar", "elkander", "mekander"]; var indefinitePronouns = ["iedereen", "ieder", "eenieder", "alleman", "allen", "alles", "iemand", "niemand", "iets", "niets", "menigeen"]; var indefinitePronounsPossessive = ["ieders", "aller", "iedereens", "eenieders"]; var relativePronouns = ["welke", "welk", "wat", "wie", "wiens", "wier"]; var interrogativeProAdverbs = ["hoe", "waarom", "waar", "hoezo", "hoeveel"]; var pronominalAdverbs = ["daaraan", "daarachter", "daaraf", "daarbij", "daarbinnen", "daarboven", "daarbuiten", "daardoorheen", "daarheen", "daarin", "daarjegens", "daarmede", "daarnaar", "daarnaartoe", "daaromtrent", "daaronder", "daarop", "daarover", "daaroverheen", "daarrond", "daartegen", "daartussen", "daartussenuit", "daaruit", "daarvan", "daarvandaan", "eraan", "erachter", "erachteraan", "eraf", "erbij", "erbinnen", "erboven", "erbuiten", "erdoor", "erdoorheen", "erheen", "erin", "erjegens", "ermede", "ermee", "erna", "ernaar", "ernaartoe", "ernaast", "erom", "eromtrent", "eronder", "eronderdoor", "erop", "eropaf", "eropuit", "erover", "eroverheen", "errond", "ertegen", "ertegenaan", "ertoe", "ertussen", "ertussenuit", "eruit", "ervan", "ervandaan", "ervandoor", "ervoor", "hieraan", "hierachter", "hieraf", "hierbij", "hierbinnen", "hierboven", "hierbuiten", "hierdoor", "hierdoorheen", "hierheen", "hierin", "hierjegens", "hierlangs", "hiermede", "hiermee", "hierna", "hiernaar", "hiernaartoe", "hiernaast", "hieromheen", "hieromtrent", "hieronder", "hierop", "hierover", "hieroverheen", "hierrond", "hiertegen", "hiertoe", "hiertussen", "hiertussenuit", "hieruit", "hiervan", "hiervandaan", "hiervoor", "vandaan", "waaraan", "waarachter", "waaraf", "waarbij", "waarboven", "waarbuiten", "waardoorheen", "waarheen", "waarin", "waarjegens", "waarmede", "waarna", "waarnaar", "waarnaartoe", "waarnaast", "waarop", "waarover", "waaroverheen", "waarrond", "waartegen", "waartegenin", "waartoe", "waartussen", "waartussenuit", "waaruit", "waarvan", "waarvandaan", "waarvoor"]; var locativeAdverbs = ["daar", "hier", "ginder", "daarginds", "ginds", "ver", "veraf", "ergens", "nergens", "overal", "dichtbij", "kortbij"]; var filteredPassiveAuxiliaries = ["word", "wordt", "werd", "werden", "ben", "bent", "is", "was", "waren"]; var passiveAuxiliariesInfinitive = ["worden", "zijn"]; var otherAuxiliaries = ["heb", "hebt", "heeft", "hadden", "had", "kun", "kan", "kunt", "kon", "konden", "mag", "mocht", "mochten", "dien", "dient", "diende", "dienden", "moet", "moest", "moesten", "ga", "gaat", "ging", "gingen"]; var otherAuxiliariesInfinitive = ["hebben", "kunnen", "mogen", "dienen", "moeten", "gaan"]; var copula = ["blijkt", "blijk", "bleek", "bleken", "gebleken", "dunkt", "dunk", "dunkte", "dunkten", "gedunkt", "heet", "heette", "heetten", "geheten", "lijkt", "lijk", "geleken", "leek", "leken", "schijn", "schijnt", "scheen", "schenen", "toescheen", "toeschijnt", "toeschijn", "toeschenen"]; var copulaInfinitive = ["blijken", "dunken", "heten", "lijken", "schijnen", "toeschijnen"]; var prepositions = ["à", "aan", "aangaande", "achter", "behalve", "behoudens", "beneden", "benevens", "benoorden", "benoordoosten", "benoordwesten", "beoosten", "betreffende", "bewesten", "bezijden", "bezuiden", "bezuidoosten", "bezuidwesten", "bij", "binnen", "blijkens", "boven", "bovenaan", "buiten", "circa", "conform", "contra", "cum", "dankzij", "door", "gedurende", "gezien", "in", "ingevolge", "inzake", "jegens", "krachtens", "langs", "luidens", "met", "middels", "na", "naar", "naast", "nabij", "namens", "nevens", "niettegenstaande", "nopens", "om", "omstreeks", "omtrent", "onder", "onderaan", "ongeacht", "onverminderd", "op", "over", "overeenkomstig", "per", "plus", "post", "richting", "rond", "rondom", "spijts", "staande", "te", "tegen", "tegenover", "ten", "ter", "tijdens", "tot", "tussen", "uit", "van", "vanaf", "vanuit", "versus", "via", "vis-à-vis", "volgens", "voor", "voorbij", "wegens", "zijdens", "zonder"]; var prepositionalAdverbs = ["af", "heen", "mee", "toe", "achterop", "onderin", "voorin", "bovenop", "buitenop", "achteraan", "onderop", "binnenin", "tevoren"]; var coordinatingConjunctions = ["en", "alsmede", "of", "ofwel", "en/of"]; var correlativeConjunctions = ["zowel", "evenmin", "zomin", "hetzij"]; var subordinatingConjunctions = ["vermits", "dewijl", "dorodien", "naardien", "nademaal", "overmits", "wijl", "eer", "eerdat", "aleer", "vooraleer", "alvorens", "totdat", "zolang", "sinds", "sedert", "ingeval", "tenware", "alhoewel", "hoezeer", "uitgezonderd", "zoverre", "zover", "naargelang", "naarmate", "alsof"]; var interviewVerbs = ["zegt", "zei", "vraagt", "vroeg", "denkt", "dacht", "stelt", "pleit", "pleitte"]; var additionalTransitionWords = ["absoluut", "zeker", "ongetwijfeld", "sowieso", "onmiddelijk", "meteen", "inclusief", "direct", "ogenblikkelijk", "terstond", "natuurlijk", "vanzelfsprekend", "gewoonlijk", "normaliter", "doorgaans", "werkelijk", "daadwerkelijk", "inderdaad", "waarachtig", "oprecht", "bijna", "meestal", "misschien", "waarschijnlijk", "wellicht", "mogelijk", "vermoedelijk", "allicht", "aannemelijk", "oorspronkelijk", "aanvankelijk", "initieel", "eigenlijk", "feitelijk", "wezenlijk", "juist", "reeds", "alvast", "bijv.", "vaak", "dikwijls", "veelal", "geregeld", "menigmaal", "regelmatig", "veelvuldig", "eenvoudigweg", "simpelweg", "louter", "kortweg", "stomweg", "domweg", "zomaar", "eventueel", "mogelijkerwijs", "eens", "weleens", "nooit", "ooit", "anders", "momenteel", "thans", "incidenteel", "trouwens", "elders", "volgend", "recent", "onlangs", "recentelijk", "laatst", "zojuist", "relatief", "duidelijk", "overduidelijk", "klaarblijkelijk", "nadrukkelijk", "ogenschijnlijk", "kennelijk", "schijnbaar", "alweer", "continu", "herhaaldelijk", "nog", "steeds", "nu"]; var intensifiers = ["zeer", "erg", "redelijk", "flink", "tikkeltje", "bijzonder", "ernstig", "enigszins", "zo", "tamelijk", "nogal", "behoorlijk", "zwaar", "heel", "hele", "reuze", "buitengewoon", "ontzettend", "vreselijk"]; var delexicalizedVerbs = ["laat", "liet", "lieten", "kom", "komt", "kwam", "kwamen", "maakt", "maak", "maakte", "maakten", "doe", "doet", "deed", "deden", "vindt", "vind", "vond", "vonden"]; var delexicalizedVerbsInfinitive = ["laten", "komen", "maken", "doen", "vinden"]; var generalAdjectivesAdverbs = ["nieuw", "nieuwe", "nieuwer", "nieuwere", "nieuwst", "nieuwste", "oud", "oude", "ouder", "oudere", "oudst", "oudste", "vorig", "vorige", "goed", "goede", "beter", "betere", "best", "beste", "groot", "grote", "groter", "grotere", "grootst", "grootste", "makkelijk", "makkelijke", "makkelijker", "makkelijkere", "makkelijkst", "makkelijste", "gemakkelijk", "gemakkelijke", "gemakkelijker", "gemakkelijkere", "gemakkelijkst", "gemakkelijste", "simpel", "simpele", "simpeler", "simpelere", "simpelst", "simpelste", "snel", "snelle", "sneller", "snellere", "snelst", "snelste", "verre", "verder", "verdere", "verst", "verste", "lang", "lange", "langer", "langere", "langst", "langste", "hard", "harde", "harder", "hardere", "hardst", "hardste", "minder", "mindere", "minst", "minste", "eigen", "laag", "lage", "lager", "lagere", "laagst", "laagste", "hoog", "hoge", "hoger", "hogere", "hoogst", "hoogste", "klein", "kleine", "kleiner", "kleinere", "kleinst", "kleinste", "kort", "korte", "korter", "kortere", "kortst", "kortste", "herhaaldelijke", "directe", "ongeveer", "slecht", "slechte", "slechter", "slechtere", "slechtst", "slechtste", "zulke", "zulk", "zo'n", "zulks", "er", "extreem", "extreme", "bijbehorende", "bijbehorend", "niet"]; var interjections = ["oh", "wauw", "hèhè", "hè", "hé", "au", "ai", "jaja", "welja", "jawel", "ssst", "heremijntijd", "hemeltjelief", "aha", "foei", "hmm", "nou", "nee", "tja", "nja", "okido", "ho", "halt", "komaan", "komop", "verrek", "nietwaar", "brr", "oef", "ach", "och", "bah", "enfin", "afijn", "haha", "hihi", "hatsjie", "hatsjoe", "hm", "tring", "vroem", "boem", "hopla"]; var recipeWords = ["ml", "cl", "dl", "l", "tl", "el", "mg", "g", "gr", "kg", "ca", "theel", "min", "sec", "uur"]; var timeWords = ["seconde", "secondes", "seconden", "minuut", "minuten", "uur", "uren", "dag", "dagen", "week", "weken", "maand", "maanden", "jaar", "jaren", "vandaag", "morgen", "overmorgen", "gisteren", "eergisteren", "'s", "morgens", "avonds", "middags", "nachts"]; var vagueNouns = ["ding", "dingen", "manier", "manieren", "item", "items", "keer", "maal", "procent", "geval", "aspect", "persoon", "personen", "deel"]; var miscellaneous = ["wel", "ja", "neen", "oké", "oke", "okee", "ok", "zoiets", "€", "euro"]; var titlesPreceding = ["mevr", "dhr", "mr", "dr", "prof"]; var titlesFollowing = ["jr", "sr"]; module.exports = function () { return { filteredAtBeginning: [].concat(passiveAuxiliariesInfinitive, otherAuxiliariesInfinitive, copulaInfinitive, delexicalizedVerbsInfinitive), filteredAtEnding: [].concat(ordinalNumerals, generalAdjectivesAdverbs), filteredAtBeginningAndEnding: [].concat(articles, prepositions, coordinatingConjunctions, demonstrativePronouns, intensifiers, quantifiers), filteredAnywhere: [].concat(transitionWords, personalPronounsNominative, personalPronounsAccusative, reflexivePronouns, interjections, cardinalNumerals, filteredPassiveAuxiliaries, otherAuxiliaries, copula, interviewVerbs, delexicalizedVerbs, indefinitePronouns, correlativeConjunctions, subordinatingConjunctions, interrogativeProAdverbs, relativePronouns, locativeAdverbs, miscellaneous, prepositionalAdverbs, pronominalAdverbs, recipeWords, timeWords, vagueNouns, reciprocalPronouns, possessivePronouns), all: [].concat(articles, cardinalNumerals, ordinalNumerals, demonstrativePronouns, possessivePronouns, reflexivePronouns, reciprocalPronouns, personalPronounsNominative, personalPronounsAccusative, quantifiers, indefinitePronouns, indefinitePronounsPossessive, relativePronouns, interrogativeProAdverbs, pronominalAdverbs, locativeAdverbs, prepositionalAdverbs, filteredPassiveAuxiliaries, passiveAuxiliariesInfinitive, otherAuxiliaries, otherAuxiliariesInfinitive, copula, copulaInfinitive, prepositions, coordinatingConjunctions, correlativeConjunctions, subordinatingConjunctions, interviewVerbs, transitionWords, additionalTransitionWords, intensifiers, delexicalizedVerbs, delexicalizedVerbsInfinitive, interjections, generalAdjectivesAdverbs, recipeWords, vagueNouns, miscellaneous, titlesPreceding, titlesFollowing) }; }; }), (function (module, exports, __webpack_require__) { "use strict"; var transitionWords = __webpack_require__(182)().singleWords; var articles = ["el", "la", "los", "las", "un", "una", "unos", "unas"]; var cardinalNumerals = ["dos", "tres", "cuatro", "cinco", "seis", "siete", "ocho", "nueve", "diez", "once", "doce", "trece", "catorce", "quince", "dieciseis", "diecisiete", "dieciocho", "diecinueve", "veinte", "cien", "centena", "mil", "millon", "millones"]; var ordinalNumerals = ["primera", "segunda", "tercera", "cuarto", "cuarta", "quinto", "quinta", "sexto", "sexta", "septimo", "septima", "octavo", "octava", "noveno", "novena", "décimo", "décima", "vigésimo", "vigésima", "primeros", "primeras", "segundos", "segundas", "terceros", "terceras", "cuartos", "cuartas", "quintos", "quintas", "sextos", "sextas", "septimos", "septimas", "octavos", "octavas", "novenos", "novenas", "décimos", "décimas", "vigésimos", "vigésimas"]; var personalPronounsNominative = ["yo", "tú", "él", "ella", "ello", "nosotros", "nosotras", "vosotros", "vosotras", "ustedes", "ellos", "ellas"]; var personalPronounsAccusative = ["me", "te", "lo", "se", "nos", "os", "les"]; var personalPronounsPrepositional = ["mí", "ti", "ud", "uds", "usted", "sí"]; var personalPronounsComitative = ["conmigo", "contigo", "consigo"]; var demonstrativePronouns = ["este", "ese", "aquel", "esta", "esa", "aquella", "estos", "esos", "aquellos", "estas", "esas", "aquellas", "esto", "eso", "aquello"]; var possessivePronouns = ["mi", "mis", "mío", "míos", "mía", "mías", "nuestro", "nuestros", "nuestra", "nuestras", "tuyo", "tuyos", "tuya", "tuyas", "tu", "tus", "vuestro", "vuestros", "vuestra", "vuestras", "suyo", "suyos", "suya", "suyas", "su", "sus"]; var quantifiers = ["bastante", "bastantes", "mucho", "muchas", "mucha", "muchos", "demasiado", "demasiada", "demasiados", "demasiadas", "poco", "poca", "pocos", "pocas", "demás", "otros", "otras", "todo", "toda", "todos", "todas"]; var indefinitePronouns = ["alguien", "algo", "algún", "alguno", "alguna", "algunos", "algunas", "nadie", "nada", "ningún", "ninguno", "ninguna", "ningunos", "ningunas", "tanto", "tantos", "tanta", "tantas"]; var interrogativeDeterminers = ["cuyas", "cual"]; var interrogativePronouns = ["cuyo"]; var interrogativeProAdverbs = ["comoquiera", "cualesquiera", "cualquier", "cuanta", "cuantas", "cuanto", "cuantos", "cuál", "cuáles", "cuánta", "cuántas", "cuánto", "cuántos", "cómo", "dondequiera", "dónde", "quien", "quienes", "quienquiera", "quién", "quiénes", "qué"]; var locativeAdverbs = ["allí", "ahí", "allá", "aquí", "acá", "adónde", "delante", "detrás", "debajo", "adelante", "atrás", "adentro", "afuera"]; var otherAuxiliaries = ["he", "has", "ha", "hay", "hemos", "habéis", "han", "hube", "hubiste", "hubo", "hubimos", "hubisteis", "hubieron", "había", "habías", "habíamos", "habíais", "habían", "habría", "habrías", "habríais", "habrían", "habré", "habrás", "habrá", "habremos", "habréis", "habrán", "haya", "hayas", "hayamos", "hayáis", "hayan", "hubiera", "hubieras", "hubiéramos", "hubierais", "hubieran", "hubiese", "hubieses", "hubiésemos", "hubieseis", "hubiesen", "hubiere", "hubieres", "hubiéremos", "hubiereis", "hubieren", "habed", "habido", "debo", "debes", "debe", "debemos", "debéis", "deben", "debí", "debiste", "debió", "debimos", "debisteis", "debieron", "debía", "debías", "debíamos", "debíais", "debían", "debería", "deberías", "deberíamos", "deberíais", "deberían", "deberé", "deberás", "deberá", "deberemos", "deberéis", "deberán", "deba", "debas", "debamos", "debáis", "deban", "debiera", "debieras", "debiéramos", "debierais", "debieran", "debiese", "debieses", "debiésemos", "debieseis", "debiesen", "debiere", "debieres", "debiéremos", "debiereis", "debieren", "debed", "debido", "empiezo", "empiezas", "empieza", "empezáis", "empiezan", "empecé", "empezaste", "empezó", "empezamos", "empezasteis", "empezaron", "empezaba", "empezabas", "empezábamos", "empezabais", "empezaban", "empezaría", "empezarías", "empezaríamos", "empezaríais", "empezarían", "empezaré", "empezarás", "empezará", "empezaremos", "empezaréis", "empezarán", "empiece", "empieces", "empecemos", "empecéis", "empiecen", "empezara", "empezaras", "empezáramos", "empezarais", "empezaran", "empezase", "empezases", "empezásemos", "empezaseis", "empezasen", "empezare", "empezares", "empezáremos", "empezareis", "empezaren", "empezad", "empezado", "comienzo", "comienzas", "comienza", "comenzamos", "comenzáis", "comienzan", "comencé", "comenzaste", "comenzó", "comenzasteis", "comenzaron", "comenzaba", "comenzabas", "comenzábamos", "comenzabais", "comenzaban", "comenzaría", "comenzarías", "comenzaríamos", "comenzaríais", "comenzarían", "comenzaré", "comenzarás", "comenzará", "comenzaremos", "comenzaréis", "comenzarán", "comience", "comiences", "comencemos", "comencéis", "comiencen", "comenzara", "comenzaras", "comenzáramos", "comenzarais", "comenzaran", "comenzase", "comenzases", "comenzásemos", "comenzaseis", "comenzasen", "comenzare", "comenzares", "comenzáremos", "comenzareis", "comenzaren", "comenzad", "comenzado", "sigo", "sigues", "sigue", "seguimos", "seguis", "siguen", "seguí", "seguiste", "siguió", "seguisteis", "siguieron", "seguía", "seguías", "seguíamos", "seguíais", "seguían", "seguiría", "seguirías", "seguiríamos", "seguiríais", "seguirían", "seguiré", "seguirás", "seguirá", "seguiremos", "seguiréis", "seguirán", "siga", "sigas", "sigamos", "sigáis", "sigan", "siguiera", "siguieras", "siguiéramos", "siguierais", "siguieran", "siguiese", "siguieses", "siguiésemos", "siguieseis", "siguiesen", "siguiere", "siguieres", "siguiéremos", "siguiereis", "siguieren", "seguid", "seguido", "tengo", "tienes", "tiene", "tenemos", "tenéis", "tienen", "tuve", "tuviste", "tuvo", "tuvimos", "tuvisteis", "tuvieron", "tenía", "tenías", "teníamos", "teníais", "tenían", "tendría", "tendrías", "tendríamos", "tendríais", "tendrían", "tendré", "tendrás", "tendrá", "tendremos", "tendréis", "tendrán", "tenga", "tengas", "tengamos", "tengáis", "tengan", "tuviera", "tuvieras", "tuviéramos", "tuvierais", "tuvieran", "tuviese", "tuvieses", "tuviésemos", "tuvieseis", "tuviesen", "tuviere", "tuvieres", "tuviéremos", "tuviereis", "tuvieren", "ten", "tened", "tenido", "ando", "andas", "andamos", "andáis", "andan", "anduve", "anduviste", "anduvo", "anduvimos", "anduvisteis", "anduvieron", "andaba", "andabas", "andábamos", "andabais", "andaban", "andaría", "andarías", "andaríamos", "andaríais", "andarían", "andaré", "andarás", "andará", "andaremos", "andaréis", "andarán", "ande", "andes", "andemos", "andéis", "anden", "anduviera", "anduvieras", "anduviéramos", "anduvierais", "anduvieran", "anduviese", "anduvieses", "anduviésemos", "anduvieseis", "anduviesen", "anduviere", "anduvieres", "anduviéremos", "anduviereis", "anduvieren", "andad", "andado", "quedo", "quedas", "queda", "quedamos", "quedáis", "quedan", "quedé", "quedasteis", "quedaron", "quedaba", "quedabas", "quedábamos", "quedabais", "quedaban", "quedaría", "quedarías", "quedaríamos", "quedaríais", "quedarían", "quedaré", "quedarás", "quedará", "quedaremos", "quedaréis", "quedarán", "quede", "quedes", "quedemos", "quedéis", "queden", "quedara", "quedaras", "quedáramos", "quedarais", "quedaran", "quedase", "quedases", "quedásemos", "quedaseis", "quedasen", "quedare", "quedares", "quedáremos", "quedareis", "quedaren", "quedad", "quedado", "hallo", "hallas", "halla", "hallamos", "halláis", "hallan", "hallé", "hallaste", "halló", "hallasteis", "hallaron", "hallaba", "hallabas", "hallábamos", "hallabais", "hallaban", "hallaría", "hallarías", "hallaríamos", "hallaríais", "hallarían", "hallaré", "hallarás", "hallará", "hallaremos", "hallaréis", "hallarán", "halle", "halles", "hallemos", "halléis", "hallen", "hallara", "hallaras", "halláramos", "hallarais", "hallaran", "hallase", "hallases", "hallásemos", "hallaseis", "hallasen", "hallare", "hallares", "halláremos", "hallareis", "hallaren", "hallad", "hallado", "vengo", "vienes", "viene", "venimos", "venis", "vienen", "vine", "viniste", "vino", "vinimos", "vinisteis", "vinieron", "venía", "vanías", "verníamos", "veníais", "venían", "vendría", "vendrías", "vendríamos", "vendíais", "vendrían", "vendré", "vendrás", "vendrá", "vendremos", "vendréis", "vendrán", "venga", "vengas", "vengamos", "vengáis", "vengan", "viniera", "vinieras", "viniéramos", "vinierais", "vinieran", "viniese", "vinieses", "viniésemos", "vinieseis", "viniesen", "viniere", "vinieres", "viniéremos", "viniereis", "vinieren", "ven", "venid", "venido", "abro", "abres", "abre", "abrismos", "abrís", "abren", "abrí", "abriste", "abrió", "abristeis", "abrieron", "abría", "abrías", "abríais", "abrían", "abriría", "abrirías", "abriríamos", "abriríais", "abrirían", "abriré", "abrirás", "abrirá", "abriremos", "abriréis", "abrirán", "abra", "abras", "abramos", "abráis", "abran", "abriera", "abrieras", "abriéramos", "abrierais", "abrieran", "abriese", "abrieses", "abriésemos", "abrieseis", "abriesen", "abriere", "abrieres", "abriéremos", "abriereis", "abrieren", "abrid", "abierto", "voy", "vas", "va", "vamos", "vais", "van", "iba", "ibas", "íbamos", "ibais", "iban", "iría", "irías", "iríamos", "iríais", "irían", "iré", "irás", "irá", "iremos", "iréis", "irán", "vaya", "vayas", "vayamos", "vayáis", "vayan", "ve", "id", "ido", "acabo", "acabas", "acaba", "acabamos", "acabáis", "acaban", "acabé", "acabaste", "acabó", "acabasteis", "acabaron", "acababa", "acababas", "acabábamos", "acababais", "acababan", "acabaría", "acabarías", "acabaríamos", "acabaríais", "acabarían", "acabaré", "acabarás", "acabará", "acabaremos", "acabaréis", "acabarán", "acabe", "acabes", "acabemos", "acabéis", "acaben", "acabara", "acabaras", "acabáramos", "acabarais", "acabaran", "acabase", "acabases", "acabásemos", "acabaseis", "acabasen", "acabare", "acabares", "acabáremos", "acabareis", "acabaren", "acabad", "acabado", "llevo", "llevas", "lleva", "llevamos", "lleváis", "llevan", "llevé", "llevaste", "llevó", "llevasteis", "llevaron", "llevaba", "llevabas", "llevábamos", "llevabais", "llevaban", "llevaría", "llevarías", "llevaríamos", "llevaríais", "llevarían", "llevaré", "llevarás", "llevará", "llevaremos", "llevaréis", "llevarán", "lleve", "lleves", "llevemos", "llevéis", "lleven", "llevara", "llevaras", "lleváramos", "llevarais", "llevaran", "llevase", "llevases", "llevásemos", "llevaseis", "llevasen", "llevare", "llevares", "lleváremos", "llevareis", "llevaren", "llevad", "llevado", "alcanzo", "alcanzas", "alcanza", "alcanzamos", "alcanzáis", "alcanzan", "alcancé", "alcanzaste", "alcanzó", "alcanzasteis", "alcanzaron", "alcanzaba", "alcanzabas", "alcanzábamos", "alcanzabais", "alcanzaban", "alcanzaría", "alcanzarías", "alcanzaríamos", "alcanzaríais", "alcanzarían", "alcanzaré", "alcanzarás", "alcanzará", "alcanzaremos", "alcanzaréis", "alcanzarán", "alcance", "alcances", "alcancemos", "alcancéis", "alcancen", "alcanzara", "alcanzaras", "alcanzáramos", "alcanzarais", "alcanzaran", "alcanzase", "alcanzases", "alcanzásemos", "alcanzaseis", "alcanzasen", "alcanzare", "alcanzares", "alcanzáremos", "alcanzareis", "alcanzaren", "alcanzad", "alcanzado", "digo", "dices", "dice", "decimos", "decís", "dicen", "dije", "dijiste", "dijo", "dijimos", "dijisteis", "dijeron", "decía", "decías", "decíamos", "decíais", "decían", "diría", "dirías", "diríamos", "diríais", "dirían", "diré", "dirás", "dirá", "diremos", "diréis", "dirán", "diga", "digas", "digamos", "digáis", "digan", "dijera", "dijeras", "dijéramos", "dijerais", "dijeran", "dijese", "dijeses", "dijésemos", "dijeseis", "dijesen", "dijere", "dijeres", "dijéremos", "dijereis", "dijeren", "di", "decid", "dicho", "continúo", "continúas", "continúa", "continuamos", "continuáis", "continúan", "continué", "continuaste", "continuó", "continuasteis", "continuaron", "continuaba", "continuabas", "continuábamos", "continuabais", "continuaban", "continuaría", "continuarías", "continuaríamos", "continuaríais", "continuarían", "continuaré", "continuarás", "continuará", "continuaremos", "continuaréis", "continuarán", "continúe", "continúes", "continuemos", "continuéis", "continúen", "continuara", "continuaras", "continuáramos", "continuarais", "continuaran", "continuase", "continuases", "continuásemos", "continuaseis", "continuasen", "continuare", "continuares", "continuáremos", "continuareis", "continuaren", "continuad", "continuado", "resulto", "resultas", "resulta", "resultamos", "resultáis", "resultan", "resulté", "resultaste", "resultó", "resultasteis", "resultaron", "resultaba", "resultabas", "resultábamos", "resultabais", "resultaban", "resultaría", "resultarías", "resultaríamos", "resultaríais", "resultarían", "resultaré", "resultarás", "resultará", "resultaremos", "resultaréis", "resultarán", "resulte", "resultes", "resultemos", "resultéis", "resulten", "resultara", "resultaras", "resultáramos", "resultarais", "resultaran", "resultase", "resultases", "resultásemos", "resultaseis", "resultasen", "resultare", "resultares", "resultáremos", "resultareis", "resultaren", "resultad", "resultado", "puedo", "puedes", "puede", "podemos", "podéis", "pueden", "pude", "pudiste", "pudo", "pudimos", "pudisteis", "pudieron", "podía", "podías", "podíamos", "podíais", "podían", "podría", "podrías", "podríamos", "podríais", "podrían", "podré", "podrás", "podrá", "podremos", "podréis", "podrán", "pueda", "puedas", "podamos", "podáis", "puedan", "pudiera", "pudieras", "pudiéramos", "pudierais", "pudieran", "pudiese", "pudieses", "pudiésemos", "pudieseis", "pudiesen", "pudiere", "pudieres", "pudiéremos", "pudiereis", "pudieren", "poded", "podido", "quiero", "quieres", "quiere", "queremos", "queréis", "quieren", "quise", "quisiste", "quiso", "quisimos", "quisisteis", "quisieron", "quería", "querías", "queríamos", "queríais", "querían", "querría", "querrías", "querríamos", "querríais", "querrían", "querré", "querrás", "querrá", "querremos", "querréis", "querrán", "quiera", "quieras", "queramos", "queráis", "quieran", "quisiera", "quisieras", "quisiéramos", "quisierais", "quisieran", "quisiese", "quisieses", "quisiésemos", "quisieseis", "quisiesen", "quisiere", "quisieres", "quisiéremos", "quisiereis", "quisieren", "quered", "querido", "sabes", "sabe", "sabemos", "sabéis", "saben", "supe", "supiste", "supo", "supimos", "supisteis", "supieron", "sabía", "sabías", "sabíamos", "sabíais", "sabían", "sabría", "sabrías", "sabríamos", "sabríais", "sabrían", "sabré", "sabrás", "sabrá", "sabremos", "sabréis", "sabrán", "sepa", "sepas", "sepamos", "sepáis", "sepan", "supiera", "supieras", "supiéramos", "supierais", "supieran", "supiese", "supieses", "supiésemos", "supieseis", "supiesen", "supiere", "supieres", "supiéremos", "supiereis", "supieren", "sabed", "sabido", "suelo", "sueles", "suele", "solemos", "soléis", "suelen", "solí", "soliste", "solió", "solimos", "solisteis", "solieron", "solía", "solías", "solíamos", "solíais", "solían", "solería", "solerías", "soleríamos", "soleríais", "solerían", "soleré", "solerás", "solerá", "soleremos", "soleréis", "solerán", "suela", "suelas", "solamos", "soláis", "suelan", "soliera", "solieras", "soliéramos", "solierais", "solieran", "soliese", "solieses", "soliésemos", "solieseis", "soliesen", "soliere", "solieres", "soliéremos", "soliereis", "solieren", "soled", "solido", "necesito", "necesitas", "necesitamos", "necesitáis", "necesitan", "necesité", "necesitaste", "necesitó", "necesitasteis", "necesitaron", "necesitaba", "necesitabas", "necesitábamos", "necesitabais", "necesitaban", "necesitaría", "necesitarías", "necesitaríamos", "necesitaríais", "necesitarían", "necesitaré", "necesitarás", "necesitará", "necesitaremos", "necesitaréis", "necesitarán", "necesite", "necesites", "necesitemos", "necesitéis", "necesiten", "necesitara", "necesitaras", "necesitáramos", "necesitarais", "necesitaran", "necesitase", "necesitases", "necesitásemos", "necesitaseis", "necesitasen", "necesitare", "necesitares", "necesitáremos", "necesitareis", "necesitaren", "necesita", "necesitad", "necesitado"]; var otherAuxiliariesInfinitive = ["haber", "deber", "empezar", "comenzar", "seguir", "tener", "andar", "quedar", "hallar", "venir", "abrir", "ir", "acabar", "llevar", "alcanzar", "decir", "continuar", "resultar", "poder", "querer", "saber", "soler", "necesitar"]; var copula = ["estoy", "estás", "está", "estamos", "estáis", "están", "estuve", "estuviste", "estuvo", "estuvimos", "estuvisteis", "estuvieron", "estuba", "estabas", "estábamos", "estabais", "estaban", "estraría", "estarías", "estaríamos", "estaríais", "estarían", "estaré", "estarás", "estará", "estaremos", "estaréis", "estarán", "esté", "estés", "estemos", "estéis", "estén", "estuviera", "estuviese", "estuvieras", "estuviéramos", "estuvierais", "estuvieran", "estuvieses", "estuviésemos", "estuvieseis", "estuviesen", "estuviere", "estuvieres", "estuviéremos", "estuviereis", "estuvieren", "estad", "estado", "soy", "eres", "es", "somos", "sois", "son", "fui", "fuiste", "fuimos", "fuisteis", "fueron", "era", "eras", "éramos", "erais", "eran", "sería", "serías", "seríamos", "seríais", "serían", "seré", "serás", "seremos", "seréis", "serán", "sea", "seas", "seamos", "seáis", "sean", "fueras", "fuéramos", "fuerais", "fueran", "fuese", "fueses", "fuésemos", "fueseis", "fuesen", "fuere", "fueres", "fuéremos", "fuereis", "fueren", "sé", "sed", "sido"]; var copulaInfinitive = ["estar", "ser"]; var prepositions = ["a", "ante", "abajo", "adonde", "al", "allende", "alrededor", "amén", "antes", "arriba", "aun", "bajo", "cabe", "cabo", "con", "contigo", "contra", "de", "dejante", "del", "dentro", "desde", "donde", "durante", "en", "encima", "entre", "excepto", "fuera", "hacia", "hasta", "incluso", "mediante", "más", "opuesto", "par", "para", "próximo", "salvo", "según", "sin", "so", "sobre", "tras", "versus", "vía"]; var prepositionalAdverbs = ["cerca"]; var coordinatingConjunctions = ["o", "y", "entonces", "e", "u", "ni", "bien", "ora"]; var correlativeConjunctions = ["igual"]; var subordinatingConjunctions = ["apenas", "segun", "que"]; var interviewVerbs = ["apunto", "apunta", "confieso", "confiesa", "confesaba", "revelado", "revelo", "revela", "revelaba", "declarado", "declaro", "declara", "declaba", "señalo", "señala", "señalaba", "declaraba", "comento", "comenta"]; var additionalTransitionWords = ["básicamente", "esencialmente", "primeramente", "siempre", "nunca", "ahora", "quizá", "acaso", "inclusive", "probablemente", "verdaderamente", "seguramente", "jamás", "obviamente", "indiscutiblement", "inmediatamente", "previamente"]; var intensifiers = ["muy", "tan", "completamente", "suficiente", "tal", "tales"]; var delexicalizedVerbs = ["hago", "haces", "hace", "hacemos", "hacéis", "hacen", "hice", "hiciste", "hizo", "hicimos", "hicisteis", "hicieron", "hacía", "hacías", "hacíamos", "hacíais", "hacían", "haría,", "harías", "haríamos", "haríais", "harían", "haré", "harás", "hará", "haremos", "haréis", "harán", "haga", "hagas", "hagamos", "hagáis", "hagan", "hiciera", "hicieras", "hiciéramos", "hicierais", "hicieran", "hiciese", "hicieses", "hiciésemos", "hicieseis", "hiciesen", "hiciere", "hicieres", "hiciéremos", "hiciereis", "hicieren", "haz", "haced", "hecho", "parezco", "pareces", "parece", "parecemos", "parecéis", "parecen", "parecí", "pareciste", "pareció", "parecimos", "parecisteis", "parecieron", "parecía", "parecías", "parecíamos", "parecíais", "parecían", "parecería", "parecerías", "pareceríamos", "pareceríais", "parecerían", "pareceré", "parecerás", "parecerá", "pareceremos", "pareceréis", "parecerán", "parezca", "parezcas", "parezcamos", "parezcáis", "parezcan", "pareciera", "parecieras", "pareciéramos", "parecierais", "parecieran", "pareciese", "parecieses", "pareciésemos", "parecieseis", "pareciesen", "pareciere", "parecieres", "pareciéremos", "pareciereis", "parecieren", "pareced", "parecido"]; var delexicalizedVerbsInfinitive = ["hacer", "parecer"]; var generalAdjectivesAdverbs = ["enfrente", "mejor", "peor", "menos", "claro", "bueno", "nuevo", "nueva", "nuevos", "nuevas", "viejo", "viejos", "vieja", "viejas", "anterior", "grande", "gran", "grandes", "mayores", "fácil", "fáciles", "rápido", "rápida", "rápidos", "rápidas", "lejos", "lejas", "difícil", "difíciles", "propio", "propios", "propia", "propias", "largo", "larga", "largos", "largas", "bajos", "baja", "bajas", "alto", "alta", "altos", "altas", "regular", "regulares", "normal", "pequeño", "pequeña", "pequeños", "pequeñas", "diminuta", "diminuto", "diminutas", "diminutos", "chiquitito", "chiquititos", "chiquitita", "chiquititas", "corta", "corto", "cortas", "cortos", "principal", "principales", "mismo", "mismos", "misma", "mismas", "capaz", "capaces", "cierta", "cierto", "ciertas", "ciertos", "llamado", "llamada", "llamados", "llamadas", "mayormente", "reciente", "recientes", "completa", "completo", "completas", "completos", "absoluta", "absoluto", "absolutas", "absolutos", "últimamente", "posible", "común", "comúnes", "comúnmente", "constantemente", "continuamente", "directamente", "fácilmente", "casi", "ligeramente", "estima", "estimada", "estimado", "aproximada", "aproximadamente", "última", "últimas", "último", "últimos", "diferente", "diferentes", "similar", "mal", "malo", "malos", "mala", "malas", "perfectamente", "excelente", "final", "general"]; var interjections = ["ah", "eh", "ejem", "ele", "achís", "adiós", "agur", "ajá", "ajajá", "ala", "alá", "albricias", "aleluya", "alerta", "alirón", "aló", "amalaya", "ar", "aro", "arrarray", "arre", "arsa", "atatay", "aúpa", "ax", "ay", "ayayay", "bah", "banzai", "barajo", "bla", "bravo", "buf", "bum", "ca", "caguendiós", "canastos", "caracho", "caracoles", "carajo", "caramba", "carape", "caray", "cáscaras", "cáspita", "cataplum", "ce", "chao", "chau", "che", "chis", "chist", "chitón", "cho", "chucho", "chus", "cielos", "clo", "coche", "cochi", "cojones", "concho", "coño", "córcholis", "cuchí", "cuidado", "cuz", "demonio", "demontre", "despacio", "diablo", "diantre", "dios", "ea", "epa", "equilicuá", "estúpido", "eureka", "evohé", "exacto", "fantástico", "firmes", "fo", "forte", "gua", "gualá", "guarte", "guay", "hala", "hale", "he", "hi", "hin", "hola", "hopo", "huesque", "huiche", "huichó", "huifa", "hurra", "huy", "ja", "jajajá", "jajay", "jaque", "jau", "jo", "jobar", "joder", "jolín", "jopo", "leñe", "listo", "malhayas", "mamola", "mecachis", "miéchica", "mondo", "moste", "mutis", "nanay", "narices", "oh", "ojalá", "ojo", "okay", "ole", "olé", "órdiga", "oste", "ostras", "ox", "oxte", "paf", "pardiez", "paso", "pucha", "puf", "puff", "pumba", "puñeta", "quia", "quiúbole", "recórcholis", "rediez", "rediós", "salve", "sanseacabó", "sniff", "socorro", "ta", "tararira", "tate", "tururú", "uf", "uh", "ui", "upa", "uste", "uy", "victoria", "vítor", "viva", "za", "zambomba", "zapateta", "zape", "zas"]; var recipeWords = ["kg", "mg", "gr", "g", "km", "m", "l", "ml", "cl"]; var timeWords = ["minuto", "minutos", "hora", "horas", "día", "días", "semana", "semanas", "mes", "meses", "año", "años", "hoy", "mañana", "ayer"]; var vagueNouns = ["cosa", "cosas", "manera", "maneras", "caso", "casos", "pieza", "piezas", "vez", "veces", "parte", "partes", "porcentaje", "instancia", "aspecto", "aspectos", "punto", "puntos", "objeto", "objectos", "persona", "personas"]; var miscellaneous = ["no", "euros"]; var titlesPreceding = ["sra", "sras", "srta", "sr", "sres", "dra", "dr", "profa", "prof"]; var titlesFollowing = ["jr", "sr"]; module.exports = function () { return { filteredAtBeginning: generalAdjectivesAdverbs, filteredAtEnding: [].concat(ordinalNumerals, otherAuxiliariesInfinitive, copulaInfinitive, delexicalizedVerbsInfinitive), filteredAtBeginningAndEnding: [].concat(articles, prepositions, coordinatingConjunctions, demonstrativePronouns, intensifiers, quantifiers, possessivePronouns), filteredAnywhere: [].concat(transitionWords, personalPronounsNominative, personalPronounsAccusative, personalPronounsPrepositional, personalPronounsComitative, interjections, cardinalNumerals, otherAuxiliaries, copula, interviewVerbs, delexicalizedVerbs, indefinitePronouns, correlativeConjunctions, subordinatingConjunctions, interrogativeDeterminers, interrogativePronouns, interrogativeProAdverbs, locativeAdverbs, miscellaneous, prepositionalAdverbs, recipeWords, timeWords, vagueNouns), all: [].concat(articles, cardinalNumerals, ordinalNumerals, demonstrativePronouns, possessivePronouns, personalPronounsNominative, personalPronounsComitative, personalPronounsPrepositional, personalPronounsAccusative, quantifiers, indefinitePronouns, interrogativeDeterminers, interrogativePronouns, interrogativeProAdverbs, locativeAdverbs, prepositionalAdverbs, otherAuxiliaries, otherAuxiliariesInfinitive, copula, copulaInfinitive, prepositions, coordinatingConjunctions, correlativeConjunctions, subordinatingConjunctions, interviewVerbs, transitionWords, additionalTransitionWords, intensifiers, delexicalizedVerbs, delexicalizedVerbsInfinitive, interjections, generalAdjectivesAdverbs, recipeWords, vagueNouns, miscellaneous, titlesPreceding, titlesFollowing) }; }; }), (function (module, exports, __webpack_require__) { "use strict"; var transitionWords = __webpack_require__(184)().singleWords; var articles = ["il", "i", "la", "le", "lo", "gli", "un", "uno", "una"]; var cardinalNumerals = ["due", "tre", "quattro", "cinque", "sette", "otto", "nove", "dieci", "undici", "dodici", "tredici", "quattordici", "quindici", "sedici", "diciassette", "diciotto", "diciannove", "venti", "cento", "mille", "mila", "duemila", "tremila", "quattromila", "cinquemila", "seimila", "settemila", "ottomila", "novemila", "diecimila", "milione", "milioni", "miliardo", "miliardi"]; var ordinalNumerals = ["prima", "primi", "prime", "secondo", "seconda", "secondi", "seconde", "terzo", "terza", "terzi", "terze", "quarto", "quarta", "quarti", "quarte", "quinto", "quinta", "quinti", "quinte", "sesto", "sesta", "sesti", "seste", "settimo", "settima", "settimi", "settime", "ottavo", "ottava", "ottavi", "ottave", "nono", "nona", "noni", "none", "decimo", "decima", "decimi", "decime", "undicesimo", "undicesima", "undicesimi", "undicesime", "dodicesimo", "dodicesima", "dodicesimi", "dodicesime", "tredicesimo", "tredicesima", "tredicesimi", "tredicesime", "quattordicesimo", "quattordicesima", "quattordicesimi", "quattordicesime", "quindicesimo", "quindicesima", "quindicesimi", "quindicesime", "sedicesimo", "sedicesima", "sedicesimi", "sedicesime", "diciassettesimo", "diciassettesima", "diciassettesimi", "diciassettesime", "diciannovesimo", "diciannovesima", "diciannovesimi", "diciannovesime", "ventesimo", "ventesima", "ventesimi", "ventesime"]; var personalPronounsNominative = ["io", "tu", "egli", "esso", "lui", "ella", "essa", "lei", "noi", "voi", "essi", "esse", "loro"]; var personalPronounsAccusative = ["mi", "ti", "si", "ci", "vi", "li", "me", "te", "se", "glie", "glielo", "gliela", "glieli", "gliele", "gliene", "ce", "ve"]; var personalPronounsPrepositional = ["sé"]; var demonstrativePronouns = ["ciò", "codesto", "codesta", "codesti", "codeste", "colei", "colui", "coloro", "costei", "costui", "costoro", "medesimo", "medesima", "medesimi", "medesime", "questo", "questa", "questi", "queste", "quello", "quella", "quelli", "quelle", "quel", "quei", "quegli"]; var possessivePronouns = ["mio", "mia", "miei", "mie", "tuo", "tua", "tuoi", "tue", "suo", "sua", "suoi", "sue", "nostro", "nostra", "nostri", "nostre", "vostro", "vostra", "vostri", "vostre"]; var quantifiers = ["affatto", "alcun", "alcuna", "alcune", "alcuni", "alcuno", "bastantemente", "grandemente", "massimamente", "meno", "minimamente", "molta", "molte", "molti", "moltissimo", "molto", "nessun", "nessuna", "nessuno", "niente", "nulla", "ogni", "più", "po'", "poca", "poche", "pochi", "poco", "pochissime", "pochissimi", "qualche", "qualsiasi", "qualunque", "quintali", "rara", "rarissima", "rarissimo", "raro", "spesso", "spessissimo", "sufficientemente", "taluno", "taluna", "taluni", "talune", "tanta", "tante", "tanti", "tantissime", "tantissimi", "tanto", "tonnellate", "troppa", "troppe", "troppi", "troppo", "tutta", "tutte", "tutti", "tutto"]; var indefinitePronouns = ["alcunché", "alcunchè", "altro", "altra", "altri", "altre", "certa", "certi", "certe", "checché", "checchè", "chicchessia", "chiunque", "ciascuno", "ciascuna", "ciascun", "diverso", "diversa", "diversi", "diverse", "parecchio", "parecchia", "parecchi", "parecchie", "qualcosa", "qualcuno", "qualcuna", "vario", "varia", "vari", "varie"]; var interrogativeDeterminers = ["che", "cosa", "cui", "qual", "quale", "quali"]; var interrogativePronouns = ["chi", "quanta", "quante", "quanti", "quanto"]; var interrogativeAdverbs = ["com'è", "com'era", "com'erano", "donde", "d'onde", "dove", "dov'è", "dov'era", "dov'erano", "dovunque"]; var pronominalAdverbs = ["ne"]; var locativeAdverbs = ["accanto", "altrove", "attorno", "dappertutto", "giù", "là", "laggiù", "lassù", "lì", "ovunque", "qua", "quaggiù", "quassù", "qui"]; var filteredPassiveAuxiliaries = ["vengano", "vengo", "vengono", "veniamo", "veniate", "venimmo", "venisse", "venissero", "venissi", "venissimo", "veniste", "venisti", "venite", "veniva", "venivamo", "venivano", "venivate", "venivi", "venivo", "venne", "vennero", "venni", "verrà", "verrai", "verranno", "verrebbe", "verrebbero", "verrei", "verremmo", "verremo", "verreste", "verresti", "verrete", "verrò", "viene", "vieni"]; var passiveAuxiliariesInfinitive = ["venire", "venir"]; var otherAuxiliaries = ["abbi", "abbia", "abbiamo", "abbiano", "abbiate", "abbiente", "avemmo", "avendo", "avente", "avesse", "avessero", "avessi", "avessimo", "aveste", "avesti", "avete", "aveva", "avevamo", "avevano", "avevate", "avevi", "avevo", "avrà", "avrai", "avranno", "avrebbe", "avrebbero", "avrei", "avremmo", "avremo", "avreste", "avresti", "avrete", "avrò", "avuto", "ebbe", "ebbero", "ebbi", "ha", "hai", "hanno", "ho", "possa", "possano", "possiamo", "possiate", "posso", "possono", "poté", "potei", "potemmo", "potendo", "potente", "poterono", "potesse", "potessero", "potessi", "potessimo", "poteste", "potesti", "potete", "potette", "potettero", "potetti", "poteva", "potevamo", "potevano", "potevate", "potevi", "potevo", "potrà", "potrai", "potranno", "potrebbe", "potrebbero", "potrei", "potremmo", "potremo", "potreste", "potresti", "potrete", "potrò", "potuto", "può", "puoi", "voglia", "vogliamo", "vogliano", "vogliate", "voglio", "vogliono", "volemmo", "volendo", "volente", "volesse", "volessero", "volessi", "volessimo", "voleste", "volesti", "volete", "voleva", "volevamo", "volevano", "volevate", "volevi", "volevo", "volle", "vollero", "volli", "voluto", "vorrà", "vorrai", "vorranno", "vorrebbe", "vorrebbero", "vorrei", "vorremmo", "vorremo", "vorreste", "vorresti", "vorrete", "vorrò", "vuoi", "vuole", "debba", "debbano", "debbono", "deva", "deve", "devi", "devo", "devono", "dobbiamo", "dobbiate", "dové", "dovei", "dovemmo", "dovendo", "doverono", "dovesse", "dovessero", "dovessi", "dovessimo", "doveste", "dovesti", "dovete", "dovette", "dovettero", "dovetti", "doveva", "dovevamo", "dovevano", "dovevate", "dovevi", "dovevo", "dovrà", "dovrai", "dovranno", "dovrebbe", "dovrebbero", "dovrei", "dovremmo", "dovremo", "dovreste", "dovresti", "dovrete", "dovrò", "dovuto", "sa", "sai", "sanno", "sapemmo", "sapendo", "sapesse", "sapessero", "sapessi", "sapessimo", "sapeste", "sapesti", "sapete", "sapeva", "sapevamo", "sapevano", "sapevate", "sapevi", "sapevo", "sappi", "sappia", "sappiamo", "sappiano", "sappiate", "saprà", "saprai", "sapranno", "saprebbe", "saprebbero", "saprei", "sapremmo", "sapremo", "sapreste", "sapresti", "saprete", "saprò", "saputo", "seppe", "seppero", "seppi", "so", "soglia", "sogliamo", "sogliano", "sogliate", "soglio", "sogliono", "solesse", "solessero", "solessi", "solessimo", "soleste", "solete", "soleva", "solevamo", "solevano", "solevate", "solevi", "solevo", "suoli", "sta", "stai", "stando", "stanno", "stante", "starà", "starai", "staranno", "staremo", "starete", "starò", "stava", "stavamo", "stavano", "stavate", "stavi", "stavo", "stemmo", "stessero", "stessimo", "steste", "stesti", "stette", "stettero", "stetti", "stia", "stiamo", "stiano", "stiate", "sto"]; var otherAuxiliariesInfinitive = ["avere", "aver", "potere", "poter", "volere", "voler", "dovere", "dover", "sapere", "saper", "solere", "stare", "star"]; var copula = ["è", "e'", "era", "erano", "eravamo", "eravate", "eri", "ero", "essendo", "essente", "fosse", "fossero", "fossi", "fossimo", "foste", "fosti", "fu", "fui", "fummo", "furono", "sarà", "sarai", "saranno", "sarebbe", "sarebbero", "sarei", "saremmo", "saremo", "sareste", "saresti", "sarete", "sarò", "sei", "sia", "siamo", "siano", "siate", "siete", "sii", "sono", "stata", "state", "stati", "stato"]; var copulaInfinitive = ["essere", "esser"]; var prepositions = ["di", "del", "dello", "della", "dei", "degli", "delle", "a", "ad", "al", "allo", "alla", "ai", "agli", "alle", "da", "dal", "dallo", "dalla", "dai", "dagli", "dalle", "in", "nel", "nello", "nella", "nei", "negli", "nelle", "con", "col", "collo", "colla", "coi", "cogli", "colle", "su", "sul", "sullo", "sulla", "sui", "sugli", "sulle", "per", "pel", "pello", "pella", "pei", "pegli", "tra", "fra", "attraverso", "circa", "contro", "davanti", "dentro", "dietro", "entro", "escluso", "fuori", "insieme", "intorno", "lontano", "lungo", "mediante", "oltre", "presso", "rasente", "riguardo", "senza", "sopra", "sotto", "tramite", "vicino"]; var coordinatingConjunctions = ["e", "ed", "o", "oppure"]; var correlativeConjunctions = ["tale", "l'uno", "l'altro", "tali", "dall'altra"]; var subordinatingConjunctions = ["anziché", "anzichè", "fuorché", "fuorchè", "giacché", "giacchè", "laddove", "modo", "ove", "qualora", "quantunque", "volta"]; var interviewVerbs = ["dice", "dicono", "diceva", "dicevano", "disse", "dissero", "detto", "domanda", "domandano", "domandava", "domandavano", "domandò", "domandarono", "domandato", "afferma", "affermato", "aggiunge", "aggiunto", "ammette", "ammesso", "annuncia", "annunciato", "assicura", "assicurato", "chiede", "chiesto", "commentato", "conclude", "concluso", "continua", "continuato", "denuncia", "denunciato", "dichiara", "dichiarato", "esordisce", "esordito", "inizia", "iniziato", "precisato", "prosegue", "proseguito", "racconta", "raccontato", "recita", "recitato", "replica", "replicato", "risponde", "risposto", "rimarca", "rimarcato", "rivela", "rivelato", "scandisce", "scandito", "scrive", "scritto", "segnala", "segnalato", "sottolinea", "sottolineato", "spiega", "spiegato"]; var interviewVerbsInfinitive = ["affermare", "aggiungere", "ammettere", "annunciare", "assicurare", "chiedere", "commentare", "concludere", "continuare", "denunciare", "dichiarare", "esordire", "iniziare", "precisare", "proseguire", "raccontare", "recitare", "replicare", "rispondere", "rimarcare", "rivelare", "scandire", "scrivere", "segnalare", "sottolineare", "spiegare"]; var additionalTransitionWords = ["eventualmente", "forse", "mai", "probabilmente"]; var intensifiers = ["addirittura", "assolutamente", "ben", "estremamente", "mica", "nemmeno", "quasi"]; var delexicalizedVerbs = ["fa", "fa'", "faccia", "facciamo", "facciano", "facciate", "faccio", "facemmo", "facendo", "facente", "facesse", "facessero", "facessi", "facessimo", "faceste", "facesti", "faceva", "facevamo", "facevano", "facevate", "facevi", "facevo", "fai", "fanno", "farà", "farai", "faranno", "farebbe", "farebbero", "farei", "faremmo", "faremo", "fareste", "faresti", "farete", "farò", "fate", "fatto", "fece", "fecero", "feci", "fo"]; var delexicalizedVerbsInfinitive = ["fare"]; var generalAdjectivesAdverbs = ["anteriore", "anteriori", "precedente", "precedenti", "facile", "facili", "facilissimo", "facilissima", "facilissimi", "facilissime", "semplice", "semplici", "semplicissima", "semplicissimo", "semplicissimi", "semplicissime", "semplicemente", "rapido", "rapida", "rapidi", "rapide", "veloce", "veloci", "differente", "difficile", "difficili", "difficilissimo", "difficilissima", "difficilissimi", "difficilissime", "basso", "bassa", "bassi", "basse", "alto", "alta", "alti", "alte", "normale", "normali", "normalmente", "corto", "corta", "corti", "corte", "breve", "brevi", "recente", "recenti", "totale", "totali", "completo", "completa", "completi", "complete", "possibile", "possibili", "ultimo", "ultima", "ultimi", "ultime", "differenti", "simile", "simili", "prossimo", "prossima", "prossimi", "prossime", "giusto", "giusta", "giusti", "giuste", "giustamente", "cosiddetto", "bene", "meglio", "benissimo", "male", "peggio", "malissimo", "comunemente", "constantemente", "direttamente", "esattamente", "facilmente", "generalmente", "leggermente", "personalmente", "recentemente", "sinceramente", "solamente", "avanti", "indietro"]; var generalAdjectivesAdverbsPreceding = ["nuovo", "nuova", "nuovi", "nuove", "vecchio", "vecchia", "vecchi", "vecchie", "bello", "bella", "belli", "belle", "bellissimo", "bellissima", "bellissimi", "bellissime", "buono", "buona", "buoni", "buone", "buonissimo", "buonissima", "buonissimi", "buonissime", "grande", "grandi", "grandissimo", "grandissima", "grandissimi", "grandissime", "lunga", "lunghi", "lunghe", "piccolo", "piccola", "piccoli", "piccole", "piccolissimo", "piccolissima", "piccolissimi", "piccolissime", "proprio", "propria", "propri", "proprie", "solito", "solita", "soliti", "solite", "stesso", "stessa", "stessi", "stesse"]; var interjections = ["accidenti", "acciderba", "ah", "aah", "ahi", "ahia", "ahimé", "bah", "beh", "boh", "ca", "caspita", "chissà", "de'", "diamine", "ecco", "eh", "ehi", "eeh", "ehilà", "ehm", "gna", "ih", "magari", "macché", "macchè", "mah", "mhm", "nca", "neh", "oibò", "oh", "ohe", "ohé", "ohilá", "ohibò", "ohimé", "okay", "ok", "olà", "poh", "pota", "puah", "sorbole", "to'", "toh", "ts", "uff", "uffa", "uh", "uhi"]; var recipeWords = ["cc", "g", "hg", "hl", "kg", "l", "prs", "pz", "q.b.", "qb", "ta", "tz"]; var timeWords = ["minuto", "minuti", "ora", "ore", "giorno", "giorni", "giornata", "giornate", "settimana", "settimane", "mese", "mesi", "anno", "anni", "oggi", "domani", "ieri", "stamattina", "stanotte", "stasera", "tardi"]; var vagueNouns = ["aspetto", "aspetti", "caso", "casi", "cose", "idea", "idee", "istanza", "maniera", "oggetto", "oggetti", "parte", "parti", "persona", "persone", "pezzo", "pezzi", "punto", "punti", "sorta", "sorte", "tema", "temi", "volte"]; var miscellaneous = ["sì", "no", "non", "€", "euro", "euros", "ecc", "eccetera"]; var titlesPreceding = ["sig.na", "sig.ra", "sig", "sigg", "dr", "dr.ssa", "dott", "dott.ssa", "prof", "prof.ssa", "gent", "gent.mo", "gent.mi", "gent.ma", "gent.me", "egr", "egr.i", "egr.ia", "egr.ie", "preg.mo", "preg.mo", "preg.ma", "preg.me", "ill", "ill.mo", "ill.mi", "ill.ma", "ill.me", "cav", "on", "spett"]; module.exports = function () { return { filteredAtBeginning: generalAdjectivesAdverbs, filteredAtEnding: [].concat(ordinalNumerals, interviewVerbsInfinitive, passiveAuxiliariesInfinitive, otherAuxiliariesInfinitive, copulaInfinitive, delexicalizedVerbsInfinitive, generalAdjectivesAdverbsPreceding), filteredAtBeginningAndEnding: [].concat(articles, prepositions, coordinatingConjunctions, demonstrativePronouns, intensifiers, quantifiers, possessivePronouns), filteredAnywhere: [].concat(transitionWords, personalPronounsNominative, personalPronounsAccusative, personalPronounsPrepositional, interjections, cardinalNumerals, filteredPassiveAuxiliaries, otherAuxiliaries, copula, interviewVerbs, delexicalizedVerbs, indefinitePronouns, correlativeConjunctions, subordinatingConjunctions, interrogativeDeterminers, interrogativePronouns, interrogativeAdverbs, locativeAdverbs, miscellaneous, pronominalAdverbs, recipeWords, timeWords, vagueNouns), all: [].concat(articles, cardinalNumerals, ordinalNumerals, demonstrativePronouns, possessivePronouns, personalPronounsNominative, personalPronounsAccusative, personalPronounsPrepositional, quantifiers, indefinitePronouns, interrogativePronouns, interrogativeAdverbs, interrogativeDeterminers, pronominalAdverbs, locativeAdverbs, filteredPassiveAuxiliaries, passiveAuxiliariesInfinitive, otherAuxiliaries, otherAuxiliariesInfinitive, copula, copulaInfinitive, prepositions, coordinatingConjunctions, correlativeConjunctions, subordinatingConjunctions, interviewVerbs, interviewVerbsInfinitive, transitionWords, additionalTransitionWords, intensifiers, delexicalizedVerbs, delexicalizedVerbsInfinitive, interjections, generalAdjectivesAdverbs, generalAdjectivesAdverbsPreceding, recipeWords, vagueNouns, miscellaneous, timeWords, titlesPreceding) }; }; }), (function (module, exports, __webpack_require__) { "use strict"; var transitionWords = __webpack_require__(181)().singleWords; var articles = ["le", "la", "les", "un", "une", "des", "aux", "du", "au", "d'un", "d'une"]; var cardinalNumerals = ["deux", "trois", "quatre", "cinq", "six", "sept", "huit", "neuf", "dix", "onze", "douze", "treize", "quatorze", "quinze", "seize", "dix-sept", "dix-huit", "dix-neuf", "vingt", "trente", "quarante", "cinquante", "soixante", "soixante-dix", "quatre-vingt", "quatre-vingt-dix", "cent", "mille", "million", "milliard"]; var ordinalNumerals = ["second", "secondes", "deuxième", "deuxièmes", "troisième", "troisièmes", "quatrième", "quatrièmes", "cinquième", "cinquièmes", "sixième", "sixièmes", "septième", "septièmes", "huitième", "huitièmes", "neuvième", "neuvièmes", "dixième", "dixièmes", "onzième", "onzièmes", "douzième", "douzièmes", "treizième", "treizièmes", "quatorzième", "quatorzièmes", "quinzième", "quinzièmes", "seizième", "seizièmes", "dix-septième", "dix-septièmes", "dix-huitième", "dix-huitièmes", "dix-neuvième", "dix-neuvièmes", "vingtième", "vingtièmes"]; var personalPronounsNominative = ["je", "tu", "il", "elle", "on", "nous", "vous", "ils", "elles"]; var personalPronounsStressed = ["moi", "toi", "lui", "soi", "eux"]; var personalPronounsAccusative = ["me", "te"]; var demonstrativePronouns = ["celui", "celle", "ceux", "celles", "ce", "celui-ci", "celui-là", "celle-ci", "celle-là", "ceux-ci", "ceux-là", "celles-ci", "celles-là", "ceci", "cela", "ça", "cette", "cet", "ces"]; var possessivePronouns = ["mon", "ton", "son", "ma", "ta", "sa", "mes", "tes", "ses", "notre", "votre", "leur", "nos", "vos", "leurs"]; var quantifiers = ["beaucoup", "peu", "quelque", "quelques", "tous", "tout", "toute", "toutes", "plusieurs", "plein", "chaque", "suffisant", "suffisante", "suffisantes", "suffisants", "faible", "moins", "tant", "plus", "divers", "diverse", "diverses"]; var reflexivePronouns = ["se"]; var indefinitePronouns = ["aucun", "aucune", "autre", "autres", "certain", "certaine", "certaines", "certains", "chacun", "chacune", "même", "mêmes", "quelqu'un", "quelqu'une", "quelques'uns", "quelques'unes", "autrui", "nul", "personne", "quiconque", "rien", "d'aucunes", "d'aucuns", "nuls", "nules", "l'autre", "l'autres", "tel", "telle", "tels", "telles"]; var relativePronouns = ["qui", "que", "lequel", "laquelle", "auquel", "auxquels", "auxquelles", "duquel", "desquels", "desquelles", "dont", "où", "quoi"]; var interrogativeProAdverbs = ["combien", "comment", "pourquoi", "d'où"]; var interrogativeAdjectives = ["quel", "quels", "quelle"]; var pronominalAdverbs = ["y"]; var locativeAdverbs = ["là", "ici", "voici"]; var otherAuxiliaries = ["a", "a-t-elle", "a-t-il", "a-t-on", "ai", "ai-je", "aie", "as", "as-tu", "aura", "aurai", "auraient", "aurais", "aurait", "auras", "aurez", "auriez", "aurons", "auront", "avaient", "avais", "avait", "avez", "avez-vous", "aviez", "avions", "avons", "avons-nous", "ayez", "ayons", "eu", "eûmes", "eurent", "eus", "eut", "eûtes", "j'ai", "j'aurai", "j'avais", "j'eus", "ont", "ont-elles", "ont-ils", "vais", "vas", "va", "allons", "allez", "vont", "vais-je", "vas-tu", "va-t-il", "va-t-elle", "va-t-on", "allons-nous", "allez-vous", "vont-elles", "vont-ils", "allé", "allés", "j'allai", "allai", "allas", "alla", "allâmes", "allâtes", "allèrent", "j'allais", "allais", "allait", "allions", "alliez", "allaient", "j'irai", "iras", "ira", "irons", "irez", "iront", "j'aille", "aille", "ailles", "aillent", "j'allasse", "allasse", "allasses", "allât", "allassions", "allassiez", "allassent", "j'irais", "irais", "irait", "irions", "iriez", "iraient", "allant", "viens", "vient", "venons", "venez", "viennent", "viens-je", "viens-de", "vient-il", "vient-elle", "vient-on", "venons-nous", "venez-vous", "viennent-elles", "viennent-ils", "vins", "vint", "vînmes", "vîntes", "vinrent", "venu", "venus", "venais", "venait", "venions", "veniez", "venaient", "viendrai", "viendras", "viendra", "viendrons", "viendrez", "viendront", "vienne", "viennes", "vinsse", "vinsses", "vînt", "vinssions", "vinssiez", "vinssent", "viendrais", "viendrait", "viendrions", "viendriez", "viendraient", "venant", "dois", "doit", "devons", "devez", "doivent", "dois-je", "dois-tu", "doit-il", "doit-elle", "doit-on", "devons-nous", "devez-vous", "doivent-elles", "doivent-ils", "dus", "dut", "dûmes", "dûtes", "durent", "dû", "devais", "devait", "devions", "deviez", "devaient", "devrai", "devras", "devra", "devrons", "devrez", "devront", "doive", "doives", "dusse", "dusses", "dût", "dussions", "dussiez", "dussent", "devrais", "devrait", "devrions", "devriez", "devraient", "peux", "peut", "pouvons", "pouvez", "peuvent", "peux-je", "peux-tu", "peut-il", "peut-elle", "peut-on", "pouvons-nous", "pouvez-vous", "peuvent-ils", "peuvent-elles", "pus", "put", "pûmes", "pûtes", "purent", "pu", "pouvais", "pouvait", "pouvions", "pouviez", "pouvaient", "pourrai", "pourras", "pourra", "pourrons", "pourrez", "pourront", "puisse", "puisses", "puissions", "puissiez", "puissent", "pusse", "pusses", "pût", "pussions", "pussiez", "pussent", "pourrais", "pourrait", "pourrions", "pourriez", "pourraient", "pouvant", "semble", "sembles", "semblons", "semblez", "semblent", "semble-je", "sembles-il", "sembles-elle", "sembles-on", "semblons-nous", "semblez-vous", "semblent-ils", "semblent-elles", "semblai", "semblas", "sembla", "semblâmes", "semblâtes", "semblèrent", "semblais", "semblait", "semblions", "sembliez", "semblaient", "semblerai", "sembleras", "semblera", "semblerons", "semblerez", "sembleront", "semblé", "semblasse", "semblasses", "semblât", "semblassions", "semblassiez", "semblassent", "semblerais", "semblerait", "semblerions", "sembleriez", "sembleraient", "parais", "paraît", "ait", "paraissons", "paraissez", "paraissent", "parais-je", "parais-tu", "paraît-il", "paraît-elle", "paraît-on", "ait-il", "ait-elle", "ait-on", "paraissons-nous", "paraissez-vous", "paraissent-ils", "paraissent-elles", "parus", "parut", "parûmes", "parûtes", "parurent", "paraissais", "paraissait", "paraissions", "paraissiez", "paraissaient", "paraîtrai", "paraîtras", "paraîtra", "paraîtrons", "paraîtrez", "paraîtront", "aitrai", "aitras", "aitra", "aitrons", "aitrez", "aitront", "paru", "paraisse", "paraisses", "parusse", "parusses", "parût", "parussions", "parussiez", "parussent", "paraîtrais", "paraîtrait", "paraîtrions", "paraîtriez", "paraîtraient", "paraitrais", "paraitrait", "paraitrions", "paraitriez", "paraitraient", "paraissant", "mets", "met", "mettons", "mettez", "mettent", "mets-je", "mets-tu", "met-il", "met-elle", "met-on", "mettons-nous", "mettez-vous", "mettent-ils", "mettent-elles", "mis", "mit", "mîmes", "mîtes", "mirent", "mettais", "mettait", "mettions", "mettiez", "mettaient", "mettrai", "mettras", "mettra", "mettrons", "mettrez", "mettront", "mette", "mettes", "misse", "misses", "mît", "missions", "missiez", "missent", "mettrais", "mettrait", "mettrions", "mettriez", "mettraient", "mettant", "finis", "finit", "finissons", "finissez", "finissent", "finis-je", "finis-tu", "finit-il", "finit-elle", "finit-on", "finissons-nous", "finissez-vous", "finissent-ils", "finissent-elles", "finîmes", "finîtes", "finirent", "finissais", "finissait", "finissions", "finissiez", "finissaient", "finirai", "finiras", "finira", "finirons", "finirez", "finiront", "fini", "finisse", "finisses", "finît", "finirais", "finirait", "finirions", "finiriez", "finiraient", "finissant"]; var otherAuxiliariesInfinitive = ["avoir", "aller", "venir", "devoir", "pouvoir", "sembler", "paraître", "paraitre", "mettre", "finir"]; var copula = ["suis", "es", "est", "est-ce", "n'est", "sommes", "êtes", "sont", "suis-je", "es-tu", "est-il", "est-elle", "est-on", "sommes-nous", "êtes-vous", "sont-ils", "sont-elles", "étais", "était", "étions", "étiez", "étaient", "serai", "seras", "sera", "serons", "serez", "seront", "serais", "serait", "serions", "seriez", "seraient", "sois", "soit", "soyons", "soyez", "soient", "été"]; var copulaInfinitive = ["être"]; var prepositions = ["à", "après", "au-delà", "au-dessous", "au-dessus", "avant", "avec", "concernant", "chez", "contre", "dans", "de", "depuis", "derrière", "dès", "devant", "durant", "en", "entre", "envers", "environ", "hormis", "hors", "jusque", "jusqu'à", "jusqu'au", "jusqu'aux", "loin", "moyennant", "outre", "par", "parmi", "pendant", "pour", "près", "quant", "sans", "sous", "sur", "travers", "vers", "voilà"]; var coordinatingConjunctions = ["et", "ni", "or", "ou"]; var correlativeConjunctions = ["non", "pas", "seulement", "sitôt", "aussitôt", "d'autre"]; var subordinatingConjunctions = ["afin", "autant", "comme", "d'autant", "d'ici", "quand", "lors", "parce", "si", "tandis"]; var interviewVerbs = ["dit", "disent", "dit-il", "dit-elle", "disent-ils", "disent-elles", "disait", "disait-il", "disait-elle", "disaient-ils", "disaient-elles", "dirent", "demande", "demandent", "demande-t-il", "demande-t-elle", "demandent-ils", "demandent-elles", "demandait", "demandaient", "demandait-il", "demandait-elle", "demandaient-ils", "demandaient-elles", "demanda", "demanda-t-il", "demanda-t-elle", "demandé", "pense", "pensent", "pense-t-il", "pense-t-elle", "pensent-ils", "pensent-elles", "pensait", "pensaient", "pensait-il", "pensait-elle", "pensaient-ils", "pensaient-elles", "pensa", "pensa-t-il", "pensa-t-elle", "pensé", "affirme", "affirme-t-il", "affirme-t-elle", "affirmé", "avoue", "avoue-t-il", "avoue-t-elle", "avoué", "concède", "concède-t-il", "concède-t-elle", "concédé", "confie", "confie-t-il", "confie-t-elle", "confié", "continue", "continue-t-il", "continue-t-elle", "continué", "déclame", "déclame-t-il", "déclame-t-elle", "déclamé", "déclare", "déclare-t-il", "déclare-t-elle", "déclaré", "déplore", "déplore-t-il", "déplore-t-elle", "déploré", "explique", "explique-t-il", "explique-t-elle", "expliqué", "lance", "lance-t-il", "lance-t-elle", "lancé", "narre", "narre-t-il", "narre-t-elle", "narré", "raconte", "raconte-t-il", "raconte-t-elle", "raconté", "rappelle", "rappelle-t-il", "rappelle-t-elle", "rappelé", "réagit", "réagit-il", "réagit-elle", "réagi", "répond", "répond-il", "répond-elle", "répondu", "rétorque", "rétorque-t-il", "rétorque-t-elle", "rétorqué", "souligne", "souligne-t-il", "souligne-t-elle", "souligné", "affirme-t-il", "affirme-t-elle", "ajoute-t-il", "ajoute-t-elle", "analyse-t-il", "analyse-t-elle", "avance-t-il", "avance-t-elle", "écrit-il", "écrit-elle", "indique-t-il", "indique-t-elle", "poursuit-il", "poursuit-elle", "précise-t-il", "précise-t-elle", "résume-t-il", "résume-t-elle", "souvient-il", "souvient-elle", "témoigne-t-il", "témoigne-t-elle"]; var interviewVerbsInfinitive = ["dire", "penser", "demander", "concéder", "continuer", "confier", "déclamer", "déclarer", "déplorer", "expliquer", "lancer", "narrer", "raconter", "rappeler", "réagir", "répondre", "rétorquer", "souligner", "affirmer", "ajouter", "analyser", "avancer", "écrire", "indiquer", "poursuivre", "préciser", "résumer", "témoigner"]; var additionalTransitionWords = ["encore", "éternellement", "immédiatement", "compris", "comprenant", "inclus", "naturellement", "particulièrement", "notablement", "actuellement", "maintenant", "ordinairement", "généralement", "habituellement", "d'habitude", "vraiment", "finalement", "uniquement", "peut-être", "initialement", "déjà", "c.-à-d", "souvent", "fréquemment", "régulièrement", "simplement", "éventuellement", "quelquefois", "parfois", "probable", "plausible", "jamais", "toujours", "incidemment", "accidentellement", "récemment", "dernièrement", "relativement", "clairement", "évidemment", "apparemment", "pourvu"]; var intensifiers = ["assez", "trop", "tellement", "presque", "très", "absolument", "extrêmement", "quasi", "quasiment", "fort"]; var delexicalizedVerbs = ["fais", "fait", "faisons", "faites", "font", "fais-je", "fait-il", "fait-elle", "fait-on", "faisons-nous", "faites-vous", "font-ils", "font-elles", "fis", "fit", "fîmes", "fîtes", "firent", "faisais", "faisait", "faisions", "faisiez", "faisaient", "ferai", "feras", "fera", "ferons", "ferez", "feront", "veux", "veut", "voulons", "voulez", "veulent", "voulus", "voulut", "voulûmes", "voulûtes", "voulurent", "voulais", "voulait", "voulions", "vouliez", "voulaient", "voudrai", "voudras", "voudra", "voudrons", "voudrez", "voudront", "voulu", "veux-je", "veux-tu", "veut-il", "veut-elle", "veut-on", "voulons-nous", "voulez-vous", "veulent-ils", "veulent-elles", "voudrais", "voudrait", "voudrions", "voudriez", "voudraient", "voulant"]; var delexicalizedVerbsInfinitive = ["faire", "vouloir"]; var generalAdjectivesAdverbs = ["antérieur", "antérieures", "antérieurs", "antérieure", "précédent", "précédents", "précédente", "précédentes", "facile", "faciles", "simple", "simples", "vite", "vites", "vitesse", "vitesses", "difficile", "difficiles", "propre", "propres", "long", "longe", "longs", "longes", "longue", "longues", "bas", "basse", "basses", "ordinaire", "ordinaires", "bref", "brefs", "brève", "brèves", "sûr", "sûrs", "sûre", "sûres", "sure", "sures", "surs", "habituel", "habituels", "habituelle", "habituelles", "soi-disant", "surtout", "récent", "récents", "récente", "récentes", "total", "totaux", "totale", "totales", "complet", "complets", "complète", "complètes", "possible", "possibles", "communément", "constamment", "facilement", "continuellement", "directement", "légèrement", "dernier", "derniers", "dernière", "dernières", "différent", "différents", "différente", "différentes", "similaire", "similaires", "pareil", "pareils", "pareille", "pareilles", "largement", "mal", "super", "bien", "pire", "pires", "suivants", "suivante", "suivantes", "prochain", "prochaine", "prochains", "prochaines", "proche", "proches", "fur"]; var generalAdjectivesAdverbsPreceding = ["nouveau", "nouvel", "nouvelle", "nouveaux", "nouvelles", "vieux", "vieil", "vieille", "vieilles", "beau", "bel", "belle", "belles", "bon", "bons", "bonne", "bonnes", "grand", "grande", "grands", "grandes", "haut", "hauts", "haute", "hautes", "petit", "petite", "petits", "petites", "meilleur", "meilleurs", "meilleure", "meilleures", "joli", "jolis", "jolie", "jolies", "gros", "grosse", "grosses", "mauvais", "mauvaise", "mauvaises", "dernier", "derniers", "dernière", "dernières"]; var interjections = ["ah", "ha", "oh", "ho", "bis", "plouf", "vlan", "ciel", "pouf", "paf", "crac", "hurrah", "allo", "stop", "bravo", "ô", "eh", "hé", "aïe", "oef", "ahi", "fi", "zest", "hem", "holà", "chut"]; var recipeWords = ["mg", "g", "kg", "ml", "dl", "cl", "l", "grammes", "gram", "once", "onces", "oz", "lbs", "càc", "cc", "càd", "càs", "càt", "cd", "cs", "ct"]; var timeWords = ["minute", "minutes", "heure", "heures", "journée", "journées", "semaine", "semaines", "mois", "année", "années", "aujourd'hui", "demain", "hier", "après-demain", "avant-hier"]; var vagueNouns = ["chose", "choses", "façon", "façons", "pièce", "pièces", "truc", "trucs", "fois", "cas", "aspect", "aspects", "objet", "objets", "idée", "idées", "thème", "thèmes", "sujet", "sujets", "personnes", "manière", "manières", "sorte", "sortes"]; var miscellaneous = ["ne", "oui", "d'accord", "amen", "euro", "euros", "etc"]; var titlesPreceding = ["mme", "mmes", "mlle", "mlles", "mm", "dr", "pr"]; var titlesFollowing = ["jr", "sr"]; module.exports = function () { return { filteredAtEnding: [].concat(ordinalNumerals, otherAuxiliariesInfinitive, delexicalizedVerbsInfinitive, copulaInfinitive, interviewVerbsInfinitive, generalAdjectivesAdverbsPreceding), filteredAtBeginning: generalAdjectivesAdverbs, filteredAtBeginningAndEnding: [].concat(articles, prepositions, coordinatingConjunctions, demonstrativePronouns, intensifiers, quantifiers, possessivePronouns), filteredAnywhere: [].concat(transitionWords, personalPronounsNominative, personalPronounsAccusative, personalPronounsStressed, reflexivePronouns, interjections, cardinalNumerals, copula, interviewVerbs, otherAuxiliaries, delexicalizedVerbs, indefinitePronouns, correlativeConjunctions, subordinatingConjunctions, interrogativeAdjectives, relativePronouns, locativeAdverbs, miscellaneous, pronominalAdverbs, recipeWords, timeWords, vagueNouns), all: [].concat(articles, cardinalNumerals, ordinalNumerals, demonstrativePronouns, possessivePronouns, reflexivePronouns, personalPronounsNominative, personalPronounsAccusative, relativePronouns, quantifiers, indefinitePronouns, interrogativeProAdverbs, pronominalAdverbs, locativeAdverbs, otherAuxiliaries, otherAuxiliariesInfinitive, interrogativeAdjectives, copula, copulaInfinitive, prepositions, coordinatingConjunctions, correlativeConjunctions, subordinatingConjunctions, interviewVerbs, interviewVerbsInfinitive, transitionWords, additionalTransitionWords, intensifiers, delexicalizedVerbs, delexicalizedVerbsInfinitive, interjections, generalAdjectivesAdverbs, generalAdjectivesAdverbsPreceding, recipeWords, vagueNouns, miscellaneous, timeWords, titlesPreceding, titlesFollowing) }; }; }), (function (module, exports, __webpack_require__) {
        var baseSlice = __webpack_require__(428), toInteger = __webpack_require__(75); function take(array, n, guard) {
            if (!(array && array.length)) { return []; }
            n = (guard || n === undefined) ? 1 : toInteger(n); return baseSlice(array, 0, n < 0 ? 0 : n);
        }
        module.exports = take;
    }), (function (module, exports) {
        function baseSlice(array, start, end) {
            var index = -1, length = array.length; if (start < 0) { start = -start > length ? 0 : (length + start); }
            end = end > length ? length : end; if (end < 0) { end += length; }
            length = start > end ? 0 : ((end - start) >>> 0); start >>>= 0; var result = Array(length); while (++index < length) { result[index] = array[index + start]; }
            return result;
        }
        module.exports = baseSlice;
    }), (function (module, exports, __webpack_require__) {
        "use strict"; var uniqBy = __webpack_require__(430); function removeDuplicateMarks(marks) { return uniqBy(marks, function (mark) { return mark.getOriginal(); }); }
        module.exports = removeDuplicateMarks;
    }), (function (module, exports, __webpack_require__) {
        var baseIteratee = __webpack_require__(18), baseUniq = __webpack_require__(431); function uniqBy(array, iteratee) { return (array && array.length) ? baseUniq(array, baseIteratee(iteratee, 2)) : []; }
        module.exports = uniqBy;
    }), (function (module, exports, __webpack_require__) {
        var SetCache = __webpack_require__(64), arrayIncludes = __webpack_require__(112), arrayIncludesWith = __webpack_require__(113), cacheHas = __webpack_require__(65), createSet = __webpack_require__(432), setToArray = __webpack_require__(66); var LARGE_ARRAY_SIZE = 200; function baseUniq(array, iteratee, comparator) {
            var index = -1, includes = arrayIncludes, length = array.length, isCommon = true, result = [], seen = result; if (comparator) { isCommon = false; includes = arrayIncludesWith; }
            else if (length >= LARGE_ARRAY_SIZE) {
                var set = iteratee ? null : createSet(array); if (set) { return setToArray(set); }
                isCommon = false; includes = cacheHas; seen = new SetCache;
            }
            else { seen = iteratee ? [] : result; }
            outer: while (++index < length) {
                var value = array[index], computed = iteratee ? iteratee(value) : value; value = (comparator || value !== 0) ? value : 0; if (isCommon && computed === computed) {
                    var seenIndex = seen.length; while (seenIndex--) { if (seen[seenIndex] === computed) { continue outer; } }
                    if (iteratee) { seen.push(computed); }
                    result.push(value);
                }
                else if (!includes(seen, computed, comparator)) {
                    if (seen !== result) { seen.push(computed); }
                    result.push(value);
                }
            }
            return result;
        }
        module.exports = baseUniq;
    }), (function (module, exports, __webpack_require__) { var Set = __webpack_require__(139), noop = __webpack_require__(433), setToArray = __webpack_require__(66); var INFINITY = 1 / 0; var createSet = !(Set && (1 / setToArray(new Set([, -0]))[1]) == INFINITY) ? noop : function (values) { return new Set(values); }; module.exports = createSet; }), (function (module, exports) {
        function noop() { }
        module.exports = noop;
    }), (function (module, exports, __webpack_require__) {
        "use strict"; var isUndefined = __webpack_require__(3); function showTrace(errorMessage) {
            if (isUndefined(errorMessage)) { errorMessage = ""; }
            if (!isUndefined(console) && !isUndefined(console.trace)) { console.trace(errorMessage); }
        }
        module.exports = { showTrace: showTrace };
    }), (function (module, exports, __webpack_require__) {
        var baseIndexOf = __webpack_require__(106), toInteger = __webpack_require__(75); var nativeMax = Math.max; function indexOf(array, value, fromIndex) {
            var length = array == null ? 0 : array.length; if (!length) { return -1; }
            var index = fromIndex == null ? 0 : toInteger(fromIndex); if (index < 0) { index = nativeMax(length + index, 0); }
            return baseIndexOf(array, value, index);
        }
        module.exports = indexOf;
    }), (function (module, exports) {
        var nativeMax = Math.max, nativeMin = Math.min; function baseInRange(number, start, end) { return number >= nativeMin(start, end) && number < nativeMax(start, end); }
        module.exports = baseInRange;
    }), (function (module, exports, __webpack_require__) {
        var escapeHtmlChar = __webpack_require__(438), toString = __webpack_require__(91); var reUnescapedHtml = /[&<>"']/g, reHasUnescapedHtml = RegExp(reUnescapedHtml.source); function escape(string) { string = toString(string); return (string && reHasUnescapedHtml.test(string)) ? string.replace(reUnescapedHtml, escapeHtmlChar) : string; }
        module.exports = escape;
    }), (function (module, exports, __webpack_require__) { var basePropertyOf = __webpack_require__(439); var htmlEscapes = { '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', "'": '&#39;' }; var escapeHtmlChar = basePropertyOf(htmlEscapes); module.exports = escapeHtmlChar; }), (function (module, exports) {
        function basePropertyOf(object) { return function (key) { return object == null ? undefined : object[key]; }; }
        module.exports = basePropertyOf;
    }), (function (module, exports, __webpack_require__) { "use strict"; var filter = __webpack_require__(6); var isSentenceTooLong = __webpack_require__(116); module.exports = function (sentences, recommendedValue) { var tooLongSentences = filter(sentences, function (sentence) { return isSentenceTooLong(recommendedValue, sentence.sentenceLength); }); return tooLongSentences; }; }), (function (module, exports, __webpack_require__) { var createAggregator = __webpack_require__(442); var partition = createAggregator(function (result, value, key) { result[key ? 0 : 1].push(value); }, function () { return [[], []]; }); module.exports = partition; }), (function (module, exports, __webpack_require__) {
        var arrayAggregator = __webpack_require__(443), baseAggregator = __webpack_require__(444), baseIteratee = __webpack_require__(18), isArray = __webpack_require__(4); function createAggregator(setter, initializer) { return function (collection, iteratee) { var func = isArray(collection) ? arrayAggregator : baseAggregator, accumulator = initializer ? initializer() : {}; return func(collection, setter, baseIteratee(iteratee, 2), accumulator); }; }
        module.exports = createAggregator;
    }), (function (module, exports) {
        function arrayAggregator(array, setter, iteratee, accumulator) {
            var index = -1, length = array == null ? 0 : array.length; while (++index < length) { var value = array[index]; setter(accumulator, value, iteratee(value), array); }
            return accumulator;
        }
        module.exports = arrayAggregator;
    }), (function (module, exports, __webpack_require__) {
        var baseEach = __webpack_require__(48); function baseAggregator(collection, setter, iteratee, accumulator) { baseEach(collection, function (value, key, collection) { setter(accumulator, value, iteratee(value), collection); }); return accumulator; }
        module.exports = baseAggregator;
    }), (function (module, exports, __webpack_require__) {
        var baseFlatten = __webpack_require__(73), baseOrderBy = __webpack_require__(446), baseRest = __webpack_require__(39), isIterateeCall = __webpack_require__(160); var sortBy = baseRest(function (collection, iteratees) {
            if (collection == null) { return []; }
            var length = iteratees.length; if (length > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) { iteratees = []; } else if (length > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) { iteratees = [iteratees[0]]; }
            return baseOrderBy(collection, baseFlatten(iteratees, 1), []);
        }); module.exports = sortBy;
    }), (function (module, exports, __webpack_require__) {
        var arrayMap = __webpack_require__(24), baseIteratee = __webpack_require__(18), baseMap = __webpack_require__(144), baseSortBy = __webpack_require__(447), baseUnary = __webpack_require__(69), compareMultiple = __webpack_require__(448), identity = __webpack_require__(37); function baseOrderBy(collection, iteratees, orders) { var index = -1; iteratees = arrayMap(iteratees.length ? iteratees : [identity], baseUnary(baseIteratee)); var result = baseMap(collection, function (value, key, collection) { var criteria = arrayMap(iteratees, function (iteratee) { return iteratee(value); }); return { 'criteria': criteria, 'index': ++index, 'value': value }; }); return baseSortBy(result, function (object, other) { return compareMultiple(object, other, orders); }); }
        module.exports = baseOrderBy;
    }), (function (module, exports) {
        function baseSortBy(array, comparer) {
            var length = array.length; array.sort(comparer); while (length--) { array[length] = array[length].value; }
            return array;
        }
        module.exports = baseSortBy;
    }), (function (module, exports, __webpack_require__) {
        var compareAscending = __webpack_require__(449); function compareMultiple(object, other, orders) {
            var index = -1, objCriteria = object.criteria, othCriteria = other.criteria, length = objCriteria.length, ordersLength = orders.length; while (++index < length) {
                var result = compareAscending(objCriteria[index], othCriteria[index]); if (result) {
                    if (index >= ordersLength) { return result; }
                    var order = orders[index]; return result * (order == 'desc' ? -1 : 1);
                }
            }
            return object.index - other.index;
        }
        module.exports = compareMultiple;
    }), (function (module, exports, __webpack_require__) {
        var isSymbol = __webpack_require__(46); function compareAscending(value, other) {
            if (value !== other) {
                var valIsDefined = value !== undefined, valIsNull = value === null, valIsReflexive = value === value, valIsSymbol = isSymbol(value); var othIsDefined = other !== undefined, othIsNull = other === null, othIsReflexive = other === other, othIsSymbol = isSymbol(other); if ((!othIsNull && !othIsSymbol && !valIsSymbol && value > other) || (valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol) || (valIsNull && othIsDefined && othIsReflexive) || (!valIsDefined && othIsReflexive) || !valIsReflexive) { return 1; }
                if ((!valIsNull && !valIsSymbol && !othIsSymbol && value < other) || (othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol) || (othIsNull && valIsDefined && valIsReflexive) || (!othIsDefined && valIsReflexive) || !othIsReflexive) { return -1; }
            }
            return 0;
        }
        module.exports = compareAscending;
    }), (function (module, exports, __webpack_require__) {
        var baseMerge = __webpack_require__(93), isObject = __webpack_require__(5); function customDefaultsMerge(objValue, srcValue, key, object, source, stack) {
            if (isObject(objValue) && isObject(srcValue)) { stack.set(srcValue, objValue); baseMerge(objValue, srcValue, undefined, customDefaultsMerge, stack); stack['delete'](srcValue); }
            return objValue;
        }
        module.exports = customDefaultsMerge;
    }), (function (module, exports, __webpack_require__) {
        var baseMerge = __webpack_require__(93), createAssigner = __webpack_require__(99);
        var mergeWith = createAssigner(function (object, source, srcIndex, customizer) {
            baseMerge(object, source, srcIndex, customizer);
        });
        module.exports = mergeWith;
    }), (function (module, exports, __webpack_require__) { "use strict"; module.exports = { sentenceLength: { recommendedWordCount: 20, slightlyTooMany: 25, farTooMany: 30 } }; }), (function (module, exports, __webpack_require__) { "use strict"; module.exports = { sentenceLength: { recommendedWordCount: 25 } }; }), (function (module, exports, __webpack_require__) {
        "use strict";
        __webpack_require__(455);
        var SnippetPreview = __webpack_require__(221);
        var defaultsDeep = __webpack_require__(117);
        var isObject = __webpack_require__(5);
        var isString = __webpack_require__(107);
        var MissingArgument = __webpack_require__(57);
        var isUndefined = __webpack_require__(3);
        var isEmpty = __webpack_require__(10);
        var forEach = __webpack_require__(1);
        var debounce = __webpack_require__(119);
        var throttle = __webpack_require__(475);
        var Jed = __webpack_require__(476);
        var SEOAssessor = __webpack_require__(114);
        var ContentAssessor = __webpack_require__(115);
        var CornerstoneSEOAssessor = __webpack_require__(477);
        var CornerstoneContentAssessor = __webpack_require__(478);
        var Researcher = __webpack_require__(81);
        var AssessorPresenter = __webpack_require__(479);
        var Pluggable = __webpack_require__(225);
        var Paper = __webpack_require__(226);
        var removeHtmlBlocks = __webpack_require__(485);
        var inputDebounceDelay = 400;

        var defaults = {
            callbacks: {
                bindElementEvents: function bindElementEvents() { },
                updateSnippetValues: function updateSnippetValues() { },
                saveScores: function saveScores() { },
                saveContentScore: function saveContentScore() { },
                updatedContentResults: function updatedContentResults() { },
                updatedKeywordsResults: function updatedKeywordsResults() { }
            },
            sampleText: {
                baseUrl: "example.org/",
                snippetCite: "example-post/",
                title: "This is an example title - edit by clicking here",
                keyword: "Choose a focus keyword",
                meta: "Modify your meta description by editing it right here",
                text: "Start writing your text!"
            },
            queue: ["wordCount", "keywordDensity", "subHeadings", "stopwords", "fleschReading", "linkCount", "imageCount", "urlKeyword", "urlLength", "metaDescription", "pageTitleKeyword", "pageTitleWidth", "firstParagraph", "'keywordDoubles"],
            typeDelay: 3000,
            typeDelayStep: 1500,
            maxTypeDelay: 5000,
            dynamicDelay: true,
            locale: "en_US",
            translations: {
                domain: "js-text-analysis",
                locale_data: {
                    "js-text-analysis": { "": {} }
                }
            },
            replaceTarget: [],
            resetTarget: [],
            elementTarget: [],
            marker: function marker() { },
            keywordAnalysisActive: true,
            contentAnalysisActive: true
        };
        function createDefaultSnippetPreview() {
            var targetElement = document.getElementById(this.config.targets.snippet);
            return new SnippetPreview({
                analyzerApp: this,
                targetElement: targetElement,
                callbacks: {
                    saveSnippetData: this.config.callbacks.saveSnippetData
                }
            });
        }

        function isValidSnippetPreview(snippetPreview) { return !isUndefined(snippetPreview) && SnippetPreview.prototype.isPrototypeOf(snippetPreview); }
        function verifyArguments(args) {
            if (!isObject(args.callbacks.getData)) { throw new MissingArgument("The app requires an object with a getdata callback."); }
            if (!isObject(args.targets)) { throw new MissingArgument("`targets` is a required App argument, `targets` is not an object."); }
            if (!isValidSnippetPreview(args.snippetPreview) && !isString(args.targets.snippet)) { throw new MissingArgument("A snippet preview is required. When no SnippetPreview object isn't passed to " + "the App, the `targets.snippet` is a required App argument. `targets.snippet` is not a string."); }
        }
        var App = function App(args) {
            if (!isObject(args)) { args = {}; }
            defaultsDeep(args, defaults); verifyArguments(args); this.config = args; this.refresh = debounce(this.refresh.bind(this), inputDebounceDelay); this._pureRefresh = throttle(this._pureRefresh.bind(this), this.config.typeDelay); this.callbacks = this.config.callbacks; this.i18n = this.constructI18n(this.config.translations); this.initializeAssessors(args); this.pluggable = new Pluggable(this); this.getData(); this.defaultOutputElement = this.getDefaultOutputElement(args); if (this.defaultOutputElement !== "") { this.showLoadingDialog(); }
            if (isValidSnippetPreview(args.snippetPreview)) { this.snippetPreview = args.snippetPreview; if (this.snippetPreview.refObj !== this) { this.snippetPreview.refObj = this; this.snippetPreview.i18n = this.i18n; } } else { this.snippetPreview = createDefaultSnippetPreview.call(this); }
            this.initSnippetPreview(); this.initAssessorPresenters(); this.refresh();
        }; App.prototype.getDefaultOutputElement = function (args) {
            if (args.keywordAnalysisActive) { return args.targets.output; }
            if (args.contentAnalysisActive) { return args.targets.contentOutput; }
            return "";
        }; App.prototype.switchAssessors = function (useCornerStone) { this.seoAssessor = this.getSeoAssessor(useCornerStone); this.contentAssessor = this.getContentAssessor(useCornerStone); this.initAssessorPresenters(); this.refresh(); }; App.prototype.getSeoAssessor = function (useCornerStone) {
            if (useCornerStone) { return this.cornerStoneSeoAssessor; }
            return this.defaultSeoAssessor;
        }; App.prototype.getContentAssessor = function (useCornerStone) {
            if (useCornerStone) { return this.cornerStoneContentAssessor; }
            return this.defaultContentAssessor;
        }; App.prototype.initializeAssessors = function (args) { this.initializeSEOAssessor(args); this.initializeContentAssessor(args); }; App.prototype.initializeSEOAssessor = function (args) {
            if (!args.keywordAnalysisActive) { return; }
            this.defaultSeoAssessor = new SEOAssessor(this.i18n, { marker: this.config.marker }); this.cornerStoneSeoAssessor = new CornerstoneSEOAssessor(this.i18n, { marker: this.config.marker }); if (isUndefined(args.seoAssessor)) { this.seoAssessor = this.defaultSeoAssessor; } else { this.seoAssessor = args.seoAssessor; }
        }; App.prototype.initializeContentAssessor = function (args) {
            if (!args.contentAnalysisActive) { return; }
            this.defaultContentAssessor = new ContentAssessor(this.i18n, { marker: this.config.marker, locale: this.config.locale }); this.cornerStoneContentAssessor = new CornerstoneContentAssessor(this.i18n, { marker: this.config.marker, locale: this.config.locale }); if (isUndefined(args.contentAssessor)) { this.contentAssessor = this.defaultContentAssessor; } else { this.contentAssessor = args.contentAssessor; }
        }; App.prototype.extendConfig = function (args) { args.sampleText = this.extendSampleText(args.sampleText); args.locale = args.locale || "en_US"; return args; }; App.prototype.extendSampleText = function (sampleText) {
            var defaultSampleText = defaults.sampleText; if (isUndefined(sampleText)) { return defaultSampleText; }
            for (var key in sampleText) { if (isUndefined(sampleText[key])) { sampleText[key] = defaultSampleText[key]; } }
            return sampleText;
        }; App.prototype.constructI18n = function (translations) { var defaultTranslations = { domain: "js-text-analysis", locale_data: { "js-text-analysis": { "": {} } } }; translations = translations || defaultTranslations; return new Jed(translations); }; App.prototype.getData = function () {
            this.rawData = this.callbacks.getData(); if (!isUndefined(this.snippetPreview)) { var data = this.snippetPreview.getAnalyzerData(); this.rawData.metaTitle = data.title; this.rawData.url = data.url; this.rawData.meta = data.metaDesc; }
            if (this.pluggable.loaded) { this.rawData.metaTitle = this.pluggable._applyModifications("data_page_title", this.rawData.metaTitle); this.rawData.meta = this.pluggable._applyModifications("data_meta_desc", this.rawData.meta); }
            this.rawData.locale = this.config.locale;
        }; App.prototype.refresh = function () { this._pureRefresh(); }; App.prototype._pureRefresh = function () { this.getData(); this.runAnalyzer(); }; App.prototype.initSnippetPreview = function () { this.snippetPreview.renderTemplate(); this.snippetPreview.callRegisteredEventBinder(); this.snippetPreview.bindEvents(); this.snippetPreview.init(); }; App.prototype.initAssessorPresenters = function () {
            if (!isUndefined(this.config.targets.output)) { this.seoAssessorPresenter = new AssessorPresenter({ targets: { output: this.config.targets.output }, assessor: this.seoAssessor, i18n: this.i18n }); }
            if (!isUndefined(this.config.targets.contentOutput)) { this.contentAssessorPresenter = new AssessorPresenter({ targets: { output: this.config.targets.contentOutput }, assessor: this.contentAssessor, i18n: this.i18n }); }
        }; App.prototype.bindInputEvent = function () { for (var i = 0; i < this.config.elementTarget.length; i++) { var elem = document.getElementById(this.config.elementTarget[i]); elem.addEventListener("input", this.refresh.bind(this)); } }; App.prototype.reloadSnippetText = function () { if (isUndefined(this.snippetPreview)) { this.snippetPreview.reRender(); } }; App.prototype.startTime = function () { this.startTimestamp = new Date().getTime(); }; App.prototype.endTime = function () { this.endTimestamp = new Date().getTime(); if (this.endTimestamp - this.startTimestamp > this.config.typeDelay) { if (this.config.typeDelay < this.config.maxTypeDelay - this.config.typeDelayStep) { this.config.typeDelay += this.config.typeDelayStep; } } }; App.prototype.runAnalyzer = function () {
            if (this.pluggable.loaded === false) { return; }
            if (this.config.dynamicDelay) { this.startTime(); }
            this.analyzerData = this.modifyData(this.rawData); this.snippetPreview.refresh(); var text = this.analyzerData.text; text = removeHtmlBlocks(text); this.paper = new Paper(text, { keyword: this.analyzerData.keyword, description: this.analyzerData.meta, url: this.analyzerData.url, title: this.analyzerData.metaTitle, titleWidth: this.snippetPreview.getTitleWidth(), locale: this.config.locale, permalink: this.analyzerData.permalink }); if (isUndefined(this.researcher)) { this.researcher = new Researcher(this.paper); } else { this.researcher.setPaper(this.paper); }
            this.runKeywordAnalysis(); this.runContentAnalysis(); this._renderAnalysisResults(); if (this.config.dynamicDelay) { this.endTime(); }
            this.snippetPreview.reRender();
        }; App.prototype.runKeywordAnalysis = function () {
            if (this.config.keywordAnalysisActive) {
                this.seoAssessor.assess(this.paper); var overallSeoScore = this.seoAssessor.calculateOverallScore(); if (!isUndefined(this.callbacks.updatedKeywordsResults)) { this.callbacks.updatedKeywordsResults(this.seoAssessor.results, overallSeoScore); }
                if (!isUndefined(this.callbacks.saveScores)) { this.callbacks.saveScores(overallSeoScore, this.seoAssessorPresenter); }
            }
        }; App.prototype.runContentAnalysis = function () {
            if (this.config.contentAnalysisActive) {
                this.contentAssessor.assess(this.paper); var overallContentScore = this.contentAssessor.calculateOverallScore(); if (!isUndefined(this.callbacks.updatedContentResults)) { this.callbacks.updatedContentResults(this.contentAssessor.results, overallContentScore); }
                if (!isUndefined(this.callbacks.saveContentScore)) { this.callbacks.saveContentScore(overallContentScore, this.contentAssessorPresenter); }
            }
        }; App.prototype.modifyData = function (data) { data = JSON.parse(JSON.stringify(data)); data.text = this.pluggable._applyModifications("content", data.text); data.metaTitle = this.pluggable._applyModifications("title", data.metaTitle); return data; }; App.prototype.pluginsLoaded = function () { this.getData(); this.removeLoadingDialog(); this.runAnalyzer(); }; App.prototype.showLoadingDialog = function () { var outputElement = document.getElementById(this.defaultOutputElement); if (this.defaultOutputElement !== "" && !isEmpty(outputElement)) { var dialogDiv = document.createElement("div"); dialogDiv.className = "YoastSEO_msg"; dialogDiv.id = "YoastSEO-plugin-loading"; document.getElementById(this.defaultOutputElement).appendChild(dialogDiv); } }; App.prototype.updateLoadingDialog = function (plugins) {
            var outputElement = document.getElementById(this.defaultOutputElement); if (this.defaultOutputElement === "" || isEmpty(outputElement)) { return; }
            var dialog = document.getElementById("YoastSEO-plugin-loading"); dialog.textContent = ""; forEach(plugins, function (plugin, pluginName) { dialog.innerHTML += "<span class=left>" + pluginName + "</span><span class=right " + plugin.status + ">" + plugin.status + "</span><br />"; }); dialog.innerHTML += "<span class=bufferbar></span>";
        }; App.prototype.removeLoadingDialog = function () { var outputElement = document.getElementById(this.defaultOutputElement); var loadingDialog = document.getElementById("YoastSEO-plugin-loading"); if (this.defaultOutputElement !== "" && !isEmpty(outputElement) && !isEmpty(loadingDialog)) { document.getElementById(this.defaultOutputElement).removeChild(document.getElementById("YoastSEO-plugin-loading")); } }; App.prototype.registerPlugin = function (pluginName, options) { return this.pluggable._registerPlugin(pluginName, options); }; App.prototype.pluginReady = function (pluginName) { return this.pluggable._ready(pluginName); }; App.prototype.pluginReloaded = function (pluginName) { return this.pluggable._reloaded(pluginName); }; App.prototype.registerModification = function (modification, callable, pluginName, priority) { return this.pluggable._registerModification(modification, callable, pluginName, priority); }; App.prototype.registerAssessment = function (name, assessment, pluginName) { if (!isUndefined(this.seoAssessor)) { return this.pluggable._registerAssessment(this.defaultSeoAssessor, name, assessment, pluginName) && this.pluggable._registerAssessment(this.cornerStoneSeoAssessor, name, assessment, pluginName); } }; App.prototype.disableMarkers = function () {
            if (!isUndefined(this.seoAssessorPresenter)) { this.seoAssessorPresenter.disableMarker(); }
            if (!isUndefined(this.contentAssessorPresenter)) { this.contentAssessorPresenter.disableMarker(); }
        }; App.prototype._renderAnalysisResults = function () {
            if (this.config.contentAnalysisActive && !isUndefined(this.contentAssessorPresenter)) { this.contentAssessorPresenter.renderIndividualRatings(); }
            if (this.config.keywordAnalysisActive && !isUndefined(this.seoAssessorPresenter)) { this.seoAssessorPresenter.setKeyword(this.paper.getKeyword()); this.seoAssessorPresenter.render(); }
        }; App.prototype.analyzeTimer = function () { this.refresh(); }; App.prototype.registerTest = function () { console.error("This function is deprecated, please use registerAssessment"); }; App.prototype.createSnippetPreview = function () { this.snippetPreview = createDefaultSnippetPreview.call(this); this.initSnippetPreview(); }; module.exports = App;
    }), (function (module, exports, __webpack_require__) { "use strict"; var analyzerConfig = { queue: ["wordCount", "keywordDensity", "subHeadings", "stopwords", "fleschReading", "linkCount", "imageCount", "urlKeyword", "urlLength", "metaDescriptionLength", "metaDescriptionKeyword", "pageTitleKeyword", "pageTitleLength", "firstParagraph", "urlStopwords", "keywordDoubles", "keyphraseSizeCheck"], stopWords: ["a", "about", "above", "after", "again", "against", "all", "am", "an", "and", "any", "are", "as", "at", "be", "because", "been", "before", "being", "below", "between", "both", "but", "by", "could", "did", "do", "does", "doing", "down", "during", "each", "few", "for", "from", "further", "had", "has", "have", "having", "he", "he'd", "he'll", "he's", "her", "here", "here's", "hers", "herself", "him", "himself", "his", "how", "how's", "i", "i'd", "i'll", "i'm", "i've", "if", "in", "into", "is", "it", "it's", "its", "itself", "let's", "me", "more", "most", "my", "myself", "nor", "of", "on", "once", "only", "or", "other", "ought", "our", "ours", "ourselves", "out", "over", "own", "same", "she", "she'd", "she'll", "she's", "should", "so", "some", "such", "than", "that", "that's", "the", "their", "theirs", "them", "themselves", "then", "there", "there's", "these", "they", "they'd", "they'll", "they're", "they've", "this", "those", "through", "to", "too", "under", "until", "up", "very", "was", "we", "we'd", "we'll", "we're", "we've", "were", "what", "what's", "when", "when's", "where", "where's", "which", "while", "who", "who's", "whom", "why", "why's", "with", "would", "you", "you'd", "you'll", "you're", "you've", "your", "yours", "yourself", "yourselves"], wordsToRemove: [" a", " in", " an", " on", " for", " the", " and"], maxSlugLength: 20, maxUrlLength: 40, maxMeta: 156 }; module.exports = analyzerConfig; }), (function (module, exports, __webpack_require__) {
        var isObjectLike = __webpack_require__(13), isPlainObject = __webpack_require__(157); function isElement(value) { return isObjectLike(value) && value.nodeType === 1 && !isPlainObject(value); }
        module.exports = isElement;
    }), (function (module, exports, __webpack_require__) {
        var baseClone = __webpack_require__(458); var CLONE_SYMBOLS_FLAG = 4; function clone(value) { return baseClone(value, CLONE_SYMBOLS_FLAG); }
        module.exports = clone;
    }), (function (module, exports, __webpack_require__) {
        var Stack = __webpack_require__(58), arrayEach = __webpack_require__(146), assignValue = __webpack_require__(98), baseAssign = __webpack_require__(459), baseAssignIn = __webpack_require__(460), cloneBuffer = __webpack_require__(153), copyArray = __webpack_require__(155), copySymbols = __webpack_require__(461), copySymbolsIn = __webpack_require__(462), getAllKeys = __webpack_require__(133), getAllKeysIn = __webpack_require__(463), getTag = __webpack_require__(88), initCloneArray = __webpack_require__(464), initCloneByTag = __webpack_require__(465), initCloneObject = __webpack_require__(156), isArray = __webpack_require__(4), isBuffer = __webpack_require__(44), isObject = __webpack_require__(5), keys = __webpack_require__(26); var CLONE_DEEP_FLAG = 1, CLONE_FLAT_FLAG = 2, CLONE_SYMBOLS_FLAG = 4; var argsTag = '[object Arguments]', arrayTag = '[object Array]', boolTag = '[object Boolean]', dateTag = '[object Date]', errorTag = '[object Error]', funcTag = '[object Function]', genTag = '[object GeneratorFunction]', mapTag = '[object Map]', numberTag = '[object Number]', objectTag = '[object Object]', regexpTag = '[object RegExp]', setTag = '[object Set]', stringTag = '[object String]', symbolTag = '[object Symbol]', weakMapTag = '[object WeakMap]'; var arrayBufferTag = '[object ArrayBuffer]', dataViewTag = '[object DataView]', float32Tag = '[object Float32Array]', float64Tag = '[object Float64Array]', int8Tag = '[object Int8Array]', int16Tag = '[object Int16Array]', int32Tag = '[object Int32Array]', uint8Tag = '[object Uint8Array]', uint8ClampedTag = '[object Uint8ClampedArray]', uint16Tag = '[object Uint16Array]', uint32Tag = '[object Uint32Array]'; var cloneableTags = {}; cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true; cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false; function baseClone(value, bitmask, customizer, key, object, stack) {
            var result, isDeep = bitmask & CLONE_DEEP_FLAG, isFlat = bitmask & CLONE_FLAT_FLAG, isFull = bitmask & CLONE_SYMBOLS_FLAG; if (customizer) { result = object ? customizer(value, key, object, stack) : customizer(value); }
            if (result !== undefined) { return result; }
            if (!isObject(value)) { return value; }
            var isArr = isArray(value); if (isArr) { result = initCloneArray(value); if (!isDeep) { return copyArray(value, result); } } else {
                var tag = getTag(value), isFunc = tag == funcTag || tag == genTag; if (isBuffer(value)) { return cloneBuffer(value, isDeep); }
                if (tag == objectTag || tag == argsTag || (isFunc && !object)) { result = (isFlat || isFunc) ? {} : initCloneObject(value); if (!isDeep) { return isFlat ? copySymbolsIn(value, baseAssignIn(result, value)) : copySymbols(value, baseAssign(result, value)); } } else {
                    if (!cloneableTags[tag]) { return object ? value : {}; }
                    result = initCloneByTag(value, tag, baseClone, isDeep);
                }
            }
            stack || (stack = new Stack); var stacked = stack.get(value); if (stacked) { return stacked; }
            stack.set(value, result); var keysFunc = isFull ? (isFlat ? getAllKeysIn : getAllKeys) : (isFlat ? keysIn : keys); var props = isArr ? undefined : keysFunc(value); arrayEach(props || value, function (subValue, key) {
                if (props) { key = subValue; subValue = value[key]; }
                assignValue(result, key, baseClone(subValue, bitmask, customizer, key, value, stack));
            }); return result;
        }
        module.exports = baseClone;
    }), (function (module, exports, __webpack_require__) {
        var copyObject = __webpack_require__(38), keys = __webpack_require__(26); function baseAssign(object, source) { return object && copyObject(source, keys(source), object); }
        module.exports = baseAssign;
    }), (function (module, exports, __webpack_require__) {
        var copyObject = __webpack_require__(38), keysIn = __webpack_require__(49); function baseAssignIn(object, source) { return object && copyObject(source, keysIn(source), object); }
        module.exports = baseAssignIn;
    }), (function (module, exports, __webpack_require__) {
        var copyObject = __webpack_require__(38), getSymbols = __webpack_require__(85); function copySymbols(source, object) { return copyObject(source, getSymbols(source), object); }
        module.exports = copySymbols;
    }), (function (module, exports, __webpack_require__) {
        var copyObject = __webpack_require__(38), getSymbolsIn = __webpack_require__(222); function copySymbolsIn(source, object) { return copyObject(source, getSymbolsIn(source), object); }
        module.exports = copySymbolsIn;
    }), (function (module, exports, __webpack_require__) {
        var baseGetAllKeys = __webpack_require__(134), getSymbolsIn = __webpack_require__(222), keysIn = __webpack_require__(49); function getAllKeysIn(object) { return baseGetAllKeys(object, keysIn, getSymbolsIn); }
        module.exports = getAllKeysIn;
    }), (function (module, exports) {
        var objectProto = Object.prototype; var hasOwnProperty = objectProto.hasOwnProperty; function initCloneArray(array) {
            var length = array.length, result = array.constructor(length); if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) { result.index = array.index; result.input = array.input; }
            return result;
        }
        module.exports = initCloneArray;
    }), (function (module, exports, __webpack_require__) {
        var cloneArrayBuffer = __webpack_require__(95), cloneDataView = __webpack_require__(466), cloneMap = __webpack_require__(467), cloneRegExp = __webpack_require__(469), cloneSet = __webpack_require__(470), cloneSymbol = __webpack_require__(472), cloneTypedArray = __webpack_require__(154); var boolTag = '[object Boolean]', dateTag = '[object Date]', mapTag = '[object Map]', numberTag = '[object Number]', regexpTag = '[object RegExp]', setTag = '[object Set]', stringTag = '[object String]', symbolTag = '[object Symbol]'; var arrayBufferTag = '[object ArrayBuffer]', dataViewTag = '[object DataView]', float32Tag = '[object Float32Array]', float64Tag = '[object Float64Array]', int8Tag = '[object Int8Array]', int16Tag = '[object Int16Array]', int32Tag = '[object Int32Array]', uint8Tag = '[object Uint8Array]', uint8ClampedTag = '[object Uint8ClampedArray]', uint16Tag = '[object Uint16Array]', uint32Tag = '[object Uint32Array]'; function initCloneByTag(object, tag, cloneFunc, isDeep) { var Ctor = object.constructor; switch (tag) { case arrayBufferTag: return cloneArrayBuffer(object); case boolTag: case dateTag: return new Ctor(+object); case dataViewTag: return cloneDataView(object, isDeep); case float32Tag: case float64Tag: case int8Tag: case int16Tag: case int32Tag: case uint8Tag: case uint8ClampedTag: case uint16Tag: case uint32Tag: return cloneTypedArray(object, isDeep); case mapTag: return cloneMap(object, isDeep, cloneFunc); case numberTag: case stringTag: return new Ctor(object); case regexpTag: return cloneRegExp(object); case setTag: return cloneSet(object, isDeep, cloneFunc); case symbolTag: return cloneSymbol(object); } }
        module.exports = initCloneByTag;
    }), (function (module, exports, __webpack_require__) {
        var cloneArrayBuffer = __webpack_require__(95); function cloneDataView(dataView, isDeep) { var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer; return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength); }
        module.exports = cloneDataView;
    }), (function (module, exports, __webpack_require__) {
        var addMapEntry = __webpack_require__(468), arrayReduce = __webpack_require__(118), mapToArray = __webpack_require__(132); var CLONE_DEEP_FLAG = 1; function cloneMap(map, isDeep, cloneFunc) { var array = isDeep ? cloneFunc(mapToArray(map), CLONE_DEEP_FLAG) : mapToArray(map); return arrayReduce(array, addMapEntry, new map.constructor); }
        module.exports = cloneMap;
    }), (function (module, exports) {
        function addMapEntry(map, pair) { map.set(pair[0], pair[1]); return map; }
        module.exports = addMapEntry;
    }), (function (module, exports) {
        var reFlags = /\w*$/; function cloneRegExp(regexp) { var result = new regexp.constructor(regexp.source, reFlags.exec(regexp)); result.lastIndex = regexp.lastIndex; return result; }
        module.exports = cloneRegExp;
    }), (function (module, exports, __webpack_require__) {
        var addSetEntry = __webpack_require__(471), arrayReduce = __webpack_require__(118), setToArray = __webpack_require__(66); var CLONE_DEEP_FLAG = 1; function cloneSet(set, isDeep, cloneFunc) { var array = isDeep ? cloneFunc(setToArray(set), CLONE_DEEP_FLAG) : setToArray(set); return arrayReduce(array, addSetEntry, new set.constructor); }
        module.exports = cloneSet;
    }), (function (module, exports) {
        function addSetEntry(set, value) { set.add(value); return set; }
        module.exports = addSetEntry;
    }), (function (module, exports, __webpack_require__) {
        var Symbol = __webpack_require__(34); var symbolProto = Symbol ? Symbol.prototype : undefined, symbolValueOf = symbolProto ? symbolProto.valueOf : undefined; function cloneSymbol(symbol) { return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {}; }
        module.exports = cloneSymbol;
    }), (function (module, exports, __webpack_require__) { var root = __webpack_require__(9); var now = function () { return root.Date.now(); }; module.exports = now; }), (function (module, exports, __webpack_require__) { "use strict"; var forEach = __webpack_require__(1); var domManipulation = __webpack_require__(224); var previewModes = { desktop: "snippet-editor__view--desktop", mobile: "snippet-editor__view--mobile" }; var minimumDesktopWidth = 640; var SnippetPreviewToggler = function SnippetPreviewToggler(previewMode, previewToggles) { this.previewMode = previewMode; this.previewToggles = previewToggles; this.viewElement = document.getElementById("snippet-preview-view"); }; SnippetPreviewToggler.prototype.initialize = function () { this._setPreviewMode(this.previewMode, this._findElementByMode(this.previewMode)); }; SnippetPreviewToggler.prototype.bindClickEvent = function (previewToggle) { previewToggle.addEventListener("click", function () { this._setPreviewMode(previewToggle.getAttribute("data-type"), previewToggle); this.removeTooltipAbility(previewToggle); }.bind(this)); }; SnippetPreviewToggler.prototype.bindMouseleaveEvent = function (previewToggle) { previewToggle.addEventListener("mouseleave", function () { this.removeTooltipAbility(previewToggle); }.bind(this)); }; SnippetPreviewToggler.prototype.bindBlurEvent = function (previewToggle) { previewToggle.addEventListener("blur", function () { this.restoreTooltipAbility(previewToggle); }.bind(this)); }; SnippetPreviewToggler.prototype.bindMouseenterEvent = function (previewToggle) { previewToggle.addEventListener("mouseenter", function () { this.restoreTooltipAbility(previewToggle); }.bind(this)); }; SnippetPreviewToggler.prototype.bindEvents = function () { forEach(this.previewToggles, function (previewToggle) { this.bindClickEvent(previewToggle); this.bindMouseleaveEvent(previewToggle); this.bindBlurEvent(previewToggle); this.bindMouseenterEvent(previewToggle); }.bind(this)); }; SnippetPreviewToggler.prototype._findElementByMode = function (previewMode) { return document.getElementsByClassName("snippet-editor__view-icon-" + previewMode)[0]; }; SnippetPreviewToggler.prototype._setPreviewMode = function (previewMode, toggleElement) { this._removeActiveStates(); this._setActiveState(toggleElement); domManipulation.removeClass(this.viewElement, previewModes[this.previewMode]); domManipulation.addClass(this.viewElement, previewModes[previewMode]); this.previewMode = previewMode; }; SnippetPreviewToggler.prototype.setDesktopMode = function () { this._setPreviewMode("desktop", this._findElementByMode("desktop")); }; SnippetPreviewToggler.prototype.setMobileMode = function () { this._setPreviewMode("mobile", this._findElementByMode("mobile")); }; SnippetPreviewToggler.prototype.setVisibility = function (previewWidth) { if (previewWidth < minimumDesktopWidth) { this.setMobileMode(); domManipulation.addClass(this.viewElement, "snippet-editor__view--desktop-has-scroll"); } else { this.setDesktopMode(); } }; SnippetPreviewToggler.prototype.setScrollHintVisibility = function (previewWidth) { domManipulation.removeClass(this.viewElement, "snippet-editor__view--desktop-has-scroll"); if (previewWidth < minimumDesktopWidth) { domManipulation.addClass(this.viewElement, "snippet-editor__view--desktop-has-scroll"); } }; SnippetPreviewToggler.prototype._removeActiveStates = function () { forEach(this.previewToggles, this._removeActiveState.bind(this)); }; SnippetPreviewToggler.prototype._removeActiveState = function (previewToggle) { domManipulation.removeClass(previewToggle, "snippet-editor__view-icon-" + previewToggle.getAttribute("data-type") + "--active"); domManipulation.removeClass(previewToggle, "snippet-editor__view-icon--active"); previewToggle.setAttribute("aria-pressed", "false"); }; SnippetPreviewToggler.prototype.removeTooltipAbility = function (previewToggle) { domManipulation.addClass(previewToggle, "yoast-tooltip-hidden"); }; SnippetPreviewToggler.prototype.restoreTooltipAbility = function (previewToggle) { domManipulation.removeClass(previewToggle, "yoast-tooltip-hidden"); }; SnippetPreviewToggler.prototype._setActiveState = function (elementToActivate) { domManipulation.addClass(elementToActivate, "snippet-editor__view-icon-" + elementToActivate.getAttribute("data-type") + "--active"); domManipulation.addClass(elementToActivate, "snippet-editor__view-icon--active"); elementToActivate.setAttribute("aria-pressed", "true"); }; module.exports = SnippetPreviewToggler; }), (function (module, exports, __webpack_require__) {
        var debounce = __webpack_require__(119), isObject = __webpack_require__(5); var FUNC_ERROR_TEXT = 'Expected a function'; function throttle(func, wait, options) {
            var leading = true, trailing = true; if (typeof func != 'function') { throw new TypeError(FUNC_ERROR_TEXT); }
            if (isObject(options)) { leading = 'leading' in options ? !!options.leading : leading; trailing = 'trailing' in options ? !!options.trailing : trailing; }
            return debounce(func, wait, { 'leading': leading, 'maxWait': wait, 'trailing': trailing });
        }
        module.exports = throttle;
    }), (function (module, exports, __webpack_require__) {
        (function (root, undef) {
            var ArrayProto = Array.prototype, ObjProto = Object.prototype, slice = ArrayProto.slice, hasOwnProp = ObjProto.hasOwnProperty, nativeForEach = ArrayProto.forEach, breaker = {}; var _ = {
                forEach: function (obj, iterator, context) {
                    var i, l, key; if (obj === null) { return; }
                    if (nativeForEach && obj.forEach === nativeForEach) { obj.forEach(iterator, context); }
                    else if (obj.length === +obj.length) { for (i = 0, l = obj.length; i < l; i++) { if (i in obj && iterator.call(context, obj[i], i, obj) === breaker) { return; } } }
                    else { for (key in obj) { if (hasOwnProp.call(obj, key)) { if (iterator.call(context, obj[key], key, obj) === breaker) { return; } } } }
                }, extend: function (obj) { this.forEach(slice.call(arguments, 1), function (source) { for (var prop in source) { obj[prop] = source[prop]; } }); return obj; }
            }; var Jed = function (options) { this.defaults = { "locale_data": { "messages": { "": { "domain": "messages", "lang": "en", "plural_forms": "nplurals=2; plural=(n != 1);" } } }, "domain": "messages", "debug": false }; this.options = _.extend({}, this.defaults, options); this.textdomain(this.options.domain); if (options.domain && !this.options.locale_data[this.options.domain]) { throw new Error('Text domain set to non-existent domain: `' + options.domain + '`'); } }; Jed.context_delimiter = String.fromCharCode(4); function getPluralFormFunc(plural_form_string) { return Jed.PF.compile(plural_form_string || "nplurals=2; plural=(n != 1);"); }
            function Chain(key, i18n) { this._key = key; this._i18n = i18n; }
            _.extend(Chain.prototype, {
                onDomain: function (domain) { this._domain = domain; return this; }, withContext: function (context) { this._context = context; return this; }, ifPlural: function (num, pkey) { this._val = num; this._pkey = pkey; return this; }, fetch: function (sArr) {
                    if ({}.toString.call(sArr) != '[object Array]') { sArr = [].slice.call(arguments, 0); }
                    return (sArr && sArr.length ? Jed.sprintf : function (x) { return x; })(this._i18n.dcnpgettext(this._domain, this._context, this._key, this._pkey, this._val), sArr);
                }
            }); _.extend(Jed.prototype, {
                translate: function (key) { return new Chain(key, this); }, textdomain: function (domain) {
                    if (!domain) { return this._textdomain; }
                    this._textdomain = domain;
                }, gettext: function (key) { return this.dcnpgettext.call(this, undef, undef, key); }, dgettext: function (domain, key) { return this.dcnpgettext.call(this, domain, undef, key); }, dcgettext: function (domain, key) { return this.dcnpgettext.call(this, domain, undef, key); }, ngettext: function (skey, pkey, val) { return this.dcnpgettext.call(this, undef, undef, skey, pkey, val); }, dngettext: function (domain, skey, pkey, val) { return this.dcnpgettext.call(this, domain, undef, skey, pkey, val); }, dcngettext: function (domain, skey, pkey, val) { return this.dcnpgettext.call(this, domain, undef, skey, pkey, val); }, pgettext: function (context, key) { return this.dcnpgettext.call(this, undef, context, key); }, dpgettext: function (domain, context, key) { return this.dcnpgettext.call(this, domain, context, key); }, dcpgettext: function (domain, context, key) { return this.dcnpgettext.call(this, domain, context, key); }, npgettext: function (context, skey, pkey, val) { return this.dcnpgettext.call(this, undef, context, skey, pkey, val); }, dnpgettext: function (domain, context, skey, pkey, val) { return this.dcnpgettext.call(this, domain, context, skey, pkey, val); }, dcnpgettext: function (domain, context, singular_key, plural_key, val) {
                    plural_key = plural_key || singular_key; domain = domain || this._textdomain; var fallback; if (!this.options) { fallback = new Jed(); return fallback.dcnpgettext.call(fallback, undefined, undefined, singular_key, plural_key, val); }
                    if (!this.options.locale_data) { throw new Error('No locale data provided.'); }
                    if (!this.options.locale_data[domain]) { throw new Error('Domain `' + domain + '` was not found.'); }
                    if (!this.options.locale_data[domain][""]) { throw new Error('No locale meta information provided.'); }
                    if (!singular_key) { throw new Error('No translation key found.'); }
                    var key = context ? context + Jed.context_delimiter + singular_key : singular_key, locale_data = this.options.locale_data, dict = locale_data[domain], defaultConf = (locale_data.messages || this.defaults.locale_data.messages)[""], pluralForms = dict[""].plural_forms || dict[""]["Plural-Forms"] || dict[""]["plural-forms"] || defaultConf.plural_forms || defaultConf["Plural-Forms"] || defaultConf["plural-forms"], val_list, res; var val_idx; if (val === undefined) { val_idx = 0; } else {
                        if (typeof val != 'number') { val = parseInt(val, 10); if (isNaN(val)) { throw new Error('The number that was passed in is not a number.'); } }
                        val_idx = getPluralFormFunc(pluralForms)(val);
                    }
                    if (!dict) { throw new Error('No domain named `' + domain + '` could be found.'); }
                    val_list = dict[key]; if (!val_list || val_idx > val_list.length) {
                        if (this.options.missing_key_callback) { this.options.missing_key_callback(key, domain); }
                        res = [singular_key, plural_key]; if (this.options.debug === true) { console.log(res[getPluralFormFunc(pluralForms)(val)]); }
                        return res[getPluralFormFunc()(val)];
                    }
                    res = val_list[val_idx]; if (!res) { res = [singular_key, plural_key]; return res[getPluralFormFunc()(val)]; }
                    return res;
                }
            }); var sprintf = (function () {
                function get_type(variable) { return Object.prototype.toString.call(variable).slice(8, -1).toLowerCase(); }
                function str_repeat(input, multiplier) {
                    for (var output = []; multiplier > 0; output[--multiplier] = input) { }
                    return output.join('');
                }
                var str_format = function () {
                    if (!str_format.cache.hasOwnProperty(arguments[0])) { str_format.cache[arguments[0]] = str_format.parse(arguments[0]); }
                    return str_format.format.call(null, str_format.cache[arguments[0]], arguments);
                }; str_format.format = function (parse_tree, argv) {
                    var cursor = 1, tree_length = parse_tree.length, node_type = '', arg, output = [], i, k, match, pad, pad_character, pad_length; for (i = 0; i < tree_length; i++) {
                        node_type = get_type(parse_tree[i]); if (node_type === 'string') { output.push(parse_tree[i]); }
                        else if (node_type === 'array') {
                            match = parse_tree[i]; if (match[2]) {
                                arg = argv[cursor]; for (k = 0; k < match[2].length; k++) {
                                    if (!arg.hasOwnProperty(match[2][k])) { throw (sprintf('[sprintf] property "%s" does not exist', match[2][k])); }
                                    arg = arg[match[2][k]];
                                }
                            }
                            else if (match[1]) { arg = argv[match[1]]; }
                            else { arg = argv[cursor++]; }
                            if (/[^s]/.test(match[8]) && (get_type(arg) != 'number')) { throw (sprintf('[sprintf] expecting number but found %s', get_type(arg))); }
                            if (typeof arg == 'undefined' || arg === null) { arg = ''; }
                            switch (match[8]) { case 'b': arg = arg.toString(2); break; case 'c': arg = String.fromCharCode(arg); break; case 'd': arg = parseInt(arg, 10); break; case 'e': arg = match[7] ? arg.toExponential(match[7]) : arg.toExponential(); break; case 'f': arg = match[7] ? parseFloat(arg).toFixed(match[7]) : parseFloat(arg); break; case 'o': arg = arg.toString(8); break; case 's': arg = ((arg = String(arg)) && match[7] ? arg.substring(0, match[7]) : arg); break; case 'u': arg = Math.abs(arg); break; case 'x': arg = arg.toString(16); break; case 'X': arg = arg.toString(16).toUpperCase(); break; }
                            arg = (/[def]/.test(match[8]) && match[3] && arg >= 0 ? '+' + arg : arg); pad_character = match[4] ? match[4] == '0' ? '0' : match[4].charAt(1) : ' '; pad_length = match[6] - String(arg).length; pad = match[6] ? str_repeat(pad_character, pad_length) : ''; output.push(match[5] ? arg + pad : pad + arg);
                        }
                    }
                    return output.join('');
                }; str_format.cache = {}; str_format.parse = function (fmt) {
                    var _fmt = fmt, match = [], parse_tree = [], arg_names = 0; while (_fmt) {
                        if ((match = /^[^\x25]+/.exec(_fmt)) !== null) { parse_tree.push(match[0]); }
                        else if ((match = /^\x25{2}/.exec(_fmt)) !== null) { parse_tree.push('%'); }
                        else if ((match = /^\x25(?:([1-9]\d*)\$|\(([^\)]+)\))?(\+)?(0|'[^$])?(-)?(\d+)?(?:\.(\d+))?([b-fosuxX])/.exec(_fmt)) !== null) {
                            if (match[2]) {
                                arg_names |= 1; var field_list = [], replacement_field = match[2], field_match = []; if ((field_match = /^([a-z_][a-z_\d]*)/i.exec(replacement_field)) !== null) {
                                    field_list.push(field_match[1]); while ((replacement_field = replacement_field.substring(field_match[0].length)) !== '') {
                                        if ((field_match = /^\.([a-z_][a-z_\d]*)/i.exec(replacement_field)) !== null) { field_list.push(field_match[1]); }
                                        else if ((field_match = /^\[(\d+)\]/.exec(replacement_field)) !== null) { field_list.push(field_match[1]); }
                                        else { throw ('[sprintf] huh?'); }
                                    }
                                }
                                else { throw ('[sprintf] huh?'); }
                                match[2] = field_list;
                            }
                            else { arg_names |= 2; }
                            if (arg_names === 3) { throw ('[sprintf] mixing positional and named placeholders is not (yet) supported'); }
                            parse_tree.push(match);
                        }
                        else { throw ('[sprintf] huh?'); }
                        _fmt = _fmt.substring(match[0].length);
                    }
                    return parse_tree;
                }; return str_format;
            })(); var vsprintf = function (fmt, argv) { argv.unshift(fmt); return sprintf.apply(null, argv); }; Jed.parse_plural = function (plural_forms, n) { plural_forms = plural_forms.replace(/n/g, n); return Jed.parse_expression(plural_forms); }; Jed.sprintf = function (fmt, args) {
                if ({}.toString.call(args) == '[object Array]') { return vsprintf(fmt, [].slice.call(args)); }
                return sprintf.apply(this, [].slice.call(arguments));
            }; Jed.prototype.sprintf = function () { return Jed.sprintf.apply(this, arguments); }; Jed.PF = {}; Jed.PF.parse = function (p) { var plural_str = Jed.PF.extractPluralExpr(p); return Jed.PF.parser.parse.call(Jed.PF.parser, plural_str); }; Jed.PF.compile = function (p) {
                function imply(val) { return (val === true ? 1 : val ? val : 0); }
                var ast = Jed.PF.parse(p); return function (n) { return imply(Jed.PF.interpreter(ast)(n)); };
            }; Jed.PF.interpreter = function (ast) {
                return function (n) {
                    var res; switch (ast.type) {
                        case 'GROUP': return Jed.PF.interpreter(ast.expr)(n); case 'TERNARY': if (Jed.PF.interpreter(ast.expr)(n)) { return Jed.PF.interpreter(ast.truthy)(n); }
                            return Jed.PF.interpreter(ast.falsey)(n); case 'OR': return Jed.PF.interpreter(ast.left)(n) || Jed.PF.interpreter(ast.right)(n); case 'AND': return Jed.PF.interpreter(ast.left)(n) && Jed.PF.interpreter(ast.right)(n); case 'LT': return Jed.PF.interpreter(ast.left)(n) < Jed.PF.interpreter(ast.right)(n); case 'GT': return Jed.PF.interpreter(ast.left)(n) > Jed.PF.interpreter(ast.right)(n); case 'LTE': return Jed.PF.interpreter(ast.left)(n) <= Jed.PF.interpreter(ast.right)(n); case 'GTE': return Jed.PF.interpreter(ast.left)(n) >= Jed.PF.interpreter(ast.right)(n); case 'EQ': return Jed.PF.interpreter(ast.left)(n) == Jed.PF.interpreter(ast.right)(n); case 'NEQ': return Jed.PF.interpreter(ast.left)(n) != Jed.PF.interpreter(ast.right)(n); case 'MOD': return Jed.PF.interpreter(ast.left)(n) % Jed.PF.interpreter(ast.right)(n); case 'VAR': return n; case 'NUM': return ast.val; default: throw new Error("Invalid Token found.");
                    }
                };
            }; Jed.PF.extractPluralExpr = function (p) {
                p = p.replace(/^\s\s*/, '').replace(/\s\s*$/, ''); if (!/;\s*$/.test(p)) { p = p.concat(';'); }
                var nplurals_re = /nplurals\=(\d+);/, plural_re = /plural\=(.*);/, nplurals_matches = p.match(nplurals_re), res = {}, plural_matches; if (nplurals_matches.length > 1) { res.nplurals = nplurals_matches[1]; }
                else { throw new Error('nplurals not found in plural_forms string: ' + p); }
                p = p.replace(nplurals_re, ""); plural_matches = p.match(plural_re); if (!(plural_matches && plural_matches.length > 1)) { throw new Error('`plural` expression not found: ' + p); }
                return plural_matches[1];
            }; Jed.PF.parser = (function () {
                var parser = {
                    trace: function trace() { }, yy: {}, symbols_: { "error": 2, "expressions": 3, "e": 4, "EOF": 5, "?": 6, ":": 7, "||": 8, "&&": 9, "<": 10, "<=": 11, ">": 12, ">=": 13, "!=": 14, "==": 15, "%": 16, "(": 17, ")": 18, "n": 19, "NUMBER": 20, "$accept": 0, "$end": 1 }, terminals_: { 2: "error", 5: "EOF", 6: "?", 7: ":", 8: "||", 9: "&&", 10: "<", 11: "<=", 12: ">", 13: ">=", 14: "!=", 15: "==", 16: "%", 17: "(", 18: ")", 19: "n", 20: "NUMBER" }, productions_: [0, [3, 2], [4, 5], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 1], [4, 1]], performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate, $$, _$) { var $0 = $$.length - 1; switch (yystate) { case 1: return { type: 'GROUP', expr: $$[$0 - 1] }; break; case 2: this.$ = { type: 'TERNARY', expr: $$[$0 - 4], truthy: $$[$0 - 2], falsey: $$[$0] }; break; case 3: this.$ = { type: "OR", left: $$[$0 - 2], right: $$[$0] }; break; case 4: this.$ = { type: "AND", left: $$[$0 - 2], right: $$[$0] }; break; case 5: this.$ = { type: 'LT', left: $$[$0 - 2], right: $$[$0] }; break; case 6: this.$ = { type: 'LTE', left: $$[$0 - 2], right: $$[$0] }; break; case 7: this.$ = { type: 'GT', left: $$[$0 - 2], right: $$[$0] }; break; case 8: this.$ = { type: 'GTE', left: $$[$0 - 2], right: $$[$0] }; break; case 9: this.$ = { type: 'NEQ', left: $$[$0 - 2], right: $$[$0] }; break; case 10: this.$ = { type: 'EQ', left: $$[$0 - 2], right: $$[$0] }; break; case 11: this.$ = { type: 'MOD', left: $$[$0 - 2], right: $$[$0] }; break; case 12: this.$ = { type: 'GROUP', expr: $$[$0 - 1] }; break; case 13: this.$ = { type: 'VAR' }; break; case 14: this.$ = { type: 'NUM', val: Number(yytext) }; break; } }, table: [{ 3: 1, 4: 2, 17: [1, 3], 19: [1, 4], 20: [1, 5] }, { 1: [3] }, { 5: [1, 6], 6: [1, 7], 8: [1, 8], 9: [1, 9], 10: [1, 10], 11: [1, 11], 12: [1, 12], 13: [1, 13], 14: [1, 14], 15: [1, 15], 16: [1, 16] }, { 4: 17, 17: [1, 3], 19: [1, 4], 20: [1, 5] }, { 5: [2, 13], 6: [2, 13], 7: [2, 13], 8: [2, 13], 9: [2, 13], 10: [2, 13], 11: [2, 13], 12: [2, 13], 13: [2, 13], 14: [2, 13], 15: [2, 13], 16: [2, 13], 18: [2, 13] }, { 5: [2, 14], 6: [2, 14], 7: [2, 14], 8: [2, 14], 9: [2, 14], 10: [2, 14], 11: [2, 14], 12: [2, 14], 13: [2, 14], 14: [2, 14], 15: [2, 14], 16: [2, 14], 18: [2, 14] }, { 1: [2, 1] }, { 4: 18, 17: [1, 3], 19: [1, 4], 20: [1, 5] }, { 4: 19, 17: [1, 3], 19: [1, 4], 20: [1, 5] }, { 4: 20, 17: [1, 3], 19: [1, 4], 20: [1, 5] }, { 4: 21, 17: [1, 3], 19: [1, 4], 20: [1, 5] }, { 4: 22, 17: [1, 3], 19: [1, 4], 20: [1, 5] }, { 4: 23, 17: [1, 3], 19: [1, 4], 20: [1, 5] }, { 4: 24, 17: [1, 3], 19: [1, 4], 20: [1, 5] }, { 4: 25, 17: [1, 3], 19: [1, 4], 20: [1, 5] }, { 4: 26, 17: [1, 3], 19: [1, 4], 20: [1, 5] }, { 4: 27, 17: [1, 3], 19: [1, 4], 20: [1, 5] }, { 6: [1, 7], 8: [1, 8], 9: [1, 9], 10: [1, 10], 11: [1, 11], 12: [1, 12], 13: [1, 13], 14: [1, 14], 15: [1, 15], 16: [1, 16], 18: [1, 28] }, { 6: [1, 7], 7: [1, 29], 8: [1, 8], 9: [1, 9], 10: [1, 10], 11: [1, 11], 12: [1, 12], 13: [1, 13], 14: [1, 14], 15: [1, 15], 16: [1, 16] }, { 5: [2, 3], 6: [2, 3], 7: [2, 3], 8: [2, 3], 9: [1, 9], 10: [1, 10], 11: [1, 11], 12: [1, 12], 13: [1, 13], 14: [1, 14], 15: [1, 15], 16: [1, 16], 18: [2, 3] }, { 5: [2, 4], 6: [2, 4], 7: [2, 4], 8: [2, 4], 9: [2, 4], 10: [1, 10], 11: [1, 11], 12: [1, 12], 13: [1, 13], 14: [1, 14], 15: [1, 15], 16: [1, 16], 18: [2, 4] }, { 5: [2, 5], 6: [2, 5], 7: [2, 5], 8: [2, 5], 9: [2, 5], 10: [2, 5], 11: [2, 5], 12: [2, 5], 13: [2, 5], 14: [2, 5], 15: [2, 5], 16: [1, 16], 18: [2, 5] }, { 5: [2, 6], 6: [2, 6], 7: [2, 6], 8: [2, 6], 9: [2, 6], 10: [2, 6], 11: [2, 6], 12: [2, 6], 13: [2, 6], 14: [2, 6], 15: [2, 6], 16: [1, 16], 18: [2, 6] }, { 5: [2, 7], 6: [2, 7], 7: [2, 7], 8: [2, 7], 9: [2, 7], 10: [2, 7], 11: [2, 7], 12: [2, 7], 13: [2, 7], 14: [2, 7], 15: [2, 7], 16: [1, 16], 18: [2, 7] }, { 5: [2, 8], 6: [2, 8], 7: [2, 8], 8: [2, 8], 9: [2, 8], 10: [2, 8], 11: [2, 8], 12: [2, 8], 13: [2, 8], 14: [2, 8], 15: [2, 8], 16: [1, 16], 18: [2, 8] }, { 5: [2, 9], 6: [2, 9], 7: [2, 9], 8: [2, 9], 9: [2, 9], 10: [2, 9], 11: [2, 9], 12: [2, 9], 13: [2, 9], 14: [2, 9], 15: [2, 9], 16: [1, 16], 18: [2, 9] }, { 5: [2, 10], 6: [2, 10], 7: [2, 10], 8: [2, 10], 9: [2, 10], 10: [2, 10], 11: [2, 10], 12: [2, 10], 13: [2, 10], 14: [2, 10], 15: [2, 10], 16: [1, 16], 18: [2, 10] }, { 5: [2, 11], 6: [2, 11], 7: [2, 11], 8: [2, 11], 9: [2, 11], 10: [2, 11], 11: [2, 11], 12: [2, 11], 13: [2, 11], 14: [2, 11], 15: [2, 11], 16: [2, 11], 18: [2, 11] }, { 5: [2, 12], 6: [2, 12], 7: [2, 12], 8: [2, 12], 9: [2, 12], 10: [2, 12], 11: [2, 12], 12: [2, 12], 13: [2, 12], 14: [2, 12], 15: [2, 12], 16: [2, 12], 18: [2, 12] }, { 4: 30, 17: [1, 3], 19: [1, 4], 20: [1, 5] }, { 5: [2, 2], 6: [1, 7], 7: [2, 2], 8: [1, 8], 9: [1, 9], 10: [1, 10], 11: [1, 11], 12: [1, 12], 13: [1, 13], 14: [1, 14], 15: [1, 15], 16: [1, 16], 18: [2, 2] }], defaultActions: { 6: [2, 1] }, parseError: function parseError(str, hash) { throw new Error(str); }, parse: function parse(input) {
                        var self = this, stack = [0], vstack = [null], lstack = [], table = this.table, yytext = '', yylineno = 0, yyleng = 0, recovering = 0, TERROR = 2, EOF = 1; this.lexer.setInput(input); this.lexer.yy = this.yy; this.yy.lexer = this.lexer; if (typeof this.lexer.yylloc == 'undefined')
                            this.lexer.yylloc = {}; var yyloc = this.lexer.yylloc; lstack.push(yyloc); if (typeof this.yy.parseError === 'function')
                            this.parseError = this.yy.parseError; function popStack(n) { stack.length = stack.length - 2 * n; vstack.length = vstack.length - n; lstack.length = lstack.length - n; }
                        function lex() {
                            var token; token = self.lexer.lex() || 1; if (typeof token !== 'number') { token = self.symbols_[token] || token; }
                            return token;
                        }
                        var symbol, preErrorSymbol, state, action, a, r, yyval = {}, p, len, newState, expected; while (true) {
                            state = stack[stack.length - 1]; if (this.defaultActions[state]) { action = this.defaultActions[state]; } else {
                                if (symbol == null)
                                    symbol = lex(); action = table[state] && table[state][symbol];
                            }
                            _handle_error: if (typeof action === 'undefined' || !action.length || !action[0]) {
                                if (!recovering) {
                                    expected = []; for (p in table[state]) if (this.terminals_[p] && p > 2) { expected.push("'" + this.terminals_[p] + "'"); }
                                    var errStr = ''; if (this.lexer.showPosition) { errStr = 'Parse error on line ' + (yylineno + 1) + ":\n" + this.lexer.showPosition() + "\nExpecting " + expected.join(', ') + ", got '" + this.terminals_[symbol] + "'"; } else {
                                        errStr = 'Parse error on line ' + (yylineno + 1) + ": Unexpected " +
                                            (symbol == 1 ? "end of input" : ("'" + (this.terminals_[symbol] || symbol) + "'"));
                                    }
                                    this.parseError(errStr, { text: this.lexer.match, token: this.terminals_[symbol] || symbol, line: this.lexer.yylineno, loc: yyloc, expected: expected });
                                }
                                if (recovering == 3) {
                                    if (symbol == EOF) { throw new Error(errStr || 'Parsing halted.'); }
                                    yyleng = this.lexer.yyleng; yytext = this.lexer.yytext; yylineno = this.lexer.yylineno; yyloc = this.lexer.yylloc; symbol = lex();
                                }
                                while (1) {
                                    if ((TERROR.toString()) in table[state]) { break; }
                                    if (state == 0) { throw new Error(errStr || 'Parsing halted.'); }
                                    popStack(1); state = stack[stack.length - 1];
                                }
                                preErrorSymbol = symbol; symbol = TERROR; state = stack[stack.length - 1]; action = table[state] && table[state][TERROR]; recovering = 3;
                            }
                            if (action[0] instanceof Array && action.length > 1) { throw new Error('Parse Error: multiple actions possible at state: ' + state + ', token: ' + symbol); }
                            switch (action[0]) {
                                case 1: stack.push(symbol); vstack.push(this.lexer.yytext); lstack.push(this.lexer.yylloc); stack.push(action[1]); symbol = null; if (!preErrorSymbol) {
                                    yyleng = this.lexer.yyleng; yytext = this.lexer.yytext; yylineno = this.lexer.yylineno; yyloc = this.lexer.yylloc; if (recovering > 0)
                                        recovering--;
                                } else { symbol = preErrorSymbol; preErrorSymbol = null; }
                                    break; case 2: len = this.productions_[action[1]][1]; yyval.$ = vstack[vstack.length - len]; yyval._$ = { first_line: lstack[lstack.length - (len || 1)].first_line, last_line: lstack[lstack.length - 1].last_line, first_column: lstack[lstack.length - (len || 1)].first_column, last_column: lstack[lstack.length - 1].last_column }; r = this.performAction.call(yyval, yytext, yyleng, yylineno, this.yy, action[1], vstack, lstack); if (typeof r !== 'undefined') { return r; }
                                    if (len) { stack = stack.slice(0, -1 * len * 2); vstack = vstack.slice(0, -1 * len); lstack = lstack.slice(0, -1 * len); }
                                    stack.push(this.productions_[action[1]][0]); vstack.push(yyval.$); lstack.push(yyval._$); newState = table[stack[stack.length - 2]][stack[stack.length - 1]]; stack.push(newState); break; case 3: return true;
                            }
                        }
                        return true;
                    }
                }; var lexer = (function () {
                    var lexer = ({
                        EOF: 1, parseError: function parseError(str, hash) { if (this.yy.parseError) { this.yy.parseError(str, hash); } else { throw new Error(str); } }, setInput: function (input) { this._input = input; this._more = this._less = this.done = false; this.yylineno = this.yyleng = 0; this.yytext = this.matched = this.match = ''; this.conditionStack = ['INITIAL']; this.yylloc = { first_line: 1, first_column: 0, last_line: 1, last_column: 0 }; return this; }, input: function () { var ch = this._input[0]; this.yytext += ch; this.yyleng++; this.match += ch; this.matched += ch; var lines = ch.match(/\n/); if (lines) this.yylineno++; this._input = this._input.slice(1); return ch; }, unput: function (ch) { this._input = ch + this._input; return this; }, more: function () { this._more = true; return this; }, pastInput: function () { var past = this.matched.substr(0, this.matched.length - this.match.length); return (past.length > 20 ? '...' : '') + past.substr(-20).replace(/\n/g, ""); }, upcomingInput: function () {
                            var next = this.match; if (next.length < 20) { next += this._input.substr(0, 20 - next.length); }
                            return (next.substr(0, 20) + (next.length > 20 ? '...' : '')).replace(/\n/g, "");
                        }, showPosition: function () { var pre = this.pastInput(); var c = new Array(pre.length + 1).join("-"); return pre + this.upcomingInput() + "\n" + c + "^"; }, next: function () {
                            if (this.done) { return this.EOF; }
                            if (!this._input) this.done = true; var token, match, col, lines; if (!this._more) { this.yytext = ''; this.match = ''; }
                            var rules = this._currentRules(); for (var i = 0; i < rules.length; i++) {
                                match = this._input.match(this.rules[rules[i]]); if (match) {
                                    lines = match[0].match(/\n.*/g); if (lines) this.yylineno += lines.length; this.yylloc = { first_line: this.yylloc.last_line, last_line: this.yylineno + 1, first_column: this.yylloc.last_column, last_column: lines ? lines[lines.length - 1].length - 1 : this.yylloc.last_column + match[0].length }
                                    this.yytext += match[0]; this.match += match[0]; this.matches = match; this.yyleng = this.yytext.length; this._more = false; this._input = this._input.slice(match[0].length); this.matched += match[0]; token = this.performAction.call(this, this.yy, this, rules[i], this.conditionStack[this.conditionStack.length - 1]); if (token) return token; else return;
                                }
                            }
                            if (this._input === "") { return this.EOF; } else { this.parseError('Lexical error on line ' + (this.yylineno + 1) + '. Unrecognized text.\n' + this.showPosition(), { text: "", token: null, line: this.yylineno }); }
                        }, lex: function lex() { var r = this.next(); if (typeof r !== 'undefined') { return r; } else { return this.lex(); } }, begin: function begin(condition) { this.conditionStack.push(condition); }, popState: function popState() { return this.conditionStack.pop(); }, _currentRules: function _currentRules() { return this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules; }, topState: function () { return this.conditionStack[this.conditionStack.length - 2]; }, pushState: function begin(condition) { this.begin(condition); }
                    }); lexer.performAction = function anonymous(yy, yy_, $avoiding_name_collisions, YY_START) {
                        var YYSTATE = YY_START; switch ($avoiding_name_collisions) {
                            case 0: break; case 1: return 20
                                break; case 2: return 19
                                break; case 3: return 8
                                break; case 4: return 9
                                break; case 5: return 6
                                break; case 6: return 7
                                break; case 7: return 11
                                break; case 8: return 13
                                break; case 9: return 10
                                break; case 10: return 12
                                break; case 11: return 14
                                break; case 12: return 15
                                break; case 13: return 16
                                break; case 14: return 17
                                break; case 15: return 18
                                break; case 16: return 5
                                break; case 17: return 'INVALID'
                                break;
                        }
                    }; lexer.rules = [/^\s+/, /^[0-9]+(\.[0-9]+)?\b/, /^n\b/, /^\|\|/, /^&&/, /^\?/, /^:/, /^<=/, /^>=/, /^</, /^>/, /^!=/, /^==/, /^%/, /^\(/, /^\)/, /^$/, /^./]; lexer.conditions = { "INITIAL": { "rules": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17], "inclusive": true } }; return lexer;
                })()
                parser.lexer = lexer; return parser;
            })(); if (true) {
                if (typeof module !== 'undefined' && module.exports) { exports = module.exports = Jed; }
                exports.Jed = Jed;
            }
            else {
                if (typeof define === 'function' && define.amd) { define(function () { return Jed; }); }
                root['Jed'] = Jed;
            }
        })(this);
    }), (function (module, exports, __webpack_require__) { "use strict"; var Assessor = __webpack_require__(42); var SEOAssessor = __webpack_require__(114); var introductionKeyword = __webpack_require__(194); var keyphraseLength = __webpack_require__(195); var keywordDensity = __webpack_require__(196); var keywordStopWords = __webpack_require__(197); var metaDescriptionKeyword = __webpack_require__(198); var MetaDescriptionLength = __webpack_require__(199); var SubheadingsKeyword = __webpack_require__(200); var textCompetingLinks = __webpack_require__(201); var TextImages = __webpack_require__(202); var TextLength = __webpack_require__(203); var OutboundLinks = __webpack_require__(205); var internalLinks = __webpack_require__(206); var titleKeyword = __webpack_require__(207); var TitleWidth = __webpack_require__(208); var UrlKeyword = __webpack_require__(209); var UrlLength = __webpack_require__(210); var urlStopWords = __webpack_require__(211); var CornerstoneSEOAssessor = function CornerstoneSEOAssessor(i18n, options) { Assessor.call(this, i18n, options); this._assessments = [introductionKeyword, keyphraseLength, keywordDensity, keywordStopWords, metaDescriptionKeyword, new MetaDescriptionLength({ scores: { tooLong: 3, tooShort: 3 } }), new SubheadingsKeyword({ scores: { noMatches: 3, oneMatch: 6, multipleMatches: 9 } }), textCompetingLinks, new TextImages({ scores: { noImages: 3, withAltNonKeyword: 3, withAlt: 3, noAlt: 3 } }), new TextLength({ recommendedMinimum: 900, slightlyBelowMinimum: 400, belowMinimum: 300, farBelowMinimum: 0, scores: { belowMinimum: -20, farBelowMinimum: -20 } }), new OutboundLinks({ scores: { noLinks: 3 } }), internalLinks, titleKeyword, new TitleWidth({ scores: { widthTooShort: 3, widthTooLong: 3 } }), new UrlKeyword({ scores: { noKeywordInUrl: 3 } }), new UrlLength({ scores: { tooLong: 3 } }), urlStopWords]; }; __webpack_require__(14).inherits(CornerstoneSEOAssessor, SEOAssessor); module.exports = CornerstoneSEOAssessor; }), (function (module, exports, __webpack_require__) { "use strict"; var Assessor = __webpack_require__(42); var ContentAssessor = __webpack_require__(115); var fleschReadingEase = __webpack_require__(212); var paragraphTooLong = __webpack_require__(213); var SentenceLengthInText = __webpack_require__(214); var SubheadingDistributionTooLong = __webpack_require__(215); var transitionWords = __webpack_require__(216); var passiveVoice = __webpack_require__(217); var sentenceBeginnings = __webpack_require__(218); var textPresence = __webpack_require__(219); var contentConfiguration = __webpack_require__(220); var CornerStoneContentAssessor = function CornerStoneContentAssessor(i18n) { var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {}; Assessor.call(this, i18n, options); var locale = options.hasOwnProperty("locale") ? options.locale : "en_US"; this._assessments = [fleschReadingEase, new SubheadingDistributionTooLong({ slightlyTooMany: 250, farTooMany: 300, recommendedMaximumWordCount: 250 }), paragraphTooLong, new SentenceLengthInText({ recommendedWordCount: contentConfiguration(locale).sentenceLength.recommendedWordCount, slightlyTooMany: 20, farTooMany: 25 }), transitionWords, passiveVoice, textPresence, sentenceBeginnings]; }; __webpack_require__(14).inherits(CornerStoneContentAssessor, ContentAssessor); module.exports = CornerStoneContentAssessor; }), (function (module, exports, __webpack_require__) {
        "use strict"; var forEach = __webpack_require__(1); var isNumber = __webpack_require__(79); var isObject = __webpack_require__(5); var isUndefined = __webpack_require__(3); var difference = __webpack_require__(480); var template = __webpack_require__(223).assessmentPresenterResult; var scoreToRating = __webpack_require__(80); var createConfig = __webpack_require__(482); var AssessorPresenter = function AssessorPresenter(args) { this.keyword = args.keyword; this.assessor = args.assessor; this.i18n = args.i18n; this.output = args.targets.output; this.overall = args.targets.overall || "overallScore"; this.presenterConfig = createConfig(args.i18n); this._disableMarkerButtons = false; this._activeMarker = false; }; AssessorPresenter.prototype.setKeyword = function (keyword) { this.keyword = keyword; }; AssessorPresenter.prototype.configHasProperty = function (property) { return this.presenterConfig.hasOwnProperty(property); }; AssessorPresenter.prototype.getIndicator = function (rating) { return { className: this.getIndicatorColorClass(rating), screenReaderText: this.getIndicatorScreenReaderText(rating), fullText: this.getIndicatorFullText(rating), screenReaderReadabilityText: this.getIndicatorScreenReaderReadabilityText(rating) }; }; AssessorPresenter.prototype.getIndicatorColorClass = function (rating) {
            if (!this.configHasProperty(rating)) { return ""; }
            return this.presenterConfig[rating].className;
        }; AssessorPresenter.prototype.getIndicatorScreenReaderText = function (rating) {
            if (!this.configHasProperty(rating)) { return ""; }
            return this.presenterConfig[rating].screenReaderText;
        }; AssessorPresenter.prototype.getIndicatorScreenReaderReadabilityText = function (rating) {
            if (!this.configHasProperty(rating)) { return ""; }
            return this.presenterConfig[rating].screenReaderReadabilityText;
        }; AssessorPresenter.prototype.getIndicatorFullText = function (rating) {
            if (!this.configHasProperty(rating)) { return ""; }
            return this.presenterConfig[rating].fullText;
        }; AssessorPresenter.prototype.resultToRating = function (result) {
            if (!isObject(result)) { return ""; }
            result.rating = scoreToRating(result.score); return result;
        }; AssessorPresenter.prototype.getIndividualRatings = function () { var ratings = {}; var validResults = this.sort(this.assessor.getValidResults()); var mappedResults = validResults.map(this.resultToRating); forEach(mappedResults, function (item, key) { ratings[key] = this.addRating(item); }.bind(this)); return ratings; }; AssessorPresenter.prototype.excludeFromResults = function (results, exclude) { return difference(results, exclude); }; AssessorPresenter.prototype.sort = function (results) { var unsortables = this.getUndefinedScores(results); var sortables = this.excludeFromResults(results, unsortables); sortables.sort(function (a, b) { return a.score - b.score; }); return unsortables.concat(sortables); }; AssessorPresenter.prototype.getUndefinedScores = function (results) { return results.filter(function (result) { return isUndefined(result.score) || result.score === 0; }); }; AssessorPresenter.prototype.addRating = function (item) {
            var indicator = this.getIndicator(item.rating); indicator.text = item.text; indicator.identifier = item.getIdentifier(); if (item.hasMarker()) { indicator.marker = item.getMarker(); }
            return indicator;
        }; AssessorPresenter.prototype.getOverallRating = function (overallScore) {
            var rating = 0; if (this.keyword === "") { return this.resultToRating({ score: rating }); }
            if (isNumber(overallScore)) { rating = overallScore / 10; }
            return this.resultToRating({ score: rating });
        }; AssessorPresenter.prototype.markAssessment = function (identifier, marker) {
            if (this._activeMarker === identifier) { this.removeAllMarks(); this._activeMarker = false; } else { marker(); this._activeMarker = identifier; }
            this.render();
        }; AssessorPresenter.prototype.disableMarker = function () { this._activeMarker = false; this.render(); }; AssessorPresenter.prototype.disableMarkerButtons = function () { this._disableMarkerButtons = true; this.render(); }; AssessorPresenter.prototype.enableMarkerButtons = function () { this._disableMarkerButtons = false; this.render(); }; AssessorPresenter.prototype.addMarkerEventHandler = function (identifier, marker) { var container = document.getElementById(this.output); var markButton = container.getElementsByClassName("js-assessment-results__mark-" + identifier)[0]; markButton.addEventListener("click", this.markAssessment.bind(this, identifier, marker)); }; AssessorPresenter.prototype.render = function () { this.renderIndividualRatings(); this.renderOverallRating(); }; AssessorPresenter.prototype.bindMarkButtons = function (scores) { forEach(scores, function (score) { if (score.hasOwnProperty("marker")) { this.addMarkerEventHandler(score.identifier, score.marker); } }.bind(this)); }; AssessorPresenter.prototype.removeAllMarks = function () { var marker = this.assessor.getSpecificMarker(); marker(this.assessor.getPaper(), []); }; AssessorPresenter.prototype.renderIndividualRatings = function () { var outputTarget = document.getElementById(this.output); var scores = this.getIndividualRatings(); outputTarget.innerHTML = template({ scores: scores, i18n: { disabledMarkText: this.i18n.dgettext("js-text-analysis", "Marks are disabled in current view"), markInText: this.i18n.dgettext("js-text-analysis", "Mark this result in the text"), removeMarksInText: this.i18n.dgettext("js-text-analysis", "Remove marks in the text") }, activeMarker: this._activeMarker, markerButtonsDisabled: this._disableMarkerButtons }); this.bindMarkButtons(scores); }; AssessorPresenter.prototype.renderOverallRating = function () {
            var overallRating = this.getOverallRating(this.assessor.calculateOverallScore()); var overallRatingElement = document.getElementById(this.overall); if (!overallRatingElement) { return; }
            overallRatingElement.className = "overallScore " + this.getIndicatorColorClass(overallRating.rating);
        }; module.exports = AssessorPresenter;
    }), (function (module, exports, __webpack_require__) { var baseDifference = __webpack_require__(481), baseFlatten = __webpack_require__(73), baseRest = __webpack_require__(39), isArrayLikeObject = __webpack_require__(97); var difference = baseRest(function (array, values) { return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true)) : []; }); module.exports = difference; }), (function (module, exports, __webpack_require__) {
        var SetCache = __webpack_require__(64), arrayIncludes = __webpack_require__(112), arrayIncludesWith = __webpack_require__(113), arrayMap = __webpack_require__(24), baseUnary = __webpack_require__(69), cacheHas = __webpack_require__(65); var LARGE_ARRAY_SIZE = 200; function baseDifference(array, values, iteratee, comparator) {
            var index = -1, includes = arrayIncludes, isCommon = true, length = array.length, result = [], valuesLength = values.length; if (!length) { return result; }
            if (iteratee) { values = arrayMap(values, baseUnary(iteratee)); }
            if (comparator) { includes = arrayIncludesWith; isCommon = false; }
            else if (values.length >= LARGE_ARRAY_SIZE) { includes = cacheHas; isCommon = false; values = new SetCache(values); }
            outer: while (++index < length) {
                var value = array[index], computed = iteratee == null ? value : iteratee(value); value = (comparator || value !== 0) ? value : 0; if (isCommon && computed === computed) {
                    var valuesIndex = valuesLength; while (valuesIndex--) { if (values[valuesIndex] === computed) { continue outer; } }
                    result.push(value);
                }
                else if (!includes(values, computed, comparator)) { result.push(value); }
            }
            return result;
        }
        module.exports = baseDifference;
    }), (function (module, exports, __webpack_require__) { "use strict"; module.exports = function (i18n) { return { feedback: { className: "na", screenReaderText: i18n.dgettext("js-text-analysis", "Feedback"), fullText: i18n.dgettext("js-text-analysis", "Content optimization: Has feedback"), screenReaderReadabilityText: '' }, bad: { className: "bad", screenReaderText: i18n.dgettext("js-text-analysis", "Bad SEO score"), fullText: i18n.dgettext("js-text-analysis", "Content optimization: Bad SEO score"), screenReaderReadabilityText: i18n.dgettext("js-text-analysis", "Needs improvement") }, ok: { className: "ok", screenReaderText: i18n.dgettext("js-text-analysis", "OK SEO score"), fullText: i18n.dgettext("js-text-analysis", "Content optimization: OK SEO score"), screenReaderReadabilityText: i18n.dgettext("js-text-analysis", "OK") }, good: { className: "good", screenReaderText: i18n.dgettext("js-text-analysis", "Good SEO score"), fullText: i18n.dgettext("js-text-analysis", "Content optimization: Good SEO score"), screenReaderReadabilityText: i18n.dgettext("js-text-analysis", "Good") } }; }; }), (function (module, exports, __webpack_require__) {
        var arrayReduce = __webpack_require__(118), baseEach = __webpack_require__(48), baseIteratee = __webpack_require__(18), baseReduce = __webpack_require__(484), isArray = __webpack_require__(4); function reduce(collection, iteratee, accumulator) { var func = isArray(collection) ? arrayReduce : baseReduce, initAccum = arguments.length < 3; return func(collection, baseIteratee(iteratee, 4), accumulator, initAccum, baseEach); }
        module.exports = reduce;
    }), (function (module, exports) {
        function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) { eachFunc(collection, function (value, index, collection) { accumulator = initAccum ? (initAccum = false, value) : iteratee(accumulator, value, index, collection); }); return accumulator; }
        module.exports = baseReduce;
    }), (function (module, exports, __webpack_require__) {
        "use strict"; var htmlparser = __webpack_require__(54); var includes = __webpack_require__(29); var textArray = void 0; var inScriptBlock = false; var inlineTags = ["script", "style", "code", "pre"]; var parser = new htmlparser.Parser({
            onopentag: function onopentag(tagName, nodeValue) {
                if (includes(inlineTags, tagName)) { inScriptBlock = true; return; }
                var nodeValueType = Object.keys(nodeValue); var nodeValueString = ""; nodeValueType.forEach(function (node) { nodeValueString += " " + node + "='" + nodeValue[node] + "'"; }); textArray.push("<" + tagName + nodeValueString + ">");
            }, ontext: function ontext(text) { if (!inScriptBlock) { textArray.push(text); } }, onclosetag: function onclosetag(tagName) {
                if (includes(inlineTags, tagName)) { inScriptBlock = false; return; }
                textArray.push("</" + tagName + ">");
            }
        }, { decodeEntities: true }); module.exports = function (text) { textArray = []; parser.write(text); return textArray.join(""); };
    }), (function (module, exports) { module.exports = { "0": 65533, "128": 8364, "130": 8218, "131": 402, "132": 8222, "133": 8230, "134": 8224, "135": 8225, "136": 710, "137": 8240, "138": 352, "139": 8249, "140": 338, "142": 381, "145": 8216, "146": 8217, "147": 8220, "148": 8221, "149": 8226, "150": 8211, "151": 8212, "152": 732, "153": 8482, "154": 353, "155": 8250, "156": 339, "158": 382, "159": 376 } }), (function (module, exports, __webpack_require__) {
        var ElementType = __webpack_require__(55); var re_whitespace = /\s+/g; var NodePrototype = __webpack_require__(231); var ElementPrototype = __webpack_require__(488); function DomHandler(callback, options, elementCB) {
            if (typeof callback === "object") { elementCB = options; options = callback; callback = null; } else if (typeof options === "function") { elementCB = options; options = defaultOpts; }
            this._callback = callback; this._options = options || defaultOpts; this._elementCB = elementCB; this.dom = []; this._done = false; this._tagStack = []; this._parser = this._parser || null;
        }
        var defaultOpts = { normalizeWhitespace: false, withStartIndices: false, withEndIndices: false, }; DomHandler.prototype.onparserinit = function (parser) { this._parser = parser; }; DomHandler.prototype.onreset = function () { DomHandler.call(this, this._callback, this._options, this._elementCB); }; DomHandler.prototype.onend = function () { if (this._done) return; this._done = true; this._parser = null; this._handleCallback(null); }; DomHandler.prototype._handleCallback = DomHandler.prototype.onerror = function (error) { if (typeof this._callback === "function") { this._callback(error, this.dom); } else { if (error) throw error; } }; DomHandler.prototype.onclosetag = function () {
            var elem = this._tagStack.pop(); if (this._options.withEndIndices) { elem.endIndex = this._parser.endIndex; }
            if (this._elementCB) this._elementCB(elem);
        }; DomHandler.prototype._createDomElement = function (properties) {
            if (!this._options.withDomLvl1) return properties; var element; if (properties.type === "tag") { element = Object.create(ElementPrototype); } else { element = Object.create(NodePrototype); }
            for (var key in properties) { if (properties.hasOwnProperty(key)) { element[key] = properties[key]; } }
            return element;
        }; DomHandler.prototype._addDomElement = function (element) {
            var parent = this._tagStack[this._tagStack.length - 1]; var siblings = parent ? parent.children : this.dom; var previousSibling = siblings[siblings.length - 1]; element.next = null; if (this._options.withStartIndices) { element.startIndex = this._parser.startIndex; }
            if (this._options.withEndIndices) { element.endIndex = this._parser.endIndex; }
            if (previousSibling) { element.prev = previousSibling; previousSibling.next = element; } else { element.prev = null; }
            siblings.push(element); element.parent = parent || null;
        }; DomHandler.prototype.onopentag = function (name, attribs) { var properties = { type: name === "script" ? ElementType.Script : name === "style" ? ElementType.Style : ElementType.Tag, name: name, attribs: attribs, children: [] }; var element = this._createDomElement(properties); this._addDomElement(element); this._tagStack.push(element); }; DomHandler.prototype.ontext = function (data) {
            var normalize = this._options.normalizeWhitespace || this._options.ignoreWhitespace; var lastTag; if (!this._tagStack.length && this.dom.length && (lastTag = this.dom[this.dom.length - 1]).type === ElementType.Text) { if (normalize) { lastTag.data = (lastTag.data + data).replace(re_whitespace, " "); } else { lastTag.data += data; } } else {
                if (this._tagStack.length && (lastTag = this._tagStack[this._tagStack.length - 1]) && (lastTag = lastTag.children[lastTag.children.length - 1]) && lastTag.type === ElementType.Text) { if (normalize) { lastTag.data = (lastTag.data + data).replace(re_whitespace, " "); } else { lastTag.data += data; } } else {
                    if (normalize) { data = data.replace(re_whitespace, " "); }
                    var element = this._createDomElement({ data: data, type: ElementType.Text }); this._addDomElement(element);
                }
            }
        }; DomHandler.prototype.oncomment = function (data) {
            var lastTag = this._tagStack[this._tagStack.length - 1]; if (lastTag && lastTag.type === ElementType.Comment) { lastTag.data += data; return; }
            var properties = { data: data, type: ElementType.Comment }; var element = this._createDomElement(properties); this._addDomElement(element); this._tagStack.push(element);
        }; DomHandler.prototype.oncdatastart = function () { var properties = { children: [{ data: "", type: ElementType.Text }], type: ElementType.CDATA }; var element = this._createDomElement(properties); this._addDomElement(element); this._tagStack.push(element); }; DomHandler.prototype.oncommentend = DomHandler.prototype.oncdataend = function () { this._tagStack.pop(); }; DomHandler.prototype.onprocessinginstruction = function (name, data) { var element = this._createDomElement({ name: name, data: data, type: ElementType.Directive }); this._addDomElement(element); }; module.exports = DomHandler;
    }), (function (module, exports, __webpack_require__) { var NodePrototype = __webpack_require__(231); var ElementPrototype = module.exports = Object.create(NodePrototype); var domLvl1 = { tagName: "name" }; Object.keys(domLvl1).forEach(function (key) { var shorthand = domLvl1[key]; Object.defineProperty(ElementPrototype, key, { get: function () { return this[shorthand] || null; }, set: function (val) { this[shorthand] = val; return val; } }); }); }), (function (module, exports, __webpack_require__) {
        var index = __webpack_require__(54), DomHandler = index.DomHandler, DomUtils = index.DomUtils; function FeedHandler(callback, options) { this.init(callback, options); }
        __webpack_require__(16)(FeedHandler, DomHandler); FeedHandler.prototype.init = DomHandler; function getElements(what, where) { return DomUtils.getElementsByTagName(what, where, true); }
        function getOneElement(what, where) { return DomUtils.getElementsByTagName(what, where, true, 1)[0]; }
        function fetch(what, where, recurse) { return DomUtils.getText(DomUtils.getElementsByTagName(what, where, recurse, 1)).trim(); }
        function addConditionally(obj, prop, what, where, recurse) { var tmp = fetch(what, where, recurse); if (tmp) obj[prop] = tmp; }
        var isValidFeed = function (value) { return value === "rss" || value === "feed" || value === "rdf:RDF"; }; FeedHandler.prototype.onend = function () {
            var feed = {}, feedRoot = getOneElement(isValidFeed, this.dom), tmp, childs; if (feedRoot) { if (feedRoot.name === "feed") { childs = feedRoot.children; feed.type = "atom"; addConditionally(feed, "id", "id", childs); addConditionally(feed, "title", "title", childs); if ((tmp = getOneElement("link", childs)) && (tmp = tmp.attribs) && (tmp = tmp.href)) feed.link = tmp; addConditionally(feed, "description", "subtitle", childs); if ((tmp = fetch("updated", childs))) feed.updated = new Date(tmp); addConditionally(feed, "author", "email", childs, true); feed.items = getElements("entry", childs).map(function (item) { var entry = {}, tmp; item = item.children; addConditionally(entry, "id", "id", item); addConditionally(entry, "title", "title", item); if ((tmp = getOneElement("link", item)) && (tmp = tmp.attribs) && (tmp = tmp.href)) entry.link = tmp; if ((tmp = fetch("summary", item) || fetch("content", item))) entry.description = tmp; if ((tmp = fetch("updated", item))) entry.pubDate = new Date(tmp); return entry; }); } else { childs = getOneElement("channel", feedRoot.children).children; feed.type = feedRoot.name.substr(0, 3); feed.id = ""; addConditionally(feed, "title", "title", childs); addConditionally(feed, "link", "link", childs); addConditionally(feed, "description", "description", childs); if ((tmp = fetch("lastBuildDate", childs))) feed.updated = new Date(tmp); addConditionally(feed, "author", "managingEditor", childs, true); feed.items = getElements("item", feedRoot.children).map(function (item) { var entry = {}, tmp; item = item.children; addConditionally(entry, "id", "guid", item); addConditionally(entry, "title", "title", item); addConditionally(entry, "link", "link", item); addConditionally(entry, "description", "description", item); if ((tmp = fetch("pubDate", item))) entry.pubDate = new Date(tmp); return entry; }); } }
            this.dom = feed; DomHandler.prototype._handleCallback.call(this, feedRoot ? null : Error("couldn't find root of feed"));
        }; module.exports = FeedHandler;
    }), (function (module, exports, __webpack_require__) {
        module.exports = Stream; var Parser = __webpack_require__(232); function Stream(options) { Parser.call(this, new Cbs(this), options); }
        __webpack_require__(16)(Stream, Parser); Stream.prototype.readable = true; function Cbs(scope) { this.scope = scope; }
        var EVENTS = __webpack_require__(54).EVENTS; Object.keys(EVENTS).forEach(function (name) { if (EVENTS[name] === 0) { Cbs.prototype["on" + name] = function () { this.scope.emit(name); }; } else if (EVENTS[name] === 1) { Cbs.prototype["on" + name] = function (a) { this.scope.emit(name, a); }; } else if (EVENTS[name] === 2) { Cbs.prototype["on" + name] = function (a, b) { this.scope.emit(name, a, b); }; } else { throw Error("wrong number of arguments!"); } });
    }), (function (module, exports, __webpack_require__) {
        module.exports = Stream; var EE = __webpack_require__(76).EventEmitter; var inherits = __webpack_require__(16); inherits(Stream, EE); Stream.Readable = __webpack_require__(122); Stream.Writable = __webpack_require__(500); Stream.Duplex = __webpack_require__(501); Stream.Transform = __webpack_require__(502); Stream.PassThrough = __webpack_require__(503); Stream.Stream = Stream; function Stream() { EE.call(this); }
        Stream.prototype.pipe = function (dest, options) {
            var source = this; function ondata(chunk) { if (dest.writable) { if (false === dest.write(chunk) && source.pause) { source.pause(); } } }
            source.on('data', ondata); function ondrain() { if (source.readable && source.resume) { source.resume(); } }
            dest.on('drain', ondrain); if (!dest._isStdio && (!options || options.end !== false)) { source.on('end', onend); source.on('close', onclose); }
            var didOnEnd = false; function onend() { if (didOnEnd) return; didOnEnd = true; dest.end(); }
            function onclose() { if (didOnEnd) return; didOnEnd = true; if (typeof dest.destroy === 'function') dest.destroy(); }
            function onerror(er) { cleanup(); if (EE.listenerCount(this, 'error') === 0) { throw er; } }
            source.on('error', onerror); dest.on('error', onerror); function cleanup() { source.removeListener('data', ondata); dest.removeListener('drain', ondrain); source.removeListener('end', onend); source.removeListener('close', onclose); source.removeListener('error', onerror); dest.removeListener('error', onerror); source.removeListener('end', cleanup); source.removeListener('close', cleanup); dest.removeListener('close', cleanup); }
            source.on('end', cleanup); source.on('close', cleanup); dest.on('close', cleanup); dest.emit('pipe', source); return dest;
        };
    }), (function (module, exports, __webpack_require__) {
        "use strict"; exports.byteLength = byteLength
        exports.toByteArray = toByteArray
        exports.fromByteArray = fromByteArray
        var lookup = []
        var revLookup = []
        var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array
        var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
        for (var i = 0, len = code.length; i < len; ++i) {
            lookup[i] = code[i]
            revLookup[code.charCodeAt(i)] = i
        }
        revLookup['-'.charCodeAt(0)] = 62
        revLookup['_'.charCodeAt(0)] = 63
        function placeHoldersCount(b64) {
            var len = b64.length
            if (len % 4 > 0) { throw new Error('Invalid string. Length must be a multiple of 4') }
            return b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0
        }
        function byteLength(b64) { return (b64.length * 3 / 4) - placeHoldersCount(b64) }
        function toByteArray(b64) {
            var i, l, tmp, placeHolders, arr
            var len = b64.length
            placeHolders = placeHoldersCount(b64)
            arr = new Arr((len * 3 / 4) - placeHolders)
            l = placeHolders > 0 ? len - 4 : len
            var L = 0
            for (i = 0; i < l; i += 4) {
                tmp = (revLookup[b64.charCodeAt(i)] << 18) | (revLookup[b64.charCodeAt(i + 1)] << 12) | (revLookup[b64.charCodeAt(i + 2)] << 6) | revLookup[b64.charCodeAt(i + 3)]
                arr[L++] = (tmp >> 16) & 0xFF
                arr[L++] = (tmp >> 8) & 0xFF
                arr[L++] = tmp & 0xFF
            }
            if (placeHolders === 2) {
                tmp = (revLookup[b64.charCodeAt(i)] << 2) | (revLookup[b64.charCodeAt(i + 1)] >> 4)
                arr[L++] = tmp & 0xFF
            } else if (placeHolders === 1) {
                tmp = (revLookup[b64.charCodeAt(i)] << 10) | (revLookup[b64.charCodeAt(i + 1)] << 4) | (revLookup[b64.charCodeAt(i + 2)] >> 2)
                arr[L++] = (tmp >> 8) & 0xFF
                arr[L++] = tmp & 0xFF
            }
            return arr
        }
        function tripletToBase64(num) { return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F] }
        function encodeChunk(uint8, start, end) {
            var tmp
            var output = []
            for (var i = start; i < end; i += 3) {
                tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])
                output.push(tripletToBase64(tmp))
            }
            return output.join('')
        }
        function fromByteArray(uint8) {
            var tmp
            var len = uint8.length
            var extraBytes = len % 3
            var output = ''
            var parts = []
            var maxChunkLength = 16383
            for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) { parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength))) }
            if (extraBytes === 1) {
                tmp = uint8[len - 1]
                output += lookup[tmp >> 2]
                output += lookup[(tmp << 4) & 0x3F]
                output += '=='
            } else if (extraBytes === 2) {
                tmp = (uint8[len - 2] << 8) + (uint8[len - 1])
                output += lookup[tmp >> 10]
                output += lookup[(tmp >> 4) & 0x3F]
                output += lookup[(tmp << 2) & 0x3F]
                output += '='
            }
            parts.push(output)
            return parts.join('')
        }
    }), (function (module, exports) {
        exports.read = function (buffer, offset, isLE, mLen, nBytes) {
            var e, m
            var eLen = nBytes * 8 - mLen - 1
            var eMax = (1 << eLen) - 1
            var eBias = eMax >> 1
            var nBits = -7
            var i = isLE ? (nBytes - 1) : 0
            var d = isLE ? -1 : 1
            var s = buffer[offset + i]
            i += d
            e = s & ((1 << (-nBits)) - 1)
            s >>= (-nBits)
            nBits += eLen
            for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) { }
            m = e & ((1 << (-nBits)) - 1)
            e >>= (-nBits)
            nBits += mLen
            for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) { }
            if (e === 0) { e = 1 - eBias } else if (e === eMax) { return m ? NaN : ((s ? -1 : 1) * Infinity) } else {
                m = m + Math.pow(2, mLen)
                e = e - eBias
            }
            return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
        }
        exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
            var e, m, c
            var eLen = nBytes * 8 - mLen - 1
            var eMax = (1 << eLen) - 1
            var eBias = eMax >> 1
            var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
            var i = isLE ? 0 : (nBytes - 1)
            var d = isLE ? 1 : -1
            var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0
            value = Math.abs(value)
            if (isNaN(value) || value === Infinity) {
                m = isNaN(value) ? 1 : 0
                e = eMax
            } else {
                e = Math.floor(Math.log(value) / Math.LN2)
                if (value * (c = Math.pow(2, -e)) < 1) {
                    e--
                    c *= 2
                }
                if (e + eBias >= 1) { value += rt / c } else { value += rt * Math.pow(2, 1 - eBias) }
                if (value * c >= 2) {
                    e++
                    c /= 2
                }
                if (e + eBias >= eMax) {
                    m = 0
                    e = eMax
                } else if (e + eBias >= 1) {
                    m = (value * c - 1) * Math.pow(2, mLen)
                    e = e + eBias
                } else {
                    m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
                    e = 0
                }
            }
            for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) { }
            e = (e << mLen) | m
            eLen += mLen
            for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) { }
            buffer[offset + i - d] |= s * 128
        }
    }), (function (module, exports) { }), (function (module, exports, __webpack_require__) {
        "use strict"; function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
        var Buffer = __webpack_require__(78).Buffer; function copyBuffer(src, target, offset) { src.copy(target, offset); }
        module.exports = function () {
            function BufferList() { _classCallCheck(this, BufferList); this.head = null; this.tail = null; this.length = 0; }
            BufferList.prototype.push = function push(v) { var entry = { data: v, next: null }; if (this.length > 0) this.tail.next = entry; else this.head = entry; this.tail = entry; ++this.length; }; BufferList.prototype.unshift = function unshift(v) { var entry = { data: v, next: this.head }; if (this.length === 0) this.tail = entry; this.head = entry; ++this.length; }; BufferList.prototype.shift = function shift() { if (this.length === 0) return; var ret = this.head.data; if (this.length === 1) this.head = this.tail = null; else this.head = this.head.next; --this.length; return ret; }; BufferList.prototype.clear = function clear() { this.head = this.tail = null; this.length = 0; }; BufferList.prototype.join = function join(s) { if (this.length === 0) return ''; var p = this.head; var ret = '' + p.data; while (p = p.next) { ret += s + p.data; } return ret; }; BufferList.prototype.concat = function concat(n) {
                if (this.length === 0) return Buffer.alloc(0); if (this.length === 1) return this.head.data; var ret = Buffer.allocUnsafe(n >>> 0); var p = this.head; var i = 0; while (p) { copyBuffer(p.data, ret, i); i += p.data.length; p = p.next; }
                return ret;
            }; return BufferList;
        }();
    }), (function (module, exports, __webpack_require__) {
        var apply = Function.prototype.apply; exports.setTimeout = function () { return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout); }; exports.setInterval = function () { return new Timeout(apply.call(setInterval, window, arguments), clearInterval); }; exports.clearTimeout = exports.clearInterval = function (timeout) { if (timeout) { timeout.close(); } }; function Timeout(id, clearFn) { this._id = id; this._clearFn = clearFn; }
        Timeout.prototype.unref = Timeout.prototype.ref = function () { }; Timeout.prototype.close = function () { this._clearFn.call(window, this._id); }; exports.enroll = function (item, msecs) { clearTimeout(item._idleTimeoutId); item._idleTimeout = msecs; }; exports.unenroll = function (item) { clearTimeout(item._idleTimeoutId); item._idleTimeout = -1; }; exports._unrefActive = exports.active = function (item) {
            clearTimeout(item._idleTimeoutId); var msecs = item._idleTimeout; if (msecs >= 0) {
                item._idleTimeoutId = setTimeout(function onTimeout() {
                    if (item._onTimeout)
                        item._onTimeout();
                }, msecs);
            }
        }; __webpack_require__(497); exports.setImmediate = setImmediate; exports.clearImmediate = clearImmediate;
    }), (function (module, exports, __webpack_require__) {
        (function (global, process) {
            (function (global, undefined) {
                "use strict"; if (global.setImmediate) { return; }
                var nextHandle = 1; var tasksByHandle = {}; var currentlyRunningATask = false; var doc = global.document; var registerImmediate; function setImmediate(callback) {
                    if (typeof callback !== "function") { callback = new Function("" + callback); }
                    var args = new Array(arguments.length - 1); for (var i = 0; i < args.length; i++) { args[i] = arguments[i + 1]; }
                    var task = { callback: callback, args: args }; tasksByHandle[nextHandle] = task; registerImmediate(nextHandle); return nextHandle++;
                }
                function clearImmediate(handle) { delete tasksByHandle[handle]; }
                function run(task) { var callback = task.callback; var args = task.args; switch (args.length) { case 0: callback(); break; case 1: callback(args[0]); break; case 2: callback(args[0], args[1]); break; case 3: callback(args[0], args[1], args[2]); break; default: callback.apply(undefined, args); break; } }
                function runIfPresent(handle) { if (currentlyRunningATask) { setTimeout(runIfPresent, 0, handle); } else { var task = tasksByHandle[handle]; if (task) { currentlyRunningATask = true; try { run(task); } finally { clearImmediate(handle); currentlyRunningATask = false; } } } }
                function installNextTickImplementation() { registerImmediate = function (handle) { process.nextTick(function () { runIfPresent(handle); }); }; }
                function canUsePostMessage() { if (global.postMessage && !global.importScripts) { var postMessageIsAsynchronous = true; var oldOnMessage = global.onmessage; global.onmessage = function () { postMessageIsAsynchronous = false; }; global.postMessage("", "*"); global.onmessage = oldOnMessage; return postMessageIsAsynchronous; } }
                function installPostMessageImplementation() {
                    var messagePrefix = "setImmediate$" + Math.random() + "$"; var onGlobalMessage = function (event) { if (event.source === global && typeof event.data === "string" && event.data.indexOf(messagePrefix) === 0) { runIfPresent(+event.data.slice(messagePrefix.length)); } }; if (global.addEventListener) { global.addEventListener("message", onGlobalMessage, false); } else { global.attachEvent("onmessage", onGlobalMessage); }
                    registerImmediate = function (handle) { global.postMessage(messagePrefix + handle, "*"); };
                }
                function installMessageChannelImplementation() { var channel = new MessageChannel(); channel.port1.onmessage = function (event) { var handle = event.data; runIfPresent(handle); }; registerImmediate = function (handle) { channel.port2.postMessage(handle); }; }
                function installReadyStateChangeImplementation() { var html = doc.documentElement; registerImmediate = function (handle) { var script = doc.createElement("script"); script.onreadystatechange = function () { runIfPresent(handle); script.onreadystatechange = null; html.removeChild(script); script = null; }; html.appendChild(script); }; }
                function installSetTimeoutImplementation() { registerImmediate = function (handle) { setTimeout(runIfPresent, 0, handle); }; }
                var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global); attachTo = attachTo && attachTo.setTimeout ? attachTo : global; if ({}.toString.call(global.process) === "[object process]") { installNextTickImplementation(); } else if (canUsePostMessage()) { installPostMessageImplementation(); } else if (global.MessageChannel) { installMessageChannelImplementation(); } else if (doc && "onreadystatechange" in doc.createElement("script")) { installReadyStateChangeImplementation(); } else { installSetTimeoutImplementation(); }
                attachTo.setImmediate = setImmediate; attachTo.clearImmediate = clearImmediate;
            }(typeof self === "undefined" ? typeof global === "undefined" ? this : global : self));
        }.call(exports, __webpack_require__(17), __webpack_require__(41)))
    }), (function (module, exports, __webpack_require__) {
        (function (global) {
            module.exports = deprecate; function deprecate(fn, msg) {
                if (config('noDeprecation')) { return fn; }
                var warned = false; function deprecated() {
                    if (!warned) {
                        if (config('throwDeprecation')) { throw new Error(msg); } else if (config('traceDeprecation')) { console.trace(msg); } else { console.warn(msg); }
                        warned = true;
                    }
                    return fn.apply(this, arguments);
                }
                return deprecated;
            }
            function config(name) {
                try { if (!global.localStorage) return false; } catch (_) { return false; }
                var val = global.localStorage[name]; if (null == val) return false; return String(val).toLowerCase() === 'true';
            }
        }.call(exports, __webpack_require__(17)))
    }), (function (module, exports, __webpack_require__) {
        "use strict"; module.exports = PassThrough; var Transform = __webpack_require__(237); var util = __webpack_require__(56); util.inherits = __webpack_require__(16); util.inherits(PassThrough, Transform); function PassThrough(options) { if (!(this instanceof PassThrough)) return new PassThrough(options); Transform.call(this, options); }
        PassThrough.prototype._transform = function (chunk, encoding, cb) { cb(null, chunk); };
    }), (function (module, exports, __webpack_require__) { module.exports = __webpack_require__(124); }), (function (module, exports, __webpack_require__) { module.exports = __webpack_require__(33); }), (function (module, exports, __webpack_require__) { module.exports = __webpack_require__(122).Transform }), (function (module, exports, __webpack_require__) { module.exports = __webpack_require__(122).PassThrough }), (function (module, exports) { }), (function (module, exports, __webpack_require__) {
        module.exports = ProxyHandler; function ProxyHandler(cbs) { this._cbs = cbs || {}; }
        var EVENTS = __webpack_require__(54).EVENTS; Object.keys(EVENTS).forEach(function (name) { if (EVENTS[name] === 0) { name = "on" + name; ProxyHandler.prototype[name] = function () { if (this._cbs[name]) this._cbs[name](); }; } else if (EVENTS[name] === 1) { name = "on" + name; ProxyHandler.prototype[name] = function (a) { if (this._cbs[name]) this._cbs[name](a); }; } else if (EVENTS[name] === 2) { name = "on" + name; ProxyHandler.prototype[name] = function (a, b) { if (this._cbs[name]) this._cbs[name](a, b); }; } else { throw Error("wrong number of arguments"); } });
    }), (function (module, exports, __webpack_require__) { var DomUtils = module.exports;[__webpack_require__(507), __webpack_require__(513), __webpack_require__(514), __webpack_require__(515), __webpack_require__(516), __webpack_require__(517)].forEach(function (ext) { Object.keys(ext).forEach(function (key) { DomUtils[key] = ext[key].bind(DomUtils); }); }); }), (function (module, exports, __webpack_require__) {
        var ElementType = __webpack_require__(55), getOuterHTML = __webpack_require__(508), isTag = ElementType.isTag; module.exports = { getInnerHTML: getInnerHTML, getOuterHTML: getOuterHTML, getText: getText }; function getInnerHTML(elem, opts) { return elem.children ? elem.children.map(function (elem) { return getOuterHTML(elem, opts); }).join("") : ""; }
        function getText(elem) { if (Array.isArray(elem)) return elem.map(getText).join(""); if (isTag(elem)) return elem.name === "br" ? "\n" : getText(elem.children); if (elem.type === ElementType.CDATA) return getText(elem.children); if (elem.type === ElementType.Text) return elem.data; return ""; }
    }), (function (module, exports, __webpack_require__) {
        var ElementType = __webpack_require__(509); var entities = __webpack_require__(510); var booleanAttributes = { __proto__: null, allowfullscreen: true, async: true, autofocus: true, autoplay: true, checked: true, controls: true, default: true, defer: true, disabled: true, hidden: true, ismap: true, loop: true, multiple: true, muted: true, open: true, readonly: true, required: true, reversed: true, scoped: true, seamless: true, selected: true, typemustmatch: true }; var unencodedElements = { __proto__: null, style: true, script: true, xmp: true, iframe: true, noembed: true, noframes: true, plaintext: true, noscript: true }; function formatAttrs(attributes, opts) {
            if (!attributes) return; var output = '', value; for (var key in attributes) {
                value = attributes[key]; if (output) { output += ' '; }
                if (!value && booleanAttributes[key]) { output += key; } else { output += key + '="' + (opts.decodeEntities ? entities.encodeXML(value) : value) + '"'; }
            }
            return output;
        }
        var singleTag = { __proto__: null, area: true, base: true, basefont: true, br: true, col: true, command: true, embed: true, frame: true, hr: true, img: true, input: true, isindex: true, keygen: true, link: true, meta: true, param: true, source: true, track: true, wbr: true, }; var render = module.exports = function (dom, opts) {
            if (!Array.isArray(dom) && !dom.cheerio) dom = [dom]; opts = opts || {}; var output = ''; for (var i = 0; i < dom.length; i++) {
                var elem = dom[i]; if (elem.type === 'root')
                    output += render(elem.children, opts); else if (ElementType.isTag(elem))
                    output += renderTag(elem, opts); else if (elem.type === ElementType.Directive)
                    output += renderDirective(elem); else if (elem.type === ElementType.Comment)
                    output += renderComment(elem); else if (elem.type === ElementType.CDATA)
                    output += renderCdata(elem); else
                    output += renderText(elem, opts);
            }
            return output;
        }; function renderTag(elem, opts) {
            if (elem.name === "svg") opts = { decodeEntities: opts.decodeEntities, xmlMode: true }; var tag = '<' + elem.name, attribs = formatAttrs(elem.attribs, opts); if (attribs) { tag += ' ' + attribs; }
            if (opts.xmlMode && (!elem.children || elem.children.length === 0)) { tag += '/>'; } else {
                tag += '>'; if (elem.children) { tag += render(elem.children, opts); }
                if (!singleTag[elem.name] || opts.xmlMode) { tag += '</' + elem.name + '>'; }
            }
            return tag;
        }
        function renderDirective(elem) { return '<' + elem.data + '>'; }
        function renderText(elem, opts) {
            var data = elem.data || ''; if (opts.decodeEntities && !(elem.parent && elem.parent.name in unencodedElements)) { data = entities.encodeXML(data); }
            return data;
        }
        function renderCdata(elem) { return '<![CDATA[' + elem.children[0].data + ']]>'; }
        function renderComment(elem) { return '<!--' + elem.data + '-->'; }
    }), (function (module, exports) { module.exports = { Text: "text", Directive: "directive", Comment: "comment", Script: "script", Style: "style", Tag: "tag", CDATA: "cdata", isTag: function (elem) { return elem.type === "tag" || elem.type === "script" || elem.type === "style"; } }; }), (function (module, exports, __webpack_require__) { var encode = __webpack_require__(511), decode = __webpack_require__(512); exports.decode = function (data, level) { return (!level || level <= 0 ? decode.XML : decode.HTML)(data); }; exports.decodeStrict = function (data, level) { return (!level || level <= 0 ? decode.XML : decode.HTMLStrict)(data); }; exports.encode = function (data, level) { return (!level || level <= 0 ? encode.XML : encode.HTML)(data); }; exports.encodeXML = encode.XML; exports.encodeHTML4 = exports.encodeHTML5 = exports.encodeHTML = encode.HTML; exports.decodeXML = exports.decodeXMLStrict = decode.XML; exports.decodeHTML4 = exports.decodeHTML5 = exports.decodeHTML = decode.HTML; exports.decodeHTML4Strict = exports.decodeHTML5Strict = exports.decodeHTMLStrict = decode.HTMLStrict; exports.escape = encode.escape; }), (function (module, exports, __webpack_require__) {
        var inverseXML = getInverseObj(__webpack_require__(121)), xmlReplacer = getInverseReplacer(inverseXML); exports.XML = getInverse(inverseXML, xmlReplacer); var inverseHTML = getInverseObj(__webpack_require__(120)), htmlReplacer = getInverseReplacer(inverseHTML); exports.HTML = getInverse(inverseHTML, htmlReplacer); function getInverseObj(obj) { return Object.keys(obj).sort().reduce(function (inverse, name) { inverse[obj[name]] = "&" + name + ";"; return inverse; }, {}); }
        function getInverseReplacer(inverse) { var single = [], multiple = []; Object.keys(inverse).forEach(function (k) { if (k.length === 1) { single.push("\\" + k); } else { multiple.push(k); } }); multiple.unshift("[" + single.join("") + "]"); return new RegExp(multiple.join("|"), "g"); }
        var re_nonASCII = /[^\0-\x7F]/g, re_astralSymbols = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g; function singleCharReplacer(c) { return "&#x" + c.charCodeAt(0).toString(16).toUpperCase() + ";"; }
        function astralReplacer(c) { var high = c.charCodeAt(0); var low = c.charCodeAt(1); var codePoint = (high - 0xD800) * 0x400 + low - 0xDC00 + 0x10000; return "&#x" + codePoint.toString(16).toUpperCase() + ";"; }
        function getInverse(inverse, re) {
            function func(name) { return inverse[name]; }
            return function (data) { return data.replace(re, func).replace(re_astralSymbols, astralReplacer).replace(re_nonASCII, singleCharReplacer); };
        }
        var re_xmlChars = getInverseReplacer(inverseXML); function escapeXML(data) { return data.replace(re_xmlChars, singleCharReplacer).replace(re_astralSymbols, astralReplacer).replace(re_nonASCII, singleCharReplacer); }
        exports.escape = escapeXML;
    }), (function (module, exports, __webpack_require__) {
        var entityMap = __webpack_require__(120), legacyMap = __webpack_require__(230), xmlMap = __webpack_require__(121), decodeCodePoint = __webpack_require__(229); var decodeXMLStrict = getStrictDecoder(xmlMap), decodeHTMLStrict = getStrictDecoder(entityMap); function getStrictDecoder(map) { var keys = Object.keys(map).join("|"), replace = getReplacer(map); keys += "|#[xX][\\da-fA-F]+|#\\d+"; var re = new RegExp("&(?:" + keys + ");", "g"); return function (str) { return String(str).replace(re, replace); }; }
        var decodeHTML = (function () {
            var legacy = Object.keys(legacyMap).sort(sorter); var keys = Object.keys(entityMap).sort(sorter); for (var i = 0, j = 0; i < keys.length; i++) { if (legacy[j] === keys[i]) { keys[i] += ";?"; j++; } else { keys[i] += ";"; } }
            var re = new RegExp("&(?:" + keys.join("|") + "|#[xX][\\da-fA-F]+;?|#\\d+;?)", "g"), replace = getReplacer(entityMap); function replacer(str) { if (str.substr(-1) !== ";") str += ";"; return replace(str); }
            return function (str) { return String(str).replace(re, replacer); };
        }()); function sorter(a, b) { return a < b ? 1 : -1; }
        function getReplacer(map) {
            return function replace(str) {
                if (str.charAt(1) === "#") {
                    if (str.charAt(2) === "X" || str.charAt(2) === "x") { return decodeCodePoint(parseInt(str.substr(3), 16)); }
                    return decodeCodePoint(parseInt(str.substr(2), 10));
                }
                return map[str.slice(1, -1)];
            };
        }
        module.exports = { XML: decodeXMLStrict, HTML: decodeHTML, HTMLStrict: decodeHTMLStrict };
    }), (function (module, exports) { var getChildren = exports.getChildren = function (elem) { return elem.children; }; var getParent = exports.getParent = function (elem) { return elem.parent; }; exports.getSiblings = function (elem) { var parent = getParent(elem); return parent ? getChildren(parent) : [elem]; }; exports.getAttributeValue = function (elem, name) { return elem.attribs && elem.attribs[name]; }; exports.hasAttrib = function (elem, name) { return !!elem.attribs && hasOwnProperty.call(elem.attribs, name); }; exports.getName = function (elem) { return elem.name; }; }), (function (module, exports) {
        exports.removeElement = function (elem) { if (elem.prev) elem.prev.next = elem.next; if (elem.next) elem.next.prev = elem.prev; if (elem.parent) { var childs = elem.parent.children; childs.splice(childs.lastIndexOf(elem), 1); } }; exports.replaceElement = function (elem, replacement) {
            var prev = replacement.prev = elem.prev; if (prev) { prev.next = replacement; }
            var next = replacement.next = elem.next; if (next) { next.prev = replacement; }
            var parent = replacement.parent = elem.parent; if (parent) { var childs = parent.children; childs[childs.lastIndexOf(elem)] = replacement; }
        }; exports.appendChild = function (elem, child) { child.parent = elem; if (elem.children.push(child) !== 1) { var sibling = elem.children[elem.children.length - 2]; sibling.next = child; child.prev = sibling; child.next = null; } }; exports.append = function (elem, next) { var parent = elem.parent, currNext = elem.next; next.next = currNext; next.prev = elem; elem.next = next; next.parent = parent; if (currNext) { currNext.prev = next; if (parent) { var childs = parent.children; childs.splice(childs.lastIndexOf(currNext), 0, next); } } else if (parent) { parent.children.push(next); } }; exports.prepend = function (elem, prev) {
            var parent = elem.parent; if (parent) { var childs = parent.children; childs.splice(childs.lastIndexOf(elem), 0, prev); }
            if (elem.prev) { elem.prev.next = prev; }
            prev.parent = parent; prev.prev = elem.prev; prev.next = elem; elem.prev = prev;
        };
    }), (function (module, exports, __webpack_require__) {
        var isTag = __webpack_require__(55).isTag; module.exports = { filter: filter, find: find, findOneChild: findOneChild, findOne: findOne, existsOne: existsOne, findAll: findAll }; function filter(test, element, recurse, limit) {
            if (!Array.isArray(element)) element = [element]; if (typeof limit !== "number" || !isFinite(limit)) { limit = Infinity; }
            return find(test, element, recurse !== false, limit);
        }
        function find(test, elems, recurse, limit) {
            var result = [], childs; for (var i = 0, j = elems.length; i < j; i++) {
                if (test(elems[i])) { result.push(elems[i]); if (--limit <= 0) break; }
                childs = elems[i].children; if (recurse && childs && childs.length > 0) { childs = find(test, childs, recurse, limit); result = result.concat(childs); limit -= childs.length; if (limit <= 0) break; }
            }
            return result;
        }
        function findOneChild(test, elems) {
            for (var i = 0, l = elems.length; i < l; i++) { if (test(elems[i])) return elems[i]; }
            return null;
        }
        function findOne(test, elems) {
            var elem = null; for (var i = 0, l = elems.length; i < l && !elem; i++) { if (!isTag(elems[i])) { continue; } else if (test(elems[i])) { elem = elems[i]; } else if (elems[i].children.length > 0) { elem = findOne(test, elems[i].children); } }
            return elem;
        }
        function existsOne(test, elems) {
            for (var i = 0, l = elems.length; i < l; i++) { if (isTag(elems[i]) && (test(elems[i]) || (elems[i].children.length > 0 && existsOne(test, elems[i].children)))) { return true; } }
            return false;
        }
        function findAll(test, rootElems) {
            var result = []; var stack = [rootElems]; while (stack.length) {
                var elems = stack.pop(); for (var i = 0, j = elems.length; i < j; i++) { if (!isTag(elems[i])) continue; if (test(elems[i])) result.push(elems[i]); }
                while (j-- > 0) { if (elems[j].children && elems[j].children.length > 0) { stack.push(elems[j].children); } }
            }
            return result;
        }
    }), (function (module, exports, __webpack_require__) {
        var ElementType = __webpack_require__(55); var isTag = exports.isTag = ElementType.isTag; exports.testElement = function (options, element) {
            for (var key in options) { if (!options.hasOwnProperty(key)); else if (key === "tag_name") { if (!isTag(element) || !options.tag_name(element.name)) { return false; } } else if (key === "tag_type") { if (!options.tag_type(element.type)) return false; } else if (key === "tag_contains") { if (isTag(element) || !options.tag_contains(element.data)) { return false; } } else if (!element.attribs || !options[key](element.attribs[key])) { return false; } }
            return true;
        }; var Checks = { tag_name: function (name) { if (typeof name === "function") { return function (elem) { return isTag(elem) && name(elem.name); }; } else if (name === "*") { return isTag; } else { return function (elem) { return isTag(elem) && elem.name === name; }; } }, tag_type: function (type) { if (typeof type === "function") { return function (elem) { return type(elem.type); }; } else { return function (elem) { return elem.type === type; }; } }, tag_contains: function (data) { if (typeof data === "function") { return function (elem) { return !isTag(elem) && data(elem.data); }; } else { return function (elem) { return !isTag(elem) && elem.data === data; }; } } }; function getAttribCheck(attrib, value) { if (typeof value === "function") { return function (elem) { return elem.attribs && value(elem.attribs[attrib]); }; } else { return function (elem) { return elem.attribs && elem.attribs[attrib] === value; }; } }
        function combineFuncs(a, b) { return function (elem) { return a(elem) || b(elem); }; }
        exports.getElements = function (options, element, recurse, limit) { var funcs = Object.keys(options).map(function (key) { var value = options[key]; return key in Checks ? Checks[key](value) : getAttribCheck(key, value); }); return funcs.length === 0 ? [] : this.filter(funcs.reduce(combineFuncs), element, recurse, limit); }; exports.getElementById = function (id, element, recurse) { if (!Array.isArray(element)) element = [element]; return this.findOne(getAttribCheck("id", id), element, recurse !== false); }; exports.getElementsByTagName = function (name, element, recurse, limit) { return this.filter(Checks.tag_name(name), element, recurse, limit); }; exports.getElementsByTagType = function (type, element, recurse, limit) { return this.filter(Checks.tag_type(type), element, recurse, limit); };
    }), (function (module, exports) {
        exports.removeSubsets = function (nodes) {
            var idx = nodes.length, node, ancestor, replace; while (--idx > -1) {
                node = ancestor = nodes[idx]; nodes[idx] = null; replace = true; while (ancestor) {
                    if (nodes.indexOf(ancestor) > -1) { replace = false; nodes.splice(idx, 1); break; }
                    ancestor = ancestor.parent;
                }
                if (replace) { nodes[idx] = node; }
            }
            return nodes;
        }; var POSITION = { DISCONNECTED: 1, PRECEDING: 2, FOLLOWING: 4, CONTAINS: 8, CONTAINED_BY: 16 }; var comparePos = exports.compareDocumentPosition = function (nodeA, nodeB) {
            var aParents = []; var bParents = []; var current, sharedParent, siblings, aSibling, bSibling, idx; if (nodeA === nodeB) { return 0; }
            current = nodeA; while (current) { aParents.unshift(current); current = current.parent; }
            current = nodeB; while (current) { bParents.unshift(current); current = current.parent; }
            idx = 0; while (aParents[idx] === bParents[idx]) { idx++; }
            if (idx === 0) { return POSITION.DISCONNECTED; }
            sharedParent = aParents[idx - 1]; siblings = sharedParent.children; aSibling = aParents[idx]; bSibling = bParents[idx]; if (siblings.indexOf(aSibling) > siblings.indexOf(bSibling)) {
                if (sharedParent === nodeB) { return POSITION.FOLLOWING | POSITION.CONTAINED_BY; }
                return POSITION.FOLLOWING;
            } else {
                if (sharedParent === nodeA) { return POSITION.PRECEDING | POSITION.CONTAINS; }
                return POSITION.PRECEDING;
            }
        }; exports.uniqueSort = function (nodes) {
            var idx = nodes.length, node, position; nodes = nodes.slice(); while (--idx > -1) { node = nodes[idx]; position = nodes.indexOf(node); if (position > -1 && position < idx) { nodes.splice(idx, 1); } }
            nodes.sort(function (a, b) {
                var relative = comparePos(a, b); if (relative & POSITION.PRECEDING) { return -1; } else if (relative & POSITION.FOLLOWING) { return 1; }
                return 0;
            }); return nodes;
        };
    }), (function (module, exports, __webpack_require__) {
        module.exports = CollectingHandler; function CollectingHandler(cbs) { this._cbs = cbs || {}; this.events = []; }
        var EVENTS = __webpack_require__(54).EVENTS; Object.keys(EVENTS).forEach(function (name) { if (EVENTS[name] === 0) { name = "on" + name; CollectingHandler.prototype[name] = function () { this.events.push([name]); if (this._cbs[name]) this._cbs[name](); }; } else if (EVENTS[name] === 1) { name = "on" + name; CollectingHandler.prototype[name] = function (a) { this.events.push([name, a]); if (this._cbs[name]) this._cbs[name](a); }; } else if (EVENTS[name] === 2) { name = "on" + name; CollectingHandler.prototype[name] = function (a, b) { this.events.push([name, a, b]); if (this._cbs[name]) this._cbs[name](a, b); }; } else { throw Error("wrong number of arguments"); } }); CollectingHandler.prototype.onreset = function () { this.events = []; if (this._cbs.onreset) this._cbs.onreset(); }; CollectingHandler.prototype.restart = function () { if (this._cbs.onreset) this._cbs.onreset(); for (var i = 0, len = this.events.length; i < len; i++) { if (this._cbs[this.events[i][0]]) { var num = this.events[i].length; if (num === 1) { this._cbs[this.events[i][0]](); } else if (num === 2) { this._cbs[this.events[i][0]](this.events[i][1]); } else { this._cbs[this.events[i][0]](this.events[i][1], this.events[i][2]); } } } };
    }), (function (module, exports, __webpack_require__) { "use strict"; module.exports = function (text) { return text.replace(new RegExp("<yoastmark[^>]*>", "g"), "").replace(new RegExp("</yoastmark>", "g"), ""); }; })]);